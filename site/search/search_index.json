{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Leetcode notes", "text": "<p>Welcome to homepage. Latest problem</p>"}, {"location": "#latest-problem", "title": "Latest problem", "text": "Problem Last update 542. 01 Matrix 9:50 AM - August 18, 2023 86. Partition List 9:35 AM - August 18, 2023 239. Sliding Window Maximum 7:31 AM - August 18, 2023 81. Search in Rotated Sorted Array II 9:35 AM - August 18, 2023 63. Unique Paths II 9:06 AM - August 18, 2023"}, {"location": "#separated-by-language", "title": "Separated by language", "text": ""}, {"location": "#c", "title": "C", "text": "Problem Last update 81. Search in Rotated Sorted Array II 9:35 AM - August 18, 2023 63. Unique Paths II 9:06 AM - August 18, 2023 74. Search a 2D Matrix 7:46 AM - August 18, 2023 50. Pow(x, n) 7:32 AM - August 18, 2023 80. Remove Duplicates from Sorted Array II 7:31 AM - August 18, 2023"}, {"location": "#python", "title": "Python", "text": "Problem Last update 542. 01 Matrix 9:50 AM - August 18, 2023 122. Best Time to Buy and Sell Stock II 9:05 AM - August 18, 2023 50. Pow(x, n) 7:32 AM - August 18, 2023 46. Permutations 7:32 AM - August 18, 2023 33. Search in Rotated Sorted Array 7:32 AM - August 18, 2023"}, {"location": "#java", "title": "Java", "text": "Problem Last update 63. Unique Paths II 9:06 AM - August 18, 2023 80. Remove Duplicates from Sorted Array II 7:31 AM - August 18, 2023"}, {"location": "#rust", "title": "Rust", "text": "Problem Last update 63. Unique Paths II 9:06 AM - August 18, 2023"}, {"location": "#misc", "title": "Misc.", "text": "<p>This page is auto generated using Dataview Query Language. Inline Fields is used for natural-looking annotation, via a <code>&lt;Key&gt;:: &lt;Value&gt;</code></p>"}, {"location": "tags/", "title": "Tags", "text": ""}, {"location": "tags/#bfs", "title": "BFS", "text": "<ul> <li>46. Permutations</li> <li>542. 01 Matrix</li> </ul>"}, {"location": "tags/#array", "title": "array", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>215. Kth Largest Element in an Array</li> <li>274. H Index</li> </ul>"}, {"location": "tags/#binary_search", "title": "binary_search", "text": "<ul> <li>74. Search a 2D Matrix</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>274. H Index</li> </ul>"}, {"location": "tags/#bit_manipulation", "title": "bit_manipulation", "text": "<ul> <li>50. Pow(x, n)</li> </ul>"}, {"location": "tags/#c", "title": "c", "text": "<ul> <li>50. Pow(x, n)</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> </ul>"}, {"location": "tags/#cache", "title": "cache", "text": "<ul> <li>84. Largest Rectangle in Histogram</li> </ul>"}, {"location": "tags/#coding_chalenge", "title": "coding_chalenge", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>50. Pow(x, n)</li> <li>55. Jump Game</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>77. Combinations</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>86. Partition List</li> <li>88. Merge Sorted Array</li> <li>91. Decode Ways</li> <li>94. Binary Tree Inorder Traversal</li> <li>98. Validate Binary Search Tree</li> <li>101. Symmetric Tree</li> <li>102. Binary Tree Level Order Traversal</li> <li>103. Binary Tree Zigzag Level Order Traversal</li> <li>104. Maximum Depth of Binary Tree</li> <li>108. Convert Sorted Array to Binary Search Tree</li> <li>116. Populating Next Right Pointers in Each Node</li> <li>118. Pascal\u2019s Triangle</li> <li>121. Best Time to Buy and Sell Stock</li> <li>122. Best Time to Buy and Sell Stock II</li> <li>124. Binary Tree Maximum Path Sum</li> <li>125. Valid Palindrome</li> <li>130. Surrounded Regions</li> <li>131. Palindrome Partitioning</li> <li>134. Gas Station</li> <li>136. Single Number</li> <li>139. Word Break</li> <li>141. Linked List Cycle</li> <li>146. LRU Cache</li> <li>169. Majority Element</li> <li>171. Excel Sheet Column Number</li> <li>190. Reverse Bits</li> <li>191. Number of 1 Bits</li> <li>202. Happy Number</li> <li>206. Reverse Linked List</li> <li>207. Course Schedule</li> <li>215. Kth Largest Element in an Array</li> <li>217. Contains Duplicate</li> <li>234. Palindrome Linked List</li> <li>239. Sliding Window Maximum</li> <li>242. Valid Anagram</li> <li>268. Missing Number</li> <li>274. H Index</li> <li>283. Move Zeroes</li> <li>326. Power of Three</li> <li>344. Reverse String</li> <li>350. Intersection of Two Arrays II</li> <li>373. Find K Pairs with Smallest Sums</li> <li>380. Insert Delete GetRandom O(1)</li> <li>387. First Unique Character in a String</li> <li>412. Fizz Buzz</li> <li>435. Non overlapping Intervals</li> <li>445. Add Two Numbers II</li> <li>518. Coin Change II</li> <li>530. Minimum Absolute Difference in BST</li> <li>542. 01 Matrix</li> <li>688. Knight Probability in Chessboard</li> <li>712. Minimum ASCII Delete Sum for Two Strings</li> <li>714. Best Time to Buy and Sell Stock with Transaction Fee</li> <li>735. Asteroid Collision</li> <li>802. Find Eventual Safe States</li> <li>852. Peak Index in a Mountain Array</li> <li>859. Buddy Strings</li> <li>894. All Possible Full Binary Trees</li> <li>1125. Smallest Sufficient Team</li> <li>1143. Longest Common Subsequence</li> <li>1569. Number of Ways to Reorder Array to Get Same BST</li> <li>1601. Maximum Number of Achievable Transfer Requests</li> <li>1615. Maximal Network Rank</li> <li>1751. Maximum Number of Events That Can Be Attended II</li> <li>1802. Maximum Value at a Given Index in a Bounded Array</li> <li>2008. Maximum Earnings From Taxi</li> <li>2140. Questions With Brainpower</li> <li>2141. Maximum Running Time of N Computers</li> <li>2328. Number of Increasing Paths in a Grid</li> <li>2352. Equal Row and Column Pairs   solve</li> <li>2369. Check if There is a Valid Partition For The Array</li> <li>2448. Minimum Cost to Make Array Equal</li> <li>2462. Total Cost to Hire K Workers</li> <li>2616. Minimize the Maximum Difference of Pairs</li> </ul>"}, {"location": "tags/#computer_sience", "title": "computer_sience", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>50. Pow(x, n)</li> <li>55. Jump Game</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>77. Combinations</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>86. Partition List</li> <li>88. Merge Sorted Array</li> <li>91. Decode Ways</li> <li>94. Binary Tree Inorder Traversal</li> <li>98. Validate Binary Search Tree</li> <li>101. Symmetric Tree</li> <li>102. Binary Tree Level Order Traversal</li> <li>103. Binary Tree Zigzag Level Order Traversal</li> <li>104. Maximum Depth of Binary Tree</li> <li>108. Convert Sorted Array to Binary Search Tree</li> <li>116. Populating Next Right Pointers in Each Node</li> <li>118. Pascal\u2019s Triangle</li> <li>121. Best Time to Buy and Sell Stock</li> <li>122. Best Time to Buy and Sell Stock II</li> <li>124. Binary Tree Maximum Path Sum</li> <li>125. Valid Palindrome</li> <li>130. Surrounded Regions</li> <li>131. Palindrome Partitioning</li> <li>134. Gas Station</li> <li>136. Single Number</li> <li>139. Word Break</li> <li>141. Linked List Cycle</li> <li>146. LRU Cache</li> <li>169. Majority Element</li> <li>171. Excel Sheet Column Number</li> <li>190. Reverse Bits</li> <li>191. Number of 1 Bits</li> <li>202. Happy Number</li> <li>206. Reverse Linked List</li> <li>207. Course Schedule</li> <li>215. Kth Largest Element in an Array</li> <li>217. Contains Duplicate</li> <li>234. Palindrome Linked List</li> <li>239. Sliding Window Maximum</li> <li>242. Valid Anagram</li> <li>268. Missing Number</li> <li>274. H Index</li> <li>283. Move Zeroes</li> <li>326. Power of Three</li> <li>344. Reverse String</li> <li>350. Intersection of Two Arrays II</li> <li>373. Find K Pairs with Smallest Sums</li> <li>380. Insert Delete GetRandom O(1)</li> <li>387. First Unique Character in a String</li> <li>412. Fizz Buzz</li> <li>435. Non overlapping Intervals</li> <li>445. Add Two Numbers II</li> <li>518. Coin Change II</li> <li>530. Minimum Absolute Difference in BST</li> <li>542. 01 Matrix</li> <li>688. Knight Probability in Chessboard</li> <li>712. Minimum ASCII Delete Sum for Two Strings</li> <li>714. Best Time to Buy and Sell Stock with Transaction Fee</li> <li>735. Asteroid Collision</li> <li>802. Find Eventual Safe States</li> <li>852. Peak Index in a Mountain Array</li> <li>859. Buddy Strings</li> <li>894. All Possible Full Binary Trees</li> <li>1125. Smallest Sufficient Team</li> <li>1143. Longest Common Subsequence</li> <li>1569. Number of Ways to Reorder Array to Get Same BST</li> <li>1601. Maximum Number of Achievable Transfer Requests</li> <li>1615. Maximal Network Rank</li> <li>1751. Maximum Number of Events That Can Be Attended II</li> <li>1802. Maximum Value at a Given Index in a Bounded Array</li> <li>2008. Maximum Earnings From Taxi</li> <li>2140. Questions With Brainpower</li> <li>2141. Maximum Running Time of N Computers</li> <li>2328. Number of Increasing Paths in a Grid</li> <li>2352. Equal Row and Column Pairs   solve</li> <li>2369. Check if There is a Valid Partition For The Array</li> <li>2448. Minimum Cost to Make Array Equal</li> <li>2462. Total Cost to Hire K Workers</li> <li>2616. Minimize the Maximum Difference of Pairs</li> </ul>"}, {"location": "tags/#divide_and_conquer", "title": "divide_and_conquer", "text": "<ul> <li>215. Kth Largest Element in an Array</li> </ul>"}, {"location": "tags/#dynamic_programing", "title": "dynamic_programing", "text": "<ul> <li>55. Jump Game</li> </ul>"}, {"location": "tags/#dynamic_programming", "title": "dynamic_programming", "text": "<ul> <li>63. Unique Paths II</li> </ul>"}, {"location": "tags/#graph", "title": "graph", "text": "<ul> <li>1615. Maximal Network Rank</li> </ul>"}, {"location": "tags/#heap_c_lang", "title": "heap_c_lang", "text": "<ul> <li>74. Search a 2D Matrix</li> </ul>"}, {"location": "tags/#java", "title": "java", "text": "<ul> <li>63. Unique Paths II</li> <li>80. Remove Duplicates from Sorted Array II</li> </ul>"}, {"location": "tags/#leetcode", "title": "leetcode", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>50. Pow(x, n)</li> <li>55. Jump Game</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>77. Combinations</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>86. Partition List</li> <li>88. Merge Sorted Array</li> <li>91. Decode Ways</li> <li>94. Binary Tree Inorder Traversal</li> <li>98. Validate Binary Search Tree</li> <li>101. Symmetric Tree</li> <li>102. Binary Tree Level Order Traversal</li> <li>103. Binary Tree Zigzag Level Order Traversal</li> <li>104. Maximum Depth of Binary Tree</li> <li>108. Convert Sorted Array to Binary Search Tree</li> <li>116. Populating Next Right Pointers in Each Node</li> <li>118. Pascal\u2019s Triangle</li> <li>121. Best Time to Buy and Sell Stock</li> <li>122. Best Time to Buy and Sell Stock II</li> <li>124. Binary Tree Maximum Path Sum</li> <li>125. Valid Palindrome</li> <li>130. Surrounded Regions</li> <li>131. Palindrome Partitioning</li> <li>134. Gas Station</li> <li>136. Single Number</li> <li>139. Word Break</li> <li>141. Linked List Cycle</li> <li>146. LRU Cache</li> <li>169. Majority Element</li> <li>171. Excel Sheet Column Number</li> <li>190. Reverse Bits</li> <li>191. Number of 1 Bits</li> <li>202. Happy Number</li> <li>206. Reverse Linked List</li> <li>207. Course Schedule</li> <li>215. Kth Largest Element in an Array</li> <li>217. Contains Duplicate</li> <li>234. Palindrome Linked List</li> <li>239. Sliding Window Maximum</li> <li>242. Valid Anagram</li> <li>268. Missing Number</li> <li>274. H Index</li> <li>283. Move Zeroes</li> <li>326. Power of Three</li> <li>344. Reverse String</li> <li>350. Intersection of Two Arrays II</li> <li>373. Find K Pairs with Smallest Sums</li> <li>380. Insert Delete GetRandom O(1)</li> <li>387. First Unique Character in a String</li> <li>412. Fizz Buzz</li> <li>435. Non overlapping Intervals</li> <li>445. Add Two Numbers II</li> <li>518. Coin Change II</li> <li>530. Minimum Absolute Difference in BST</li> <li>542. 01 Matrix</li> <li>688. Knight Probability in Chessboard</li> <li>712. Minimum ASCII Delete Sum for Two Strings</li> <li>714. Best Time to Buy and Sell Stock with Transaction Fee</li> <li>735. Asteroid Collision</li> <li>802. Find Eventual Safe States</li> <li>852. Peak Index in a Mountain Array</li> <li>859. Buddy Strings</li> <li>894. All Possible Full Binary Trees</li> <li>1125. Smallest Sufficient Team</li> <li>1143. Longest Common Subsequence</li> <li>1569. Number of Ways to Reorder Array to Get Same BST</li> <li>1601. Maximum Number of Achievable Transfer Requests</li> <li>1615. Maximal Network Rank</li> <li>1751. Maximum Number of Events That Can Be Attended II</li> <li>1802. Maximum Value at a Given Index in a Bounded Array</li> <li>2008. Maximum Earnings From Taxi</li> <li>2140. Questions With Brainpower</li> <li>2141. Maximum Running Time of N Computers</li> <li>2328. Number of Increasing Paths in a Grid</li> <li>2352. Equal Row and Column Pairs   solve</li> <li>2369. Check if There is a Valid Partition For The Array</li> <li>2448. Minimum Cost to Make Array Equal</li> <li>2462. Total Cost to Hire K Workers</li> <li>2616. Minimize the Maximum Difference of Pairs</li> </ul>"}, {"location": "tags/#matrix", "title": "matrix", "text": "<ul> <li>74. Search a 2D Matrix</li> </ul>"}, {"location": "tags/#network", "title": "network", "text": "<ul> <li>LAP 1   Routing</li> </ul>"}, {"location": "tags/#python", "title": "python", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>50. Pow(x, n)</li> <li>55. Jump Game</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>77. Combinations</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> </ul>"}, {"location": "tags/#recusion", "title": "recusion", "text": "<ul> <li>50. Pow(x, n)</li> <li>77. Combinations</li> </ul>"}, {"location": "tags/#runtime_memory_alocation", "title": "runtime_memory_alocation", "text": "<ul> <li>74. Search a 2D Matrix</li> </ul>"}, {"location": "tags/#rust", "title": "rust", "text": "<ul> <li>63. Unique Paths II</li> </ul>"}, {"location": "tags/#sort", "title": "sort", "text": "<ul> <li>215. Kth Largest Element in an Array</li> </ul>"}, {"location": "tags/#stack_c_lang", "title": "stack_c_lang", "text": "<ul> <li>74. Search a 2D Matrix</li> </ul>"}, {"location": "tags/#tree", "title": "tree", "text": "<ul> <li>1569. Number of Ways to Reorder Array to Get Same BST</li> </ul>"}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/", "title": "LAP 1   Routing", "text": "", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#problem", "title": "Problem", "text": "<p>Consider we having this network NETWORK LAP 1 - VPN route, route the Admin to access the Private LAN (the Router can\u2019t not access and change route table)</p> <p>The 192.168.1.254 gateway have 2 network card to make route traffic between 192.168.1.0/24 and  192.168.2.0/24</p> <p>Jump server also have two network card too. But all other Private Lan 2 client only have 192.168.1.254 as default gateway</p> <p></p>", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#solve", "title": "Solve", "text": "<p>To get to the Answer </p> <p>We mush make sure we have the packet can be route forward and backward. In this problem, we have 2 new hop gateway (with 3 manual route) that need manual config.</p>", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#pre-require", "title": "Pre require", "text": "<p>The network card in Jump server make the routing too complex thus being remove and use 192.168.1.254 as gateway to access the Private Lan 2 client instead. </p> <pre><code>sudo nwtui\n</code></pre> <p>Then process to deactivate and disable Lan 2 network interface on the Jump server </p>", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#hop-1", "title": "Hop 1:", "text": "", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#route-admin-pc-to-jump-server", "title": "Route Admin PC to Jump server", "text": "<p>This is needed so that Admin PC can understand and find 192.168.2.0/24 network</p> <p>This require we add to our gateway routing table (which is on VPN server)</p> <p></p> <pre><code>route 192.168.2.0/24 via 10.243.143.44\n</code></pre> <p>or</p> <pre><code>sudo route add -net 192.168.2.0/24 gw 10.243.143.44\n</code></pre> <p>Result route table on Admin PC after update should look like this</p> <pre><code>\u2192 route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         net.xxx         0.0.0.0         UG    600    0        0 tun0\n10.243.0.0      0.0.0.0         255.255.0.0     U     0      0        0 &lt;VPN_inf&gt;\nlink-local      0.0.0.0         255.255.0.0     U     1000   0        0 br-1da3c1d75167\n192.168.2.0     10.243.143.44   255.255.255.0   UG    0      0        0 &lt;VPN_inf&gt;\n</code></pre>", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#adding-forwarding-request-on-jump-server", "title": "Adding forwarding request on Jump server", "text": "<p>To route the packet back, Jump server have to have IPv4 forwarding capacity to allow traffic to flow through as local VPN client (.44) is also acting as a router for other devices (.43)</p> <pre><code>sudo sysctl -w net.ipv4.ip_forward=1\n</code></pre>", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#or-by-config-file", "title": "Or by config file", "text": "<pre><code>sudo nano /etc/sysctl.conf\n</code></pre> <p>Add or uncomment the following line:</p> <pre><code>net.ipv4.ip_forward=1\n</code></pre> <p>And then apply</p> <pre><code>sudo sysctl -p\n</code></pre>", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#hop-2-route-packet-between-jump-server-and-gateway", "title": "Hop 2: Route packet between Jump server and Gateway", "text": "", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#gateway-route-traffic-over-vpn-network", "title": "Gateway route traffic over VPN network", "text": "<p>On the gateway, we need to enable IP forwarding so that it can forward traffic from the 192.168.2.0/24 subnet to the VPN client:</p> <p>Via GUI</p> <p></p> <p>Check the Available Network Interfaces:</p> <p>To find out the name of the network interface you want to route traffic through, run the following command:</p> <pre><code>netsh interface show interface\n</code></pre> <p>Identify the name of the interface you want to use (e.g., <code>Lan1_network_interface</code>). And add route</p> <pre><code>route add 10.243.0.0 mask 255.255.255.0 192.168.1.98 IF Lan1_network_interface\n</code></pre> <p>You may want to use metric so our manual route have higher priority</p>", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#jump-route-traffic-over-private-lan2-network", "title": "Jump route traffic over Private Lan2 Network", "text": "<p>On the Jump server, we need to enable IP forwarding so that it can forward traffic from the VPN client to the 192.168.2.0/24 subnet:</p> <pre><code>sudo route add -net 192.168.2.0/24 gw 192.168.1.254\n</code></pre>", "tags": ["network"]}, {"location": "Networks/Lap01/LAP%201%20-%20Routing/#hop-3-gateway-to-private-lan2", "title": "Hop 3: Gateway to Private LAN2", "text": "<p>Just use default network interface, Lan2 client only know to send the packet back to our gateway (via <code>192.168.2.254</code>)</p> <p>Our gateway <code>192.168.1.254</code> to <code>192.168.2.254</code> have 2 network interface, so there is no need for further config.</p>", "tags": ["network"]}, {"location": "Program%20Language/C%20language/", "title": "C language", "text": "<p>A good language for deep understanding the machine way of handle thing, while not bloated with overcomplicated syntax</p> <p>List of problem that I used c to solve</p> Problem Last update 81. Search in Rotated Sorted Array II 9:35 AM - August 18, 2023 63. Unique Paths II 9:06 AM - August 18, 2023 74. Search a 2D Matrix 7:46 AM - August 18, 2023 50. Pow(x, n) 7:32 AM - August 18, 2023 80. Remove Duplicates from Sorted Array II 7:31 AM - August 18, 2023"}, {"location": "Program%20Language/Python/", "title": "Python", "text": "<p>A good language for fast implementations. But quite fast in runtimes on it own</p> <p>List of problem that I used python to solve</p> Problem Last update 542. 01 Matrix 9:50 AM - August 18, 2023 81. Search in Rotated Sorted Array II 9:35 AM - August 18, 2023 63. Unique Paths II 9:06 AM - August 18, 2023 122. Best Time to Buy and Sell Stock II 9:05 AM - August 18, 2023 77. Combinations 7:46 AM - August 18, 2023 74. Search a 2D Matrix 7:46 AM - August 18, 2023 55. Jump Game 7:32 AM - August 18, 2023 50. Pow(x, n) 7:32 AM - August 18, 2023 46. Permutations 7:32 AM - August 18, 2023 33. Search in Rotated Sorted Array 7:32 AM - August 18, 2023"}, {"location": "Program%20Language/Rush/", "title": "Rush", "text": "<p>List of problem that I used rust to solve</p> Problem Last update 63. Unique Paths II 9:06 AM - August 18, 2023"}, {"location": "Program%20Language/Rush/#variable", "title": "Variable", "text": "<ul> <li>Assigned using <code>let</code> keyword</li> <li>Print to standard output by <code>print! ( )</code> or <code>println! ()</code></li> <li>Scope of a variable defined by the block of code in which it is declared</li> <li>Function is a named block of code that is reusable</li> <li>Shadowing allows a variable to be re-declared in the same scope with the same name</li> </ul>"}, {"location": "Query%20Language/Dataview%20Query%20Language/", "title": "Dataview Query Language", "text": "<p>Have some use case in Obsidian notes, this note is for reference that what I used</p>"}, {"location": "Query%20Language/Dataview%20Query%20Language/#query-structure", "title": "Query structure", "text": "<p>Or LIST/TABLE can be used to render the content</p> <pre><code>TABLE WITHOUT ID \"[[\" + file.name + \"|\" + file.name + \"]]\" as \"Problem\", &lt;column&gt;\nFROM &lt;file/folder/tag&gt;\nWHERE &lt;expression&gt;\nSORT &lt;column&gt; (DESC)\nLIMIT &lt;number&gt;\n</code></pre>"}, {"location": "Query%20Language/Dataview%20Query%20Language/#metadata", "title": "Metadata:", "text": "<ul> <li><code>file.mtime</code> : File modify time</li> <li><code>file.tags</code> : File tags as array</li> <li><code>&lt;meta-inlines&gt;</code> : reference to metadata</li> </ul>"}, {"location": "Query%20Language/Dataview%20Query%20Language/#adding-metadata", "title": "Adding metadata:", "text": ""}, {"location": "Query%20Language/Dataview%20Query%20Language/#frontmatter", "title": "Frontmatter", "text": "<pre><code>---\ntags:\n- &lt;anything&gt;\n---\n</code></pre>"}, {"location": "Query%20Language/Dataview%20Query%20Language/#inline", "title": "Inline", "text": "<ul> <li><code>&lt;meta-inlines&gt;:: &lt;anything&gt;</code></li> </ul>"}, {"location": "Query%20Language/Dataview%20Query%20Language/#function", "title": "Function", "text": "<ul> <li><code>econtain(&lt;array/string&gt;)</code> : Check for exact contain of element in list array</li> </ul>"}, {"location": "notes/Leetcode%2010-100/33.%20Search%20in%20Rotated%20Sorted%20Array/", "title": "33. Search in Rotated Sorted Array", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/33.%20Search%20in%20Rotated%20Sorted%20Array/#problem", "title": "Problem", "text": "<p>There is an integer array <code>nums</code> sorted in ascending order (with distinct values).</p> <p>Prior to being passed to your function, <code>nums</code> is possibly rotated at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (0-indexed). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p> <p>Given the array <code>nums</code> after the possible rotation and an integer <code>target</code>, return the index of <code>target</code> if it is in <code>nums</code>, or <code>-1</code> if it is not in <code>nums</code>.</p> <p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p> <p>Example 1:</p> <p>Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4</p> <p>Example 2:</p> <p>Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1</p> <p>Example 3:</p> <p>Input: nums = [1], target = 0 Output: -1</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 5000</code></li> <li><code>-104 &lt;= nums[i] &lt;= 104</code></li> <li>All values of <code>nums</code> are unique.</li> <li><code>nums</code> is an ascending array that is possibly rotated.</li> <li><code>-104 &lt;= target &lt;= 104</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/33.%20Search%20in%20Rotated%20Sorted%20Array/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/33.%20Search%20in%20Rotated%20Sorted%20Array/#find-the-shift-point-of-the-sorted-array-and-binary-search", "title": "Find the shift point of the sorted array and Binary search", "text": "<p>Source code: https://github.com/ylsama/leetcode/blob/main/33.py</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/33.%20Search%20in%20Rotated%20Sorted%20Array/#shift-point-finder", "title": "Shift point finder", "text": "<p>We represent the sorted <code>nums</code> array as <code>[1..n]</code>, the shift point is <code>shiftPoint</code>, we have:</p> <ul> <li>Sorted <code>nums</code> array: <code>nums[1] &lt; nums[2] &lt; ... &lt; nums[shiftPoint] &lt; nums[shiftPoint+1] &lt; .. &lt; nums[n]</code>(as define: all values of <code>nums[i]</code> are unique)</li> <li><code>0 &lt;= shiftPoint &lt; n</code> (or <code>sp</code> for sort)</li> </ul> <p>The problem give us <code>nums</code> array being shifted by <code>sp</code> so we can represent it like this:</p> index [1] [2] \u2026 [n- sp] [n- sp + 1] \u2026 [n] nums_index 1 2 \u2026 n- sp n- sp +1 \u2026 n nums_value sp +1 sp+2 \u2026 n 1 \u2026 sp <p>Then shift point <code>sp</code> is the only point where: ^9bc286</p> <ul> <li>every element with <code>nums_index &lt;= n- sp</code> have <code>nums_value &gt; nums_value[1]</code></li> <li>every element with <code>nums_index &gt;  n- sp</code> have <code>nums_value &lt; nums_value[1]</code></li> </ul> <p>We can use binary search to find <code>n-sp</code>:</p> <ol> <li>Start with `pointerLeftIndex = 1, pointerRightIndex = n+1</li> <li>Calculate the middle value: <code>midIndex = (left + right)//2</code></li> <li>If <code>nums_value[midIndex] &gt; nums_value[1]</code> then <code>midIndex &lt;= n- sp</code> and we can shift the <code>pointerLeftIndex = midIndex</code>, else we shift the <code>pointerRightIndex = midIndex</code></li> <li>Repeat calculated <code>midIndex</code> value and shift <code>pointerLeft/RightIndex</code> until <code>pointerLeft == midIndex == (left + right)//2</code> , which also mean/the same as  <code>pointerLeft  +1 == pointerRightIndex</code></li> <li>We have <code>pointerLeft</code> is the <code>n-sp</code> ; return <code>n-pointerLeft</code></li> </ol> <p>How can <code>pointerLeft</code> is <code>n-sp</code>, basically we trying to find <code>(left, right) = (index,index+1)</code> pair using the binary search that have:</p> <ol> <li><code>pointerLeftIndex &gt; nums_value[1]</code></li> <li><code>pointerRightIndex &lt; nums_value[1]</code></li> <li><code>pointerLeftIndex == pointerRightIndex - 1</code> We conclude using [[33. Search in Rotated Sorted Array#^9bc286|the analysis about the <code>sp</code> element before]] </li> </ol> <pre><code>from math import log, trunc\nfrom random import randint\nfrom typing import List\nclass Solution:\ndef findShiftPoint(self):\nshiftPoint = -1\nisFound = False\n# Python index is from 0 .. n-1\npointerLeftIndex = 0\npointerRightIndex = len(self.nums)\nMAX_CAP_BINARY_SEARCH = trunc(log(len(self.nums), 2))+1\nfor i in range(MAX_CAP_BINARY_SEARCH):\nmidIndex = (pointerLeftIndex + pointerRightIndex) // 2\nif pointerLeftIndex == midIndex:\nbreak\nif  self.nums[midIndex] &gt; self.nums[0]:\npointerLeftIndex = midIndex\nelse:\npointerRightIndex = midIndex\nif pointerLeftIndex+1 == pointerRightIndex:\nshiftPoint = len(self.nums)-1 - pointerLeftIndex\nisFound = True\nelse:\nraise \"Logic error, can't find shiftPoint in log(n) time\"\nreturn (shiftPoint, isFound)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/33.%20Search%20in%20Rotated%20Sorted%20Array/#binary-search-implemetaion", "title": "Binary search implemetaion", "text": "<p>After found the shift point, we can treat <code>nums</code> as two <code>seperated</code> sorted array and we can use normal binary search to find the target on each one. <pre><code>    def binarySearch(self, startIndex,endIndex, target):\ntargetIndex, isFound = -1, False\nleft = startIndex-1\nright = endIndex +1\nMAX_CAP_BINARY_SEARCH = trunc(log(len(self.nums), 2))+1\nfor i in range(MAX_CAP_BINARY_SEARCH):\nmidIndex = (left + right) // 2\nif left == midIndex:\nbreak \nif self.nums[midIndex] &lt;= target:\nleft = midIndex\nelse:\nright = midIndex\nif left+1 == right:\ntargetIndex = left\nif startIndex &lt;= targetIndex &lt;= endIndex:\nisFound = self.nums[targetIndex] == target\nelse:\nraise \"Logic error, can't find targetIndex in log(n) times\"\nreturn (targetIndex, isFound)\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/33.%20Search%20in%20Rotated%20Sorted%20Array/#final-main-function", "title": "Final main function", "text": "<p>Our final main function <code>search</code> procedure:</p> <ol> <li>Using <code>findShiftPoint</code> to find the shift point of the input array</li> <li>Using <code>binarySearch</code> to find the target in each sorted array</li> <li>If found the target, update <code>result</code> variable</li> <li>Return <code>result</code> </li> </ol> <pre><code>    def search(self, nums: List[int], target: int) -&gt; int:\nself.nums = nums\nself.target = target\nn = len(nums)\nresult = -1\nshiftPoint, isFound = self.findShiftPoint()\nif not isFound:\nraise \"can't find shift point, logic fail\"\ntargetIndex, isFound = self.binarySearch(0, n- shiftPoint -1, target)\nif isFound:\nresult = targetIndex\ntargetIndex, isFound = self.binarySearch(n- shiftPoint,n-1, target)\nif isFound:\nresult = targetIndex\nreturn result\n</code></pre> <p>You can test the function using this main function <pre><code>def main():\na = Solution()\n# Example 1:\n# Input\nnums = [4,5,6,7,0,1,2]\ntarget = 0\n# Output \nresult = 4\nprint (\"Test 1 is\", a.search(nums, target) == result)\n# Example 2:\n# Input: \nnums = [4,5,6,7,0,1,2]\ntarget = 3\n# Output:\nresult = -1\nprint (\"Test 2 is\", a.search(nums, target) == result)\n# Example 3:\n# Input: \nnums = [1]\ntarget = 0\n# Output: \nresult = -1\nprint (\"Test 3 is\", a.search(nums, target) == result)\n# Constraints test:\n# 1 &lt;= nums.length &lt;= 5000\n# -10**4 &lt;= nums[i] &lt;= 10**4\nnums = [i for i in range(5000)]\nshift = randint(0, 4999)\nnums = nums[shift:] + nums[:shift]\n# All values of nums are unique.\n# nums is an ascending array that is possibly rotated.\n# -10**4 &lt;= target &lt;= 10**4\ntarget = 30\nresult = (shift + target) % 5000\nprint (\"Test limit is OK\", a.search(nums, target) == result)\nif __name__ == \"__main__\":\nmain()\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/45.%20Jump%20Game%20II/", "title": "45. Jump Game II", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/45.%20Jump%20Game%20II/#problem", "title": "Problem", "text": "<p>You are given a 0-indexed array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.</p> <p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:</p> <ul> <li><code>0 &lt;= j &lt;= nums[i]</code> and</li> <li><code>i + j &lt; n</code></li> </ul> <p>Return the minimum number of jumps to reach <code>nums[n - 1]</code>. The test cases are generated such that you can reach <code>nums[n - 1]</code>.</p> <p>Example 1:</p> <p>Input: nums = [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</p> <p>Example 2:</p> <p>Input: nums = [2,3,0,1,4] Output: 2</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10**4</code></li> <li><code>0 &lt;= nums[i] &lt;= 1000</code></li> <li>It\u2019s guaranteed that you can reach <code>nums[n - 1]</code>.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/45.%20Jump%20Game%20II/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/45.%20Jump%20Game%20II/#water-falling", "title": "Water falling", "text": "<p>Following a minimized greedy/dynamic programming minimized path problem from graph.</p> <ul> <li>Calling the <code>minimum</code> array is to store the total minimal step needed to reach each element, <code>minimum[i]</code> correspond to <code>element[i]</code>. At first, <code>minimum</code> array isn\u2019t set, as none element is being processed.</li> <li>We start at <code>index=0</code>, cost <code>step=0</code> jump step. As we already start at the first element. This also mean we have <code>minimum[0] = 0</code></li> <li>From next, we start a loop<ul> <li>We find a element with index <code>pos</code> that have minimum <code>step</code> value, that is not visited/process</li> <li>Flag it as already visited</li> <li>Update all other element our current <code>pos</code> can jump into new minimum (<code>step + 1</code>) if it either uninitialized or it currently have a less optimal total of step need to jump into.</li> </ul> </li> </ul> <p>This is when I also realized we dealing with a serial of number, a special case of graph data:</p> <ul> <li>The minimum jump step to each element isn\u2019t change value after initialized.</li> </ul> <p>So that mean we can just skip most of the unnecessary loop to update the <code>minimum</code>.</p> <pre><code>class Solution:\ndef jump(self, nums: List[int]) -&gt; int:\nn = len(nums)\np = 0\nminimum = [-1] * n\nminimum[0] = 0\nq = [(0, 0)]\nwhile q:\npos, step = q.pop(0)\nfor npos in range(p, min(n, pos + nums[pos]+1)):\nif minimum[npos] == -1:\nminimum[npos] = step + 1\nq.append((npos, step + 1))\np = npos\nreturn minimum[-1]\n</code></pre> <p>So I calling it water fall basically because the height being collapsing all at once  </p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "python"]}, {"location": "notes/Leetcode%2010-100/46.%20Permutations/", "title": "46. Permutations", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "BFS", "python"]}, {"location": "notes/Leetcode%2010-100/46.%20Permutations/#problem", "title": "Problem", "text": "<p>Given an array <code>nums</code> of distinct integers, return all the possible permutations. You can return the answer in any order.</p> <p>Example 1:</p> <p>Input: <code>nums = [1,2,3]</code> Output: <code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1|1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></p> <p>Example 2:</p> <p>Input: <code>nums = [0,1]</code> Output: <code>[[0,1],[1,0|0,1],[1,0]]</code></p> <p>Example 3:</p> <p>Input: <code>nums = [1]</code> Output: <code>[[1|1]]</code></p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 6</code></li> <li><code>-10 &lt;= nums[i] &lt;= 10</code></li> <li>All the integers of <code>nums</code> are unique.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "BFS", "python"]}, {"location": "notes/Leetcode%2010-100/46.%20Permutations/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "BFS", "python"]}, {"location": "notes/Leetcode%2010-100/46.%20Permutations/#dfs-or-bfs", "title": "DFS or BFS", "text": "<p>Goes through each stage of the permutations until we using all available number in <code>nums</code> array</p> <pre><code>from typing import List\nclass Solution:\ndef dfs(self, lastArray, adjNode):\nresult = []\nif len(adjNode) == 0:\nresult = lastArray\nreturn [result]\nfor node in adjNode:\nnewArray = lastArray + [node]\nnewAdjNode = adjNode - set([node])\nresult = result + self.dfs(newArray, newAdjNode)\nreturn result\ndef permute(self, nums: List[int]) -&gt; List[List[int]]:\nreturn self.dfs([], set(nums))\n</code></pre> <p>To test above code: <pre><code>def test():\na = Solution()\n# Example 1:\nnums = [1,2,3]\nresult = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1|1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nprint(\"Test 1 is\", result == a.permute(nums))\n# Example 2:\nnums = [0,1]\nresult = [[0,1],[1,0|0,1],[1,0]]\nprint(\"Test 2 is\", result == a.permute(nums))\n# Example 3:\nnums = [1]\nresult = [[1|1]]\nprint(\"Test 3 is\", result == a.permute(nums))\nif __name__ == \"__main__\":\ntest()\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "BFS", "python"]}, {"location": "notes/Leetcode%2010-100/46.%20Permutations/#reuse-global-variable", "title": "Reuse global variable", "text": "<p>Taking approach from 77. Combinations, we can try reuse some of our created array to make the code run faster, while minimize total <code>for loop</code></p> <pre><code>class Solution:\ndef permute(self, nums: List[int]) -&gt; List[List[int]]:\npath = []\ndef helper(words):\nif len(words) == 1:\nreturn [path+list(words)]\nresult = []\nt = words.copy()\nfor i in words:\npath.append(i)\nt.remove(i)\nresult += helper(t)\nt.add(i)\npath.pop()\nreturn result\nreturn helper(set(nums))\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "BFS", "python"]}, {"location": "notes/Leetcode%2010-100/50.%20Pow%28x%2C%20n%29/", "title": "50. Pow(x, n)", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "recusion", "python", "c", "bit_manipulation"]}, {"location": "notes/Leetcode%2010-100/50.%20Pow%28x%2C%20n%29/#problem", "title": "Problem", "text": "<p>Implement pow(x, n), which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>xn</code>).</p> <p>Example 1:</p> <p>Input: x = 2.00000, n = 10 Output: 1024.00000</p> <p>Example 2:</p> <p>Input: x = 2.10000, n = 3 Output: 9.26100</p> <p>Example 3:</p> <p>Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25</p> <p>Constraints:</p> <ul> <li><code>-100.0 &lt; x &lt; 100.0</code></li> <li><code>-231 &lt;= n &lt;= 231-1</code></li> <li><code>n</code> is an integer.</li> <li>Either <code>x</code> is not zero or <code>n &gt; 0</code>.</li> <li><code>-10**4 &lt;= xn &lt;= 10**4</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "recusion", "python", "c", "bit_manipulation"]}, {"location": "notes/Leetcode%2010-100/50.%20Pow%28x%2C%20n%29/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "recusion", "python", "c", "bit_manipulation"]}, {"location": "notes/Leetcode%2010-100/50.%20Pow%28x%2C%20n%29/#use-built-in-function", "title": "Use built-in function", "text": "<pre><code>class Solution(object):\ndef myPow(self, x, n):\nreturn pow(x,n)\n# return x ** n\n</code></pre> <pre><code>double myPow(double x, int n){\nreturn pow(x,n);\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "recusion", "python", "c", "bit_manipulation"]}, {"location": "notes/Leetcode%2010-100/50.%20Pow%28x%2C%20n%29/#actually-doing-some-thing", "title": "Actually doing some thing", "text": "<p>Basically, we can use the following recursive formula to calculate <code>x^n</code> efficiently: <code>pow(x,n) = pow(x,n/2) * pow(x,n/2) * pow(x,n%2)</code></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "recusion", "python", "c", "bit_manipulation"]}, {"location": "notes/Leetcode%2010-100/50.%20Pow%28x%2C%20n%29/#python", "title": "python", "text": "<p>There isn\u2019t anything stop python from working</p> <ul> <li>Implement the function directly using recursion</li> <li> <p>Case n &lt; 0: we just need to change our <code>x = 1/x</code> and can safely clear <code>n</code> sign; Keep in mind that when x == 0, this can throw error.  <pre><code>class Solution:\ndef myPow(self, x: float, n: int, cache = None) -&gt; float:\nif n ==0 :\nreturn 1\nif n &lt;0 :\nreturn self.myPow(1/x,-n)\nif n%2 == 0:\nreturn self.myPow(x, n//2) **2\nelse:\nreturn x * self.myPow(x,n//2)**2\n</code></pre></p> </li> <li> <p>The above code could re-calculate some <code>pow()</code>, to avoiding this, we can add a <code>cache</code> array. <pre><code>class Solution:\ndef myPow(self, x: float, n: int, cache = None) -&gt; float:\nif x == 0.:\nreturn 0\nif cache is None:\ncache = {}\ncache[0] = 1.\ncache[1] = x\nif x != 0:\ncache[-1] = 1./x\nif n in cache:\nreturn cache[n]\ncache[n] = self.myPow(x, n//2, cache) * self.myPow(x, n//2, cache)* self.myPow(x, n%2, cache)\nreturn cache[n]\n</code></pre></p> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "recusion", "python", "c", "bit_manipulation"]}, {"location": "notes/Leetcode%2010-100/50.%20Pow%28x%2C%20n%29/#c", "title": "C", "text": "<p>Using the same logic, but there is some thing to consider:</p> <ul> <li>We can\u2019t just revert the sign of a number, as <code>int</code> value have 32 bit, which  <code>MAX_INT == 2**31</code> and <code>MIN_INT == 2**31 - 1</code> (because of <code>0</code>) </li> <li>C not have <code>dict()</code> by default and we also don\u2019t want to create a large <code>[-2*32..2*32-1]</code> array. While this can be overcome with Hash functions, we can store only <code>[x**(2**0), x**(2**1), ..., x**(2**32)]</code> </li> <li>A number <code>n</code> is presented using binary; which mean, by using bit manipulation, we can easily split-ed <code>n</code>  to sum of = <code>(1 or 0) * 2**0 + (1 or 0) * 2**1 + ... + (1 or 0) 2 ** 32</code>. Leverage: <code>x**n = x ** (&lt;splited number which total = n&gt;)</code>. We can using this <code>binary</code> split instead of divine by 2 like python.</li> <li> <p>Here is the Try to match Python function <pre><code>double cache[32];\ndouble myPow(double x, int n){\nlong tmp_n = n;\nif (x == 0.)\nreturn 0;\nif (tmp_n &lt; 0) {\ntmp_n = -tmp_n;\nx = 1./x;\n}\ncache[0] = x;\ndouble answer = 1.;\nfor (int i = 0; i &lt; 32 || tmp_n &gt; 0; i++) {\nbool flag = tmp_n &amp; 1;\ntmp_n = tmp_n &gt;&gt; 1;\nif (i &gt; 0)\ncache[i] = cache[i-1] * cache[i-1];\nif (flag)\nanswer *= cache[i];\n}\nreturn answer;\n}\n</code></pre></p> </li> <li> <p>As we only need <code>cache[i-1]</code>, we not even need <code>cache</code> in the fist place;</p> </li> <li>The way to handle n &lt; 0 can be optimize more, instead of large the variable with 64 bit long integer.<ul> <li>In C, negative number is representing in <code>~ &lt;unsign&gt; +1</code>, which mean flipping all bit in unsigned number and then plus <code>1</code> (example <code>0001</code> become <code>1110 + 1 = 1111</code>)</li> <li>We can use this instead of <code>n = -n</code> bit flip which could result an out of memory scope error.</li> <li>We handle the separated plus <code>1</code> directly in case of <code>n &lt; 0</code> <pre><code>double myPow(double x, int n){\nif (x == 0.)\nreturn 0;\ndouble answer = 1.;\nbool flag = n &lt; 0;\nif (flag) {\nanswer /= x;\nn = ~n;\n}\nfor (;;) {\nif (n &amp; 1) {\nif (flag)\nanswer /= x;\nelse\nanswer *= x;\n}\nn = n &gt;&gt; 1;\nif (!n)\nbreak;\nx = x * x;\n}\nreturn answer;\n}\n</code></pre></li> </ul> </li> </ul> <p>Or this, separating <code>n == 0; n &gt; 0; and n &lt; 0</code> also work: <pre><code>double myPow(double base, int exp)\n{\ndouble result = 1;\nif (base == 0) return 0;\nif (exp &gt; 0)\nfor (;;) {\nif (exp &amp; 1)\nresult *= base;\nexp &gt;&gt;= 1;\nif (!exp)\nbreak;\nbase *= base;\n}\nelse if (exp &lt; 0) {\nexp = ~(exp);\nresult /= base;\nfor (;;) {\nif (exp &amp; 1)\nresult /= base;\nexp &gt;&gt;= 1;\nif (!exp)\nbreak;\nbase *= base;\n}\n}\nreturn result;\n}\n</code></pre></p> <p>Compiler optimized will help us to minimal the Assembly code in any way; Also, using C we can some how have an optimized function that can process on pair with provided standards <code>pow(x,n)</code> built-in the language, which take <code>0ms</code> to run.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "recusion", "python", "c", "bit_manipulation"]}, {"location": "notes/Leetcode%2010-100/55.%20Jump%20Game/", "title": "55. Jump Game", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "dynamic_programing"]}, {"location": "notes/Leetcode%2010-100/55.%20Jump%20Game/#problem", "title": "Problem", "text": "<p>You are given an integer array <code>nums</code>. You are initially positioned at the array\u2019s first index, and each element in the array represents your maximum jump length at that position.</p> <p>Return <code>true</code> if you can reach the last index, or <code>false</code> otherwise.</p> <p>Example 1:</p> <p>Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</p> <p>Example 2:</p> <p>Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10**4</code></li> <li><code>0 &lt;= nums[i] &lt;= 10**5</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "dynamic_programing"]}, {"location": "notes/Leetcode%2010-100/55.%20Jump%20Game/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "dynamic_programing"]}, {"location": "notes/Leetcode%2010-100/55.%20Jump%20Game/#dynamic-programming-from-top-down", "title": "Dynamic programming from top down", "text": "<p>It seem go backward is easier, as you have more information calculated than jump forward blindly</p> <ul> <li>If you go backward, and found out you can\u2019t find a good standing point to jump to the position you standing at, it mean we could just stop and return False </li> <li>We can skip some standing point if there is a better one that can jump our current end point.</li> </ul> <pre><code>from random import randint\nfrom typing import List\nclass Solution:\ndef canJump(self, nums: List[int]) -&gt; bool:\ncheckCanJump = True\nlastIndex = len(nums) - 1\nstartingPoint = 0\ncanBeSkip = [False]* len(nums)\nfor jumpEndPoint in range(lastIndex, -1, -1):\nif jumpEndPoint == startingPoint:\nbreak\nif canBeSkip[jumpEndPoint]:\ncontinue\nneededJumpLength = 1\nstandingPoint = jumpEndPoint\nfor standingPoint in range(jumpEndPoint-1, -1, -1):\nif nums[standingPoint] &gt;= neededJumpLength:\nbreak\nneededJumpLength += 1\ncanBeSkip[jumpEndPoint] = True\nif nums[standingPoint] &lt; neededJumpLength:\ncheckCanJump = False\nbreak\nreturn checkCanJump \n</code></pre> <p>This is some test for the problem <pre><code>def test():\na = Solution()\n# Example 1\nnums = [2,3,1,1,4]\nOutput = True\nresult = a.canJump(nums)\nprint(\"Test 1 is\", Output == result)\n# Example 2\nnums = [3,2,1,0,4]\nOutput = False\nresult = a.canJump(nums)\nprint(\"Test 2 is\", Output == result)\n# Example 3\nnums = [3]\nOutput = True\nresult = a.canJump(nums)\nprint(\"Test 3 is\", Output == result)\n# Example 4\nnums = [0]\nOutput = True\nresult = a.canJump(nums)\nprint(\"Test 4 is\", Output == result)\n# Example 5\nnums = [2,0]\nOutput = True\nresult = a.canJump(nums)\nprint(\"Test 5 is\", Output == result)\n# Constraints\n# 1 &lt;= nums.length &lt;= 10**4\n# 0 &lt;= nums[i] &lt;= 10**5\nnums = [randint(0,10**5) for i in range(10**4)]\nOutput = True               # Pretty much\nresult = a.canJump(nums)\nprint(\"Test time limit is OK\")\nif __name__ == \"__main__\":\ntest()\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "dynamic_programing"]}, {"location": "notes/Leetcode%2010-100/63.%20Unique%20Paths%20II/", "title": "63. Unique Paths II", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "c", "rust", "java", "array", "dynamic_programming"]}, {"location": "notes/Leetcode%2010-100/63.%20Unique%20Paths%20II/#problem", "title": "Problem", "text": "<p>You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the top-left corner (i.e., <code>grid[0][0]</code>). The robot tries to move to the bottom-right corner (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p> <p>An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include any square that is an obstacle.</p> <p>Return the number of possible unique paths that the robot can take to reach the bottom-right corner.</p> <p>The test cases are generated so that the answer will be less than or equal to <code>2 * 10**9</code>.</p> <p>Example 1:</p> <p></p> <p>Input: obstacleGrid = <code>[[0,0,0],[0,1,0],[0,0,0|0,0,0],[0,1,0],[0,0,0]]</code> Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner:</p> <ol> <li>Right -&gt; Right -&gt; Down -&gt; Down</li> <li>Down -&gt; Down -&gt; Right -&gt; Right</li> </ol> <p>Example 2:</p> <p></p> <p>Input: obstacleGrid = <code>[[0,1],[0,0|0,1],[0,0]]</code> Output: 1</p> <p>Constraints:</p> <ul> <li><code>m == obstacleGrid.length</code></li> <li><code>n == obstacleGrid[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 100</code></li> <li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "c", "rust", "java", "array", "dynamic_programming"]}, {"location": "notes/Leetcode%2010-100/63.%20Unique%20Paths%20II/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "c", "rust", "java", "array", "dynamic_programming"]}, {"location": "notes/Leetcode%2010-100/63.%20Unique%20Paths%20II/#dynamic-programming", "title": "Dynamic programming", "text": "<p>By using this information: </p> <p>The robot can only move either down or right at any point in time.</p> <p>We can use this formula to calculate the total bot path, adding up the possibility in go down and go right movement of the bot: <pre><code>totalPath[x][y] = totalPath[x-1][y] + totalPath[x][y-1] </code></pre></p> <p>Final implementation look like this <pre><code>int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize){\nint path[obstacleGridSize][*obstacleGridColSize];\npath[0][0] = !obstacleGrid[0][0];\nfor (int i = 0; i &lt; obstacleGridSize; i ++)\nfor (int j = 0; j &lt; *obstacleGridColSize; j++) {\nif (i == j &amp;&amp; j == 0) continue;\npath[i][j] = 0;\nif (obstacleGrid[i][j] == 1) continue;\nif (i &gt; 0)\npath[i][j] += path[i-1][j];\nif (j &gt; 0)\npath[i][j] += path[i][j-1];\n}\nreturn path[obstacleGridSize-1][*obstacleGridColSize-1];\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "c", "rust", "java", "array", "dynamic_programming"]}, {"location": "notes/Leetcode%2010-100/63.%20Unique%20Paths%20II/#comparison", "title": "Comparison", "text": "Time Submitted Status Runtime Memory Language 08/12/2023 15:31 Accepted 0 ms 40.8 MB java 08/12/2023 15:29 Accepted 1 ms 2 MB rust 08/12/2023 14:57 Accepted 4 ms 6.1 MB c 08/12/2023 14:48 Accepted 60 ms 16.2 MB python3 <ul> <li> <p><code>java</code>: While we can direct transfer  <code>path[0][0] = obstacleGrid[0][0] ^ 1</code> , here I try inline if <pre><code>class Solution {\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) {\nint m = obstacleGrid.length;\nint n = obstacleGrid[0].length;\nint[][] path = new int[obstacleGrid.length][obstacleGrid[0].length];\npath[0][0] = (obstacleGrid[0][0] == 0) ? 1 : 0;\nfor (int i = 0; i &lt; m; i ++)\nfor (int j = 0; j &lt; n; j++) {\nif (obstacleGrid[i][j] == 1) continue;\nif (i &gt; 0)\npath[i][j] += path[i-1][j];\nif (j &gt; 0)\npath[i][j] += path[i][j-1];\n}\nreturn path[m-1][n-1];\n}\n}\n</code></pre></p> </li> <li> <p><code>c): Randomly with time to complete the problem (it should always be</code>0ms<code>imo), but it quite nice to have</code>1, 0 -&gt; 0, 1<code>convert using</code>!<code>(</code>not<code>logical operand</code> <code>path[0][0] = !obstacleGrid[0][0];</code> Also, i don\u2019t used <code>memset</code> to initialized <code>path = {0}</code> </p> </li> <li> <p><code>python): I just directly convert using</code>int(`` value <pre><code>class Solution:\ndef uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:\nm = len(obstacleGrid)\nn = len(obstacleGrid[0])\npath = [[0] * n for _ in range(m)]\npath[0][0] = int(obstacleGrid[0][0] == 0)\nfor i in range(m):\nfor j in range(n):\nif i == j == 0 or obstacleGrid[i][j] == 1:\ncontinue\nif i &gt; 0:\npath[i][j] += path[i-1][j]\nif j &gt; 0:\npath[i][j] += path[i][j-1]\nreturn path[m-1][n-1]\n</code></pre> <li> <p><code>rust): feel like java code, nothing fancy (while I do have to go back and remove some unused code in</code>java<code>solution to match</code>rust<code>version</code> <pre><code>impl Solution {\npub fn unique_paths_with_obstacles(obstacle_grid: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 {\nlet m = obstacle_grid.len();\nlet n = obstacle_grid[0].len();\nlet mut path = vec![vec![0; n]; m];\npath[0][0] = obstacle_grid[0][0] ^ 1;\nfor i in 0..m {\nfor j in 0..n {\nif obstacle_grid[i][j] == 1 {\ncontinue;\n}\nif i &gt; 0 {\npath[i][j] += path[i - 1][j];\n}\nif j &gt; 0 {\npath[i][j] += path[i][j - 1];\n}\n}\n}\npath[m - 1][n - 1]\n}\n}\n</code></pre></p> </li>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "c", "rust", "java", "array", "dynamic_programming"]}, {"location": "notes/Leetcode%2010-100/74.%20Search%20a%202D%20Matrix/", "title": "74. Search a 2D Matrix", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "heap_c_lang", "stack_c_lang", "runtime_memory_alocation", "binary_search", "array", "matrix"]}, {"location": "notes/Leetcode%2010-100/74.%20Search%20a%202D%20Matrix/#problem", "title": "Problem", "text": "<p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p> <ul> <li>Each row is sorted in non-decreasing order.</li> <li>The first integer of each row is greater than the last integer of the previous row.</li> </ul> <p>Given an integer <code>target</code>, return <code>true</code> if <code>target</code> is in <code>matrix</code> or <code>false</code> otherwise.</p> <p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p> <p>Example 1: <pre><code>**Input:** matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60|1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n**Output:** true\n</code></pre> Example 2: <pre><code>**Input:** matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60|1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\n**Output:** false\n</code></pre></p> <p>Constraints:</p> <ul> <li><code>m == matrix.length</code></li> <li><code>n == matrix[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 100</code></li> <li><code>-10**4 &lt;= matrix[i][j], target &lt;= 10**4</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "heap_c_lang", "stack_c_lang", "runtime_memory_alocation", "binary_search", "array", "matrix"]}, {"location": "notes/Leetcode%2010-100/74.%20Search%20a%202D%20Matrix/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "heap_c_lang", "stack_c_lang", "runtime_memory_alocation", "binary_search", "array", "matrix"]}, {"location": "notes/Leetcode%2010-100/74.%20Search%20a%202D%20Matrix/#binary-searching", "title": "Binary searching", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "heap_c_lang", "stack_c_lang", "runtime_memory_alocation", "binary_search", "array", "matrix"]}, {"location": "notes/Leetcode%2010-100/74.%20Search%20a%202D%20Matrix/#takeaway", "title": "Takeaway", "text": "<p>Just take the two dimension array as one dimension (Which c naively support with its <code>stack</code> base memory allocate). </p> <ul> <li>Allocating <code>matrix[m][n]</code> is equally allocating <code>matrix[m*n]</code></li> <li>Which: <code>matrix[x][y] = (int) *(matrix + x) +y) = (int) matrix[x*n+y]</code> </li> <li>Still, the implementation in Leetcode using heap allocation </li> </ul> <pre><code>bool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\nint m = matrixSize;\nint n = *matrixColSize;\nfor (int i = 0; i &lt; n * m; i++){\nint* ptr = *(matrix + i/n) + i%n;\nif (i&gt;0 &amp;&amp; i%n==0) printf(\"\\n\");\nprintf(\"%p \", ptr);\n}\nreturn false;\n}\n</code></pre> <p>By checking with this code <code>stdout</code> give me this <code>[input]</code> <pre><code>[[1,3,5,7],[10,11,16,20],[23,30,34,60|1,3,5,7],[10,11,16,20],[23,30,34,60]]  \n3\n</code></pre></p> <p><code>[stdout]</code> <pre><code>0x602000000030 0x602000000034 0x602000000038 0x60200000003c  \n0x602000000050 0x602000000054 0x602000000058 0x60200000005c  \n0x602000000070 0x602000000074 0x602000000078 0x60200000007c\n</code></pre></p> <p>Which mean, it not possible using the array directly by pointer or <code>(int) *(matrix + x) +y) != (int) *matrix + x*n +y</code></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "heap_c_lang", "stack_c_lang", "runtime_memory_alocation", "binary_search", "array", "matrix"]}, {"location": "notes/Leetcode%2010-100/74.%20Search%20a%202D%20Matrix/#actual-implementation", "title": "Actual implementation", "text": "<p>I like to use binary search that the start of <code>left</code>, <code>right</code> is not in the array, example:</p> <ul> <li>An array <code>matrix</code> that span over <code>[0..=n]</code> range (inclusive), <code>left, right = -1, n+1</code></li> <li>So when calculating <code>mid=(left+right)//2</code>, we can landing <code>mid</code> in any number in <code>[-1..=n+1]</code> range. Giving me a easier way  to controlling where <code>left</code> and <code>right</code> end up.</li> <li>The search function always end with <code>left == mid == right -1</code>.</li> </ul> <p>While this isn\u2019t necessary in this exact problem, but here I trying land <code>matrix[left] &lt;= target &lt; matrix[right]</code> (and by the break stop definition, we also have <code>left = right -1 = mid = (left + right) // 2</code>). So:</p> <ul> <li>If <code>matrix[left] != matrix[target]</code>, there isn\u2019t any thing in the <code>matrix</code> equal to <code>target</code> (as there isn\u2019t any element between <code>maxtrix[left..right]</code> ), return <code>False</code></li> <li>If <code>matrix[left] == matrix[target]</code>, we found <code>target</code>, return <code>True</code> <pre><code>class Solution:\ndef searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\nm = len(matrix)\nn = len(matrix[0])\nl = -1\nr = m*n\nfor _ in range(trunc(log(n*m, 2)) +1):\nmid = (l + r) // 2\nif mid == l:\nbreak\nif matrix[mid//n][mid%n] &lt;= target:\nl = mid\nelse:\nr = mid\nif matrix[l//n][l%n] == target:\nreturn True\nreturn False\n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "heap_c_lang", "stack_c_lang", "runtime_memory_alocation", "binary_search", "array", "matrix"]}, {"location": "notes/Leetcode%2010-100/77.%20Combinations/", "title": "77. Combinations", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "recusion"]}, {"location": "notes/Leetcode%2010-100/77.%20Combinations/#problem", "title": "Problem", "text": "<p>Given two integers <code>n</code> and <code>k</code>, return all possible combinations of <code>k</code> numbers chosen from the range <code>[1, n]</code>.</p> <p>You may return the answer in any order.</p> <p>Example 1:</p> <p>Input: <code>n = 4, k = 2</code> Output: <code>[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4|1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</code> Explanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., <code>[1,2]</code> and <code>[2,1]</code> are considered to be the same combination.</p> <p>Example 2:</p> <p>Input: <code>n = 1, k = 1</code> Output: <code>[[1|1]]</code> Explanation: There is 1 choose 1 = 1 total combination.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 20</code></li> <li><code>1 &lt;= k &lt;= n</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "recusion"]}, {"location": "notes/Leetcode%2010-100/77.%20Combinations/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "recusion"]}, {"location": "notes/Leetcode%2010-100/77.%20Combinations/#recursion", "title": "Recursion", "text": "<p>Solve any combine <code>(n,k)</code> using the \u201cbefore\u201d combine <code>(n-1,k-1)</code></p> <ul> <li>Introducing <code>words</code> array to keep the available words list we can use to create our combination</li> <li>If any <code>k == 1</code>, we can safely return all member of remaining words lists</li> <li><code>n</code> should always large than  <pre><code>class Solution:\ndef combine(self, n: int, k: int, words = None) -&gt; List[List[int]]:\nif words is None:\nwords = [i for i in range(1,n+1)]\nif n &lt; k:\nreturn [[|]]\nif n &gt;= 1 and k == 1:\nreturn [[i] for i in words]\nresult = []\nfor i in range(len(words)):\nif n-1 &gt;= len(words[i+1:]):\nc = self.combine(n-1, k-1, words[i+1:])\nfor l in c:\nresult.append([words[i]]+l)\nreturn result\n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "recusion"]}, {"location": "notes/Leetcode%2010-100/77.%20Combinations/#optimized", "title": "Optimized", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "recusion"]}, {"location": "notes/Leetcode%2010-100/77.%20Combinations/#reuse-path-and-use-number-representation", "title": "Reuse path and Use number representation", "text": "<pre><code>class Solution:\ndef combine(self, n: int, k: int) -&gt; List[List[int]]:\nwords = n+1\ndef helper(n, k, pos = 1, path = []):\nif n &lt; k:\nreturn [[|]]\nif n &gt;= 1 and k == 1:\nreturn [path + [i] for i in range(pos, words)]\nresult = []\nfor i in range(pos, words):\nif n &gt;= words - i:\nresult += helper(n-1, k-1, i+1, path + [i])\nelse:\nbreak\nreturn result\nreturn helper(n,k)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "recusion"]}, {"location": "notes/Leetcode%2010-100/77.%20Combinations/#global-path", "title": "Global path", "text": "<pre><code>class Solution:\ndef combine(self, n: int, k: int) -&gt; List[List[int]]:\nwords = n+1\npath = []\ndef helper(level, pos = 1):\nif level == 1:\nreturn [path + [i] for i in range(pos, words)]\nresult = []\nfor i in range(pos, words-level+1):\npath.append(i)\nresult += helper(level-1, i+1)\npath.pop()\nreturn result\nreturn helper(k)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "python", "recusion"]}, {"location": "notes/Leetcode%2010-100/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II/", "title": "80. Remove Duplicates from Sorted Array II", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "java", "array"]}, {"location": "notes/Leetcode%2010-100/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II/#problem", "title": "Problem", "text": "<p>Given an integer array <code>nums</code> sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.</p> <p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p> <p>Return <code>k</code> after placing the final result in the first <code>k</code> slots of <code>nums</code>.</p> <p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.</p> <p>Custom Judge:</p> <p>The judge will test your solution with the following code: <pre><code>int[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\nassert nums[i] == expectedNums[i];\n}\n</code></pre> If all assertions pass, then your solution will be accepted.</p> <p>Example 1:</p> <p>Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).</p> <p>Example 2:</p> <p>Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,,] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores).</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 3 * 10**4</code></li> <li><code>-10**4 &lt;= nums[i] &lt;= 10**4</code></li> <li><code>nums</code> is sorted in non-decreasing order.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "java", "array"]}, {"location": "notes/Leetcode%2010-100/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II/#solve", "title": "Solve", "text": "<pre><code>from collections import defaultdict\nclass Solution:\ndef removeDuplicates(self, nums: List[int]) -&gt; int:\n# return self.counting(nums)\nreturn self.sliding(nums)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "java", "array"]}, {"location": "notes/Leetcode%2010-100/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II/#counting", "title": "Counting", "text": "<p>A normal loop through all available number in <code>nums</code> array, I keep a cache that store total appearance on all of the number.</p> <p>With that, I then adding the number in to <code>nums</code> array base on how many times they appear</p> <pre><code>    def counting(self, nums):\ncount = defaultdict(int)\nfor n in nums:\ncount[n] += 1\na = list(count.keys())\na.sort()\nindex = 0\nfor k in a:\nif count[k] &gt;= 2:\nnums[index] = nums[index+1] = k\nindex += 2\nelif count[k] == 1:\nnums[index] = k\nindex += 1\nfor i in range(index, len(nums)):\nnums.pop()\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "java", "array"]}, {"location": "notes/Leetcode%2010-100/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II/#sliding-pointer", "title": "Sliding pointer", "text": "<p>Using the above counting method, we isn\u2019t consider the array is  sorted in non-decreasing order: Equal number is right next each other. So, we only need to check the next following number on every number <code>value</code> change to count total appearance of <code>value</code>. </p> <p>Which mean, we can effectively update the <code>nums</code> array by using two <code>index</code>, <code>faster</code> pointer, follow 3 rules:</p> <ul> <li>A base <code>index</code> pointer, which point to the need to be update <code>nums</code></li> <li><code>index</code> pointer only change to next one, unless it\u2019s correspond <code>nums</code> array value is update to the correct value.</li> <li>A <code>faster</code> pointer, which is the current <code>nums</code> we process.</li> </ul> <p>Because <code>index</code> increase slower than <code>faster</code> pointer, we can store directly into <code>nums</code> array without losing any unprocessed data </p> <pre><code>    def sliding(self, nums):\nindex, faster = 0, 0\ncount = 0\nvalue = None\nfor i, n in enumerate(nums):\nif i == 0:\nindex, faster = 0, 0\nvalue = n\ncount = 1\ncontinue\nif n == value:\ncount += 1\nelse:\nvalue = n\ncount = 1\nif count &lt;= 2:\nindex += 1\nfaster += 1\nnums[index] = nums[faster]\nfor i in range(index+1, len(nums)):\nnums.pop()\n</code></pre> <p>By keeping track of total appearance of current number (<code>value</code>) using <code>count</code>. We make sure update the <code>nums</code> less than or equal 2 times each number  </p> <p>I also convert it to <code>c</code> code and <code>java</code> code:</p> <ul> <li>In <code>c</code> code, i try using a <code>boolean</code> instead of <code>int</code>, as count only in the value of <code>1</code> or <code>2</code> in the first implementation</li> <li> <p>I also using initiation directly to process the first index of number, skip it on the next for loop  <pre><code>int removeDuplicates(int* nums, int numsSize){\nint index = 0;\nbool count = false;\nint value = nums[0];\nfor (int i = 1; i &lt; numsSize; i++){\nif (nums[i] == value){\nif (!count) index ++;\ncount = true;\n} else {\nvalue = nums[i];\nindex ++;\ncount = false;\n}\nnums[index] = nums[i];\n}\nreturn index+1;\n}\n</code></pre></p> </li> <li> <p>But in <code>java</code>, i can\u2019t seep to find way to slice the array, so I just leave it like this instead <pre><code>class Solution {\npublic int removeDuplicates(int[] nums) {\nint index = -1;\nboolean count = false;\nint value = nums[0];\nfor (int n : nums) {\nif (index == -1) {\nindex += 1;\ncontinue;\n}\nif (n == value){\nif (!count) index += 1;\ncount = true;\n} else {\nvalue = n;\nindex += 1;\ncount = false;\n}\nnums[index] = n;\n}\nreturn index+1;\n}\n}\n</code></pre></p> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "c", "python", "java", "array"]}, {"location": "notes/Leetcode%2010-100/81.%20Search%20in%20Rotated%20Sorted%20Array%20II/", "title": "81. Search in Rotated Sorted Array II", "text": "", "tags": ["leetcode", "computer_sience", "python", "c", "coding_chalenge", "binary_search"]}, {"location": "notes/Leetcode%2010-100/81.%20Search%20in%20Rotated%20Sorted%20Array%20II/#problem", "title": "Problem", "text": "<p>There is an integer array <code>nums</code> sorted in non-decreasing order (not necessarily with distinct values).</p> <p>Before being passed to your function, <code>nums</code> is rotated at an unknown pivot index <code>k</code> (<code>0 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (0-indexed). For example, <code>[0,1,2,4,4,4,5,6,6,7]</code> might be rotated at pivot index <code>5</code> and become <code>[4,5,6,6,7,0,1,2,4,4]</code>.</p> <p>Given the array <code>nums</code> after the rotation and an integer <code>target</code>, return <code>true</code> if <code>target</code> is in <code>nums</code>, or <code>false</code> if it is not in <code>nums</code>.</p> <p>You must decrease the overall operation steps as much as possible.</p> <p>Example 1:</p> <p>Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true</p> <p>Example 2:</p> <p>Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 5000</code></li> <li><code>-104 &lt;= nums[i] &lt;= 104</code></li> <li><code>nums</code> is guaranteed to be rotated at some pivot.</li> <li><code>-104 &lt;= target &lt;= 104</code></li> </ul> <p>Follow up: This problem is similar to 33. Search in Rotated Sorted Array, but <code>nums</code> may contain duplicates. Would this affect the runtime complexity? How and why?</p>", "tags": ["leetcode", "computer_sience", "python", "c", "coding_chalenge", "binary_search"]}, {"location": "notes/Leetcode%2010-100/81.%20Search%20in%20Rotated%20Sorted%20Array%20II/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "python", "c", "coding_chalenge", "binary_search"]}, {"location": "notes/Leetcode%2010-100/81.%20Search%20in%20Rotated%20Sorted%20Array%20II/#remove-duplicate-find-shift-point-binary-search", "title": "Remove Duplicate + Find shift point + Binary search", "text": "", "tags": ["leetcode", "computer_sience", "python", "c", "coding_chalenge", "binary_search"]}, {"location": "notes/Leetcode%2010-100/81.%20Search%20in%20Rotated%20Sorted%20Array%20II/#some-conclusion", "title": "Some conclusion", "text": "<p>While there is a lot of similarity from 33. Search in Rotated Sorted Array . The main breaking point is that we can\u2019t effectively find the shift point as if <code>nums[mid] == nums[0]</code>, it could either be left, or right because of duplication. Both example could be: <pre><code>-  L     M     R\n- [2, 0, 2, 2, 2]\n- [2, 2, 2, 0, 2]\n</code></pre></p> <p>So to preventing this, we should at least remove duplication on either end, here is a snippet code that I try to clear the duplicate on <code>nums</code> array left side: <pre><code>        for i in range(n-1,-1,-1):\nif nums[i] == nums[0]:\ncontinue\nself.nums = nums[:i+1]\nn = len(self.nums)\nbreak\nif n == 0:\nreturn False\n</code></pre></p> <p>Final code should be the same as 33. Search in Rotated Sorted Array <pre><code>class Solution:\ndef findShiftPoint(self):\nshiftPoint = -1\nisFound = False\npointerLeftIndex = 0\npointerRightIndex = len(self.nums)\nwhile True:\nmidIndex = (pointerLeftIndex + pointerRightIndex) // 2\nif pointerLeftIndex == midIndex:\nbreak\nif self.nums[midIndex] &gt;= self.nums[0]:\npointerLeftIndex = midIndex\nelse:\npointerRightIndex = midIndex\nif pointerLeftIndex+1 == pointerRightIndex:\nshiftPoint = len(self.nums)-1 - pointerLeftIndex\nisFound = True\nreturn (shiftPoint, isFound)\ndef binarySearch(self, startIndex,endIndex, target):\ntargetIndex, isFound = -1, False\nleft = startIndex-1\nright = endIndex +1\nwhile True:\nmidIndex = (left + right) // 2\nif left == midIndex:\nbreak \nif self.nums[midIndex] &lt;= target:\nleft = midIndex\nelse:\nright = midIndex\nif left+1 == right:\ntargetIndex = left\nif startIndex &lt;= targetIndex &lt;= endIndex:\nisFound = self.nums[targetIndex] == target\nreturn (targetIndex, isFound)\ndef search(self, nums: List[int], target: int) -&gt; int:\nself.nums = nums\nn = len(nums)\nself.target = target\nfor i in range(n-1,-1,-1):\nif nums[i] == nums[0]:\ncontinue\nself.nums = nums[:i+1]\nn = len(self.nums)\nbreak\nif n == 0:\nreturn False\nresult = -1\nshiftPoint, isFound = self.findShiftPoint()\ntargetIndex, isFound = self.binarySearch(0, n- shiftPoint -1, target)\nif isFound:\nreturn True\ntargetIndex, isFound = self.binarySearch(n- shiftPoint,n-1, target)\nif isFound:\nreturn True\nreturn False\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "python", "c", "coding_chalenge", "binary_search"]}, {"location": "notes/Leetcode%2010-100/84.%20Largest%20Rectangle%20in%20Histogram/", "title": "84. Largest Rectangle in Histogram", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "cache", "binary_search", "array", "python"]}, {"location": "notes/Leetcode%2010-100/84.%20Largest%20Rectangle%20in%20Histogram/#problem", "title": "Problem", "text": "<p>Given an array of integers <code>heights</code> representing the histogram\u2019s bar height where the width of each bar is <code>1</code>, return the area of the largest rectangle in the histogram.</p> <p>Example 1:</p> <p></p> <p>Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= heights.length &lt;= 10**5</code></li> <li><code>0 &lt;= heights[i] &lt;= 10**4</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "cache", "binary_search", "array", "python"]}, {"location": "notes/Leetcode%2010-100/84.%20Largest%20Rectangle%20in%20Histogram/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "cache", "binary_search", "array", "python"]}, {"location": "notes/Leetcode%2010-100/84.%20Largest%20Rectangle%20in%20Histogram/#cache-it-all", "title": "Cache it all", "text": "<p>We need what information, we cache it:</p> <ul> <li>Loop through the provided <code>height</code> array from left to right (<code>[0..n]</code>)</li> <li>Using a dictionary hash map <code>cache</code> to store all the rectangle we can create up until now</li> <li>Calculate the next one using: <code>cache[(i,p)] = cache[(i-1,p)] + p</code> which mean:<ul> <li>With current bar with a height of <code>p</code> ;</li> <li>we can append it and form a rectangle to the last know <code>i-1</code> index <code>p</code> height rectangle.</li> </ul> </li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\ndef largestRectangleArea(self, heights: List[int]) -&gt; int:\ncache = defaultdict(int)\nlargest = 0 \nfor i, h in enumerate(heights):\nfor p in range(1, h+1):\ncache[(i,p)] = cache[(i-1,p)] + p\nif largest &lt; cache[(i,p)]:\nlargest = cache[(i,p)]\nreturn largest\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "cache", "binary_search", "array", "python"]}, {"location": "notes/Leetcode%2010-100/84.%20Largest%20Rectangle%20in%20Histogram/#optimize", "title": "Optimize", "text": "<ul> <li>Binary search: Using binary search instead of loop through all possible <code>p in [0..h]</code> with each bar; only calculating and caching p with a clear know of it</li> <li>Optimize memory: We only need index <code>(i-1)</code> information to process index <code>i</code>, so we don\u2019t need to cache/can free any thing before it.</li> <li>Optimize calculation: We only need to store the appearance of each height, check for largest rectangle only when it goes out of the scope or end of the loop.</li> </ul> <pre><code>class Solution:\ndef largestRectangleArea(self, heights: List[int]) -&gt; int:\ncache = [{}, {}]\nprev, curr = 0, 1\nlargest = 0 \nfor i, h in enumerate(heights):\nif i == 0:\nh = heights[0]\ncache[prev][h] = i\nlargest = h\nprev_keys = [h]\ncontinue\ninsert_pos = bisect_right(prev_keys, h)\ncurr_keys = prev_keys[:insert_pos].copy()\nfor key in prev_keys[:insert_pos]:\ncache[curr][key] = cache[prev][key]\nif h not in prev_keys:\ncache[curr][h] = i\nif insert_pos &lt; len(prev_keys):\ncache[curr][h] = cache[prev][prev_keys[insert_pos]]\ncurr_keys.append(h)\nfor key in prev_keys[insert_pos:]:\nif largest &lt; (i-cache[prev][key])*key:\nlargest = (i-cache[prev][key])*key\ncurr, prev = prev, curr\nprev_keys = curr_keys\n# print(cache[curr])\ncache[curr] = {}\nfor key in cache[prev]:\nif largest &lt; (len(heights)-cache[prev][key])*key:\nlargest = (len(heights)-cache[prev][key])*key\nreturn largest\n</code></pre> <ul> <li>Try to clear the dictionary and using copy for quickly create key array, I quite gave up at this point</li> </ul> <pre><code>class Solution:\ndef largestRectangleArea(self, heights: List[int]) -&gt; int:\ncache = [[], [|], []]\nprev, curr = 0, 1\nlargest = 0 \nprev_keys = []\nfor i, h in enumerate(heights):\nif i == 0:\nh = heights[0]\nlargest = h\ncache[prev].append(i)\nprev_keys = [h]\ncontinue\ninsert_pos = bisect_right(prev_keys, h)\ncurr_keys = prev_keys[:insert_pos].copy()\ncache[curr] = cache[prev][:insert_pos].copy()\nif h not in prev_keys:\ncurr_keys.append(h)\ncache[curr].append(i)\nif insert_pos &lt; len(prev_keys):\ncache[curr][-1] = cache[prev][insert_pos]\nfor k, start in enumerate(cache[prev][insert_pos:]):\nkey = insert_pos + k \nif largest &lt; (i-start)*prev_keys[key]:\nlargest = (i-start)*prev_keys[key]\ncurr, prev = prev, curr\nprev_keys = curr_keys\n# print(cache[curr])\nfor i, key in enumerate(cache[prev]):\nif largest &lt; (len(heights)-key)*prev_keys[i]:\nlargest = (len(heights)-key)*prev_keys[i]\nreturn largest\n</code></pre> <p>After understand the yanked code, I realize a lot more imprisonment window:</p> <ul> <li>We not need separated <code>prev</code> and <code>curr</code> cache. We can just reuse the <code>prev</code> one directly, pop out any unused <code>&lt;out of the scope&gt;</code> rectangle</li> <li>So I only use <code>cache</code> and <code>keys</code>, instead of having <code>curr_keys, prev_keys, curr, prev, cache[curr] = cache[prev]</code></li> <li>We used the previous <code>keys</code> array directly, so instead of use <code>bisect_right</code> to find the cut out, calculate the <code>&lt;out of the scope&gt;</code> rectangle first and update using a while loop <code>pop()</code> them out until the height of the last one in <code>keys</code> array is lower than current processed height <code>h</code>.<ul> <li>This also mean we have to find another way to get the <code>cache[prev][insert_pos]</code>, which is a product of <code>bisect_right</code> and already be free from memory by <code>keys.pop()</code>. so I set a term <code>w</code> and update it every time using <code>keys.pop()</code></li> </ul> </li> <li>We also can append a <code>[0]</code> at the end so we can reused the logic inside the loop to find largest rectangle, instead of using separated loop at the end.</li> </ul> <pre><code>class Solution:\ndef largestRectangleArea(self, heights: List[int]) -&gt; int:\ncache = []\nkeys = []\nlargest = 0\nfor i, h in enumerate(heights + [0]):\nif i == 0:\nh = heights[0]\nlargest = h\ncache.append(i)\nkeys.append(h)\ncontinue\nw = i\nwhile len(keys) &gt; 0 and keys[-1] &gt; h:\nk = keys.pop()\nstart = cache.pop()\nif largest &lt; (i-start)*k:\nlargest = (i-start)*k\nw = start\nif len(keys) == 0 or keys[-1] != h:\nkeys.append(h)\ncache.append(w)\nreturn largest\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "cache", "binary_search", "array", "python"]}, {"location": "notes/Leetcode%2010-100/84.%20Largest%20Rectangle%20in%20Histogram/#gave-up-yank-some-code", "title": "Gave up: Yank some code", "text": "<p>This is quite close to final version of mine some how <pre><code>class Solution:\ndef largestRectangleArea(self, heights: List[int]) -&gt; int:\nif len(heights) == 1:\nreturn heights[0]\n# stack = [&lt;remember_height&gt;, &lt;window_length&gt;]]\nstack = [[heights[0], 1|heights[0], 1]]\ntopHeight, topWidth = stack[-1]\nlargest = heights[0]\nfor h in heights[1:] + [0]:\nw = 1\nif stack and h &lt;= topHeight:\nwhile stack and h &lt; topHeight:\ncurrH, currW = stack.pop()\ntopHeight, topWidth = stack[-1] if stack else (None, None)\nw += currW\narea = (w - 1) * currH\nif area &gt; largest:\nlargest = area\nif stack and h == topHeight:\ntopWidth += w\nstack[-1] = (h, topWidth)\ncontinue\ntopHeight, topWidth = h, w\nstack.append((topHeight, topWidth))\nreturn largest\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "cache", "binary_search", "array", "python"]}, {"location": "notes/Leetcode%2010-100/86.%20Partition%20List/", "title": "86. Partition List", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/86.%20Partition%20List/#problem", "title": "Problem", "text": "<p>Given the <code>head</code> of a linked list and a value <code>x</code>, partition it such that all nodes less than <code>x</code> come before nodes greater than or equal to <code>x</code>.</p> <p>You should preserve the original relative order of the nodes in each of the two partitions.</p> <p>Example 1:</p> <p></p> <p>Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5]</p> <p>Example 2:</p> <p>Input: head = [2,1], x = 2 Output: [1,2]</p> <p>Constraints:</p> <ul> <li>The number of nodes in the list is in the range <code>[0, 200]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> <li><code>-200 &lt;= x &lt;= 200</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/86.%20Partition%20List/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/86.%20Partition%20List/#de-linked-list-and-make-new-one", "title": "De-linked list and make new one", "text": "<p><code>python</code></p> <p>Just throw away the linked list, I storing all data in a array and rebuild new one.</p> <ul> <li>Loop through <code>head</code> to construct <code>delink</code> array that have all <code>value</code> at the same position of <code>head</code> list</li> <li>Loop through the <code>delink</code> array twice to construct the result link list </li> </ul> <pre><code>class Solution:\ndef partition(self, head: Optional[ListNode], x: int) -&gt; Optional[ListNode]:\np = head\ndelink = []\nwhile p:\ndelink.append(p.val) \np = p.next\nnewHead = None\np = None\nfor i in delink:\nif i &gt;= x:\ncontinue\nif newHead is None:\nnewHead = ListNode(i)\np = newHead\ncontinue\np.next = ListNode(i)\np = p.next\nfor i in delink:\nif i &lt; x:\ncontinue\nif newHead is None:\nnewHead = ListNode(i)\np = newHead\ncontinue\np.next = ListNode(i)\np = p.next\nreturn newHead\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/86.%20Partition%20List/#loop-on-linked-list-but-still-make-new-one", "title": "Loop on linked list but still make new one", "text": "<p><code>python</code></p> <p>The previous approach only loop through the list once, not randomly accessing it, so we can just use normal loop through provided <code>head</code> linked list using a pointer <code>p</code> variable.</p> <p>To make it better, I using two temp Linked list to construct the result Linked list, so that I only need to loop through <code>head</code> once:</p> <ul> <li><code>smaller</code>: Contain all smaller node</li> <li><code>equalOrBigger</code>: Contain all the other node</li> </ul> <pre><code>class Solution:\ndef partition(self, head: Optional[ListNode], x: int) -&gt; Optional[ListNode]:\np = head\nsmaller = None\nequalOrBigger = None\neSmall = None\neBig = None\nwhile p:\nif p.val &gt;= x:\nif equalOrBigger is None:\nequalOrBigger = ListNode(p.val)\neBig = equalOrBigger\nelse:\neBig.next = ListNode(p.val)\neBig = eBig.next\nelse:\nif smaller is None:\nsmaller = ListNode(p.val)\neSmall = smaller\nelse:\neSmall.next = ListNode(p.val)\neSmall = eSmall.next\np = p.next\nif smaller is None:\nsmaller = equalOrBigger\nelse:\neSmall.next = equalOrBigger\nreturn smaller\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/86.%20Partition%20List/#loop-on-linked-list-and-reused-all-the-old-provided-listnode", "title": "Loop on linked list and reused all the old provided <code>ListNode</code>", "text": "<p><code>python</code></p> <p>Instead of create new <code>ListNode</code>, we can directly using <code>p</code> as our node Still, we need to store <code>p</code> by <code>temp</code> so that our change doesn\u2019t affect the loop code <pre><code>        while p:\ntemp = p\np = p.next\n# &lt;reuse logic on temp&gt;\n</code></pre></p> <p>Final implementation <pre><code>class Solution:\ndef partition(self, head: Optional[ListNode], x: int) -&gt; Optional[ListNode]:\np = head\nsmaller = None\nequalOrBigger = None\neSmall = None\neBig = None\nwhile p:\ntemp = p\np = p.next\nif temp.val &gt;= x:\nif equalOrBigger is None:\nequalOrBigger = temp\neBig = equalOrBigger\nelse:\neBig.next = temp\neBig = eBig.next\nelse:\nif smaller is None:\nsmaller = temp\neSmall = smaller\nelse:\neSmall.next = temp\neSmall = eSmall.next\nif equalOrBigger is not None:\neBig.next = None\nif smaller is None:\nsmaller = equalOrBigger\nelse:\neSmall.next = equalOrBigger\nreturn smaller\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/88.%20Merge%20Sorted%20Array/", "title": "88. Merge Sorted Array", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/88.%20Merge%20Sorted%20Array/#problem", "title": "Problem", "text": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in non-decreasing order, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p> <p>Merge <code>nums1</code> and <code>nums2</code> into a single array sorted in non-decreasing order.</p> <p>The final sorted array should not be returned by the function, but instead be stored inside the array <code>nums1</code>. To accommodate this, <code>nums1</code> has a length of <code>m + n</code>, where the first <code>m</code> elements denote the elements that should be merged, and the last <code>n</code> elements are set to <code>0</code> and should be ignored. <code>nums2</code> has a length of <code>n</code>.</p> <p>Example 1: <pre><code>**Input:** nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n**Output:** [1,2,2,3,5,6]\n**Explanation:** The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/88.%20Merge%20Sorted%20Array/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/88.%20Merge%20Sorted%20Array/#allocating-new-memory", "title": "Allocating new memory", "text": "<p><code>python</code></p> <p>This is the foundation of merge sort </p> <pre><code>class Solution:\ndef merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:\n\"\"\"\n        Do not return anything, modify nums1 in-place instead.\n        \"\"\"\nresult = nums1\nnums1 = nums1[:m].copy()\np1 = 0\np2 = 0\nfor i in range(m+n):\nif p1 &gt;= len(nums1):\nresult[i] = nums2[p2]\np2 += 1\nelif p2 &gt;= len(nums2):\nresult[i] = nums1[p1]\np1 += 1\nelif nums1[p1] &lt; nums2[p2]:\nresult[i] = nums1[p1]\np1 += 1\nelse:\nresult[i] = nums2[p2]\np2 += 1\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/91.%20Decode%20Ways/", "title": "91. Decode Ways", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/91.%20Decode%20Ways/#problem", "title": "Problem", "text": "<p>A message containing letters from <code>A-Z</code> can be encoded into numbers using the following mapping:</p> <p>\u2018A\u2019 -&gt; \u201c1\u201d \u2018B\u2019 -&gt; \u201c2\u201d \u2026 \u2018Z\u2019 -&gt; \u201c26\u201d</p> <p>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>\"11106\"</code> can be mapped into:</p> <ul> <li><code>\"AAJF\"</code> with the grouping <code>(1 1 10 6)</code></li> <li><code>\"KJF\"</code> with the grouping <code>(11 10 6)</code></li> </ul> <p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>\"06\"</code> cannot be mapped into <code>'F'</code> since <code>\"6\"</code> is different from <code>\"06\"</code>.</p> <p>Given a string <code>s</code> containing only digits, return the number of ways to decode it.</p> <p>The test cases are generated so that the answer fits in a 32-bit integer.</p> <p>Example 1: <pre><code>**Input:** s = \"12\"\n**Output:** 2\n**Explanation:** \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n</code></pre></p> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 100</code></li> <li><code>s</code> contains only digits and may contain leading zero(s).</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/91.%20Decode%20Ways/#solve", "title": "Solve", "text": "<p>Dynamic programming:</p> <ul> <li>We could use fixed size <code>cache[3]</code> rotation array instead</li> </ul> <pre><code>class Solution:\ndef numDecodings(self, s: str) -&gt; int:\nif s[0] == '0':\nreturn 0\ncache = {}\ncache[-1] = 1\ncache[-2] = 1\nfor i, c in enumerate(s):\nif i == 0:\ncache[i] = 1\ncontinue\ncache[i] = 0\nif c != '0':\ncache[i] = cache[i-1]\nif s[i-1] == '1' or (s[i-1] == '2' and ord(s[i]) &lt;= ord('6')):\ncache[i] += cache[i-2]\nreturn cache[len(s)-1]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/94.%20Binary%20Tree%20Inorder%20Traversal/", "title": "94. Binary Tree Inorder Traversal", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/94.%20Binary%20Tree%20Inorder%20Traversal/#problem", "title": "Problem", "text": "<p>Given the <code>root</code> of a binary tree, return the inorder traversal of its nodes\u2019 values.</p> <p>Example 1:</p> <p></p> <p>Input: root = [1,null,2,3] Output: [1,3,2]</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/94.%20Binary%20Tree%20Inorder%20Traversal/#solve", "title": "Solve", "text": "<p>You can return all the node value of a binary tree in many order: <code>bfs</code>, <code>dfs</code>, <code>lnr</code>, <code>rnl</code>, <code>lrn</code> .</p> <p>The problem specifically require Inorder traversal, which mean <code>left-node-right</code> order</p> <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:\nanwser = []\nif root is None:\nreturn anwser\nif root.left:\nanwser += self.inorderTraversal(root.left)\nanwser.append(root.val)\nif root.right:\nanwser += self.inorderTraversal(root.right)\nreturn anwser\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/98.%20Validate%20Binary%20Search%20Tree/", "title": "98. Validate Binary Search Tree", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/98.%20Validate%20Binary%20Search%20Tree/#problem", "title": "Problem", "text": "<p>Given the <code>root</code> of a binary tree, determine if it is a valid binary search tree (BST).</p> <p>A valid BST is defined as follows:</p> <ul> <li>The left subtree of a node contains only nodes with keys less than the node\u2019s key.</li> <li>The right subtree of a node contains only nodes with keys greater than the node\u2019s key.</li> <li>Both the left and right subtrees must also be binary search trees.</li> </ul> <p>Example 1:</p> <p></p> <p>Input: root = [2,1,3] Output: true</p> <p>Example 2:</p> <p></p> <p>Input: root = [5,1,4,null,null,3,6] Output: false Explanation: The root node\u2019s value is 5 but its right child\u2019s value is 4.</p> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[1, 104]</code>.</li> <li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/98.%20Validate%20Binary%20Search%20Tree/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/98.%20Validate%20Binary%20Search%20Tree/#recursion-bottom-up", "title": "Recursion - bottom up", "text": "<p>If we want a valid BST, then all tree node it self is a valid BST. With each tree node check, I try to remember:</p> <ul> <li>Is it a valid Tree</li> <li>What is it coverage range</li> </ul> <p>This then helping us when it come to their parent node, we:</p> <ul> <li>If its left, right node isn\u2019t a valid Tree, then the parent node isn\u2019t a valid Tree. Quickly return <code>False</code></li> <li>If the coverage range not match:   <code>[Left range] &lt; Parent.val &lt; [Right range]</code> then the Parent isn\u2019t a valid Tree. Quickly return <code>False</code></li> <li>If both above pass, we have a valid parent tree node. Return it coverage range <code>[l,r]</code> and its valid Tree stage <code>True</code></li> </ul> <pre><code>class Solution:\ndef isValidBST(self, root: Optional[TreeNode]) -&gt; bool:\ndef represent(root):\nl = root.val\nr = root.val\nif root.left:\nl_left, l_right, l_check = represent(root.left)\nif not l_check or root.val &lt;= l_right:\nreturn 0, 0, False\nl = l_left\nif root.right:\nr_left, r_right, r_check = represent(root.right)\nif not r_check or r_left &lt;= root.val:\nreturn 0, 0, False\nr = r_right\nreturn l, r, True\n_, _, result = represent(root)\nreturn result\n</code></pre> <p>While some how this return a accepted, this shouldn\u2019t work:</p> <ul> <li>The stack will be deallocated, all Rep object that we define will free the memory after return to the original parent function.</li> <li>So the return function which trying to return a pointer to Rep object, return to a free position in stack. Which then maybe be overridden, and make not so good behavior.  <pre><code>typedef struct {\nint l;\nint r;\nbool valid;\n} Rep;\nRep check(struct TreeNode* root){\nint l = root-&gt;val;\nint r = root-&gt;val;\nif (root-&gt;left != NULL) {\nRep left = check(root-&gt;left);\nif (!left.valid || l &lt;= left.r) {\nRep wrong = {0, 0, false};\nreturn wrong;\n}\nl = left.l;\n}\nif (root-&gt;right != NULL) {\nRep right = check(root-&gt;right);\nif (!right.valid || right.l &lt;= r) {\nRep wrong = {0, 0, false};\nreturn wrong;\n}\nr = right.r;\n}\nRep result = {l, r, true};\nreturn result;\n}\nbool isValidBST(struct TreeNode* root) {\nreturn check(root).valid;\n}\n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/98.%20Validate%20Binary%20Search%20Tree/#recursion-top-down", "title": "Recursion - top down", "text": "<p>If we want a valid BST, then all tree node it self is a valid BST. Start from the top <code>root</code> tree node, with a range of <code>[left, right] = [-MAX_INT, MAX_INT]</code>, to check our if <code>root</code> a valid BTS:</p> <ul> <li>All tree node in the Left should be covered by <code>[-MAX_INT, root.val -1]</code></li> <li>All tree node in the Right should be covered by <code>[root.val +1, MAX_INT]</code></li> </ul> <p>We push it down until checking all the node possible, any node that have value outside of it desirable range will return us with a <code>False</code> valid BTS <code>root</code></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/98.%20Validate%20Binary%20Search%20Tree/#memory-limit", "title": "Memory limit", "text": "<p>The MAX_INT should large than - <code>-2**31 &lt;= Node.val &lt;= 2**31 - 1</code>, which may require you to give a bigger memory</p> <p>While there is some (??) moments here.  Here is Leetcode C memory allocate: int = 4 bytes long = long long = 8 bytes</p> <p>My memory. Here is C memory allocate: int = 2 bytes long = 4 bytes long long = 8 bytes</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%2010-100/98.%20Validate%20Binary%20Search%20Tree/#implementation", "title": "Implementation", "text": "<p>By using long (8 bytes) integer:</p> <pre><code>bool check(struct TreeNode* root, long l, long r){\nif (root-&gt;left != NULL) {\nif (! check(root-&gt;left, l, root-&gt;val))\nreturn false;\n}\nif (root-&gt;right != NULL) {\nif (! check(root-&gt;right, root-&gt;val, r))\nreturn false;\n}\nreturn l &lt; root-&gt;val &amp;&amp; root-&gt;val &lt; r;\n}\nbool isValidBST(struct TreeNode* root) {\nreturn check(root, LLONG_MIN, LLONG_MAX);\n}\n</code></pre> <p>or by using a boolean as our representative to MAX_INT number, instead of real value:  <pre><code>bool check(struct TreeNode* root, int l, int r, bool haveL, bool haveR){\nif (root-&gt;left != NULL) {\nif (! check(root-&gt;left, l, root-&gt;val, haveL, true))\nreturn false;\n}\nif (root-&gt;right != NULL) {\nif (! check(root-&gt;right, root-&gt;val, r, true, haveR))\nreturn false;\n}\nif (haveL){\nif (! (l &lt; root-&gt;val))\nreturn false; }\nif (haveR){\nif (! (root-&gt;val &lt; r)) {\nreturn false;\n}\n}\nreturn true;\n}\nbool isValidBST(struct TreeNode* root) {\nreturn check(root, 0, 0, false, false);\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/101.%20Symmetric%20Tree/", "title": "101. Symmetric Tree", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/101.%20Symmetric%20Tree/#problem", "title": "Problem", "text": "<p>Given the <code>root</code> of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p> <p>Example 1:</p> <p></p> <p>Input: root = [1,2,2,3,4,4,3] Output: true</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/101.%20Symmetric%20Tree/#solve", "title": "Solve", "text": "<p>Quite tricky, the way is keeping track of all node to travel and their corresponded   </p> <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:\nqueue = [(root, root)]\nwhile len(queue) &gt; 0:\np, q = queue.pop(0)\nif p.val != q.val:\nreturn False\nif p.right and q.left:\nqueue.append((p.right, q.left))\nelif p.right or q.left:\nreturn False\nif p.left and q.right:\nqueue.append((p.left, q.right))\nelif p.left or q.right:\nreturn False\nreturn True\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/102.%20Binary%20Tree%20Level%20Order%20Traversal/", "title": "102. Binary Tree Level Order Traversal", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/102.%20Binary%20Tree%20Level%20Order%20Traversal/#problem", "title": "Problem", "text": "<p>Given the <code>root</code> of a binary tree, return the level order traversal of its nodes\u2019 values. (i.e., from left to right, level by level).</p> <p>Example 1:</p> <p></p> <p>Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7|3],[9,20],[15,7]]</p> <p>Example 2:</p> <p>Input: root = [1] Output: 1</p> <p>Example 3:</p> <p>Input: root = [] Output: []</p> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li> <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/102.%20Binary%20Tree%20Level%20Order%20Traversal/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/102.%20Binary%20Tree%20Level%20Order%20Traversal/#recursive", "title": "Recursive", "text": "<p>I do exactly what the problem said:</p> <ul> <li>Create a array <code>result</code></li> <li>Loop through all nodes in the <code>root</code> tree, while keeping its level using recursive</li> <li>Push them in to <code>result</code> as we go</li> </ul> <pre><code>class Solution:\ndef levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\nresult = []\ndef helper(root, level = None):\nif level is None:\nlevel = 0\nwhile len(result) - 1 &lt; level:\nresult.append([])\nresult[level].append(root.val)\nif root.left:\nhelper(root.left, level + 1)\nif root.right:\nhelper(root.right, level + 1)\nif root:\nhelper(root)\nreturn result\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/102.%20Binary%20Tree%20Level%20Order%20Traversal/#using-queue", "title": "Using queue", "text": "<p>Simple BFS implement with queue</p> <pre><code>class Solution:\ndef levelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\nresult = []\nq = []\nif root:\nq.append((root,0))\nwhile len(q) &gt; 0:\nr, level = q.pop(0)\nif len(result) - 1 &lt; level:\nresult.append([])\nresult[level].append(r.val)\nif r.left:\nq.append((r.left, level + 1))\nif r.right:\nq.append((r.right, level + 1))\nreturn result\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/", "title": "103. Binary Tree Zigzag Level Order Traversal", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/#problem", "title": "Problem", "text": "<p>Given the <code>root</code> of a binary tree, return the zigzag level order traversal of its nodes\u2019 values. (i.e., from left to right, then right to left for the next level and alternate between).</p> <p>Example 1:</p> <p></p> <p>Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7|3],[20,9],[15,7]]</p> <p>Example 2:</p> <p>Input: root = [1] Output: 1</p> <p>Example 3:</p> <p>Input: root = [] Output: []</p> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/#solve", "title": "Solve", "text": "<p>By reusing our 102. Binary Tree Level Order Traversal, we can just reverse the order of result array at every <code>odd</code> index.</p> <p>As the order of result is already left -&gt; right</p> <pre><code>class Solution:\ndef zigzagLevelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\nresult = []\nq = []\nif root:\nq.append((root,0))\nwhile len(q) &gt; 0:\nr, level = q.pop(0)\nif len(result) - 1 &lt; level:\nresult.append([])\nresult[level].append(r.val)\nif r.left:\nq.append((r.left, level + 1))\nif r.right:\nq.append((r.right, level + 1))\nfor i in range(1, len(result), 2):\nresult[i] = result[i][::-1]\nreturn result\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/104.%20Maximum%20Depth%20of%20Binary%20Tree/", "title": "104. Maximum Depth of Binary Tree", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/104.%20Maximum%20Depth%20of%20Binary%20Tree/#problem", "title": "Problem", "text": "<p>Given the <code>root</code> of a binary tree, return its maximum depth.</p> <p>A binary tree\u2019s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p> <p>Example 1:</p> <p></p> <p>Input: root = [3,9,20,null,null,15,7] Output: 3</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/104.%20Maximum%20Depth%20of%20Binary%20Tree/#solve", "title": "Solve", "text": "<ul> <li> <p>Go to each node and keep track their deep level <pre><code>#TODO\n</code></pre></p> </li> <li> <p>Or use simple recursion <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef maxDepth(self, root: Optional[TreeNode]) -&gt; int:\nif root is None:\nreturn 0\ndeep = 1\nif root.left:\nleft_deep = self.maxDepth(root.left)\nif deep &lt; left_deep + 1:\ndeep = left_deep + 1\nif root.right:\nright_deep = self.maxDepth(root.right)\nif deep &lt; right_deep + 1:\ndeep = right_deep + 1\nreturn deep\n</code></pre></p> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/", "title": "108. Convert Sorted Array to Binary Search Tree", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/#problem", "title": "Problem", "text": "<p>Given an integer array <code>nums</code> where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.</p> <p>Example 1:</p> <p></p> <p>Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted:</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/#solve", "title": "Solve", "text": "<p>A simple recursion, we reuse our own created function Recursion break case is when:</p> <ul> <li><code>len(nums) == 0</code> which we return <code>None</code> </li> <li><code>len(nums)== 1</code> which it is a leaf <code>TreeNode</code> with <code>leaf.left = leaf.right == None</code></li> </ul> <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef sortedArrayToBST(self, nums: List[int]) -&gt; Optional[TreeNode]:\nif len(nums) == 1:\nreturn TreeNode(nums[0])\nif len(nums) ==0:\nreturn None\nmid = len(nums)//2\nroot_value = nums[mid]\nleft = self.sortedArrayToBST(nums[:mid])\nright = self.sortedArrayToBST(nums[mid+1:])\nreturn TreeNode(root_value, left, right)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/116.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node/", "title": "116. Populating Next Right Pointers in Each Node", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/116.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node/#problem", "title": "Problem", "text": "<p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: <pre><code>struct Node {\nint val;\nNode *left;\nNode *right;\nNode *next;\n}\n</code></pre> Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p> <p>Initially, all next pointers are set to <code>NULL</code>.</p> <p>Example 1:</p> <p></p> <p>Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with \u2018#\u2019 signifying the end of each level.</p> <p>Example 2:</p> <p>Input: root = [] Output: []</p> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[0, 212 - 1]</code>.</li> <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul> <p>Follow-up:</p> <ul> <li>You may only use constant extra space.</li> <li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/116.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node/#solve", "title": "Solve", "text": "<p>By reusing our 102. Binary Tree Level Order Traversal, we can just using result to help us populate every node next.</p> <p>As the order of result is already left -&gt; right, we loop and set our <code>node[i].next = node[i+1]</code> with every <code>result[0..n]</code></p> <pre><code>class Solution:\ndef connect(self, root: 'Optional[Node]') -&gt; 'Optional[Node]':\nresult = []\nq = []\nif root:\nq.append((root,0))\nwhile len(q) &gt; 0:\nr, level = q.pop(0)\nif len(result) - 1 &lt; level:\nresult.append([])\nresult[level].append(r)\nif r.left:\nq.append((r.left, level + 1))\nif r.right:\nq.append((r.right, level + 1))\nfor nodes in result:\nfor i in range(len(nodes)-1):\nnodes[i].next = nodes[i+1]\nreturn root\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/118.%20Pascal%27s%20Triangle/", "title": "118. Pascal's Triangle", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/118.%20Pascal%27s%20Triangle/#problem", "title": "Problem", "text": "<p>Given an integer <code>numRows</code>, return the first numRows of Pascal\u2019s triangle.</p> <p>In Pascal\u2019s triangle, each number is the sum of the two numbers directly above it as shown:</p> <p></p> <p>Example 1: <pre><code>**Input:** numRows = 5\n**Output:** [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1|1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/118.%20Pascal%27s%20Triangle/#solve", "title": "Solve", "text": "<ul> <li>Simply simulating what the problem said, no optimizing anything </li> </ul> <pre><code>class Solution:\ndef generate(self, numRows: int) -&gt; List[List[int]]:\nanswer = [[1], [1,1], [1,2,1|1], [1,1], [1,2,1]]\nfor row in range(3,numRows):\nlast = answer[row-1]\ncurrent_row = [1]\nfor index in range(len(last)-1):\ncurrent_row.append(last[index] + last[index+1])\ncurrent_row.append(1)\nanswer.append(current_row)\nreturn answer[:numRows]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/", "title": "121. Best Time to Buy and Sell Stock", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#problem", "title": "Problem", "text": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p> <p>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p> <p>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return <code>0</code>.</p> <p>Example 1:</p> <p>Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/121.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/#solve", "title": "Solve", "text": "<ul> <li> <p>I already solve 714. Best Time to Buy and Sell Stock with Transaction Fee, still, it not quite the same.</p> </li> <li> <p>Here is quick <code>n**2</code> answer <pre><code>class Solution:\ndef maxProfit(self, prices: List[int]) -&gt; int:\nif len(prices) == 1:\nreturn 0\nmax_price = 0\nfor i in range(len(prices)):\nfor j in range(i+1, len(prices)):\nif max_price &gt;= prices[j] - prices[i]:\ncontinue\nmax_price = prices[j] - prices[i]\nreturn max_price\n</code></pre></p> </li> <li> <p>We can optimize this by try find the max price of  <code>prices[i+1: len(prices)]</code> immediately.  <pre><code># TODO\n</code></pre></p> </li> <li>Or reversing it to file min price or <code>prices[0: j]</code> instead. Here is using more clear name <pre><code>class Solution:\ndef maxProfit(self, prices: List[int]) -&gt; int:\nif len(prices) == 1:\nreturn 0\ncurr_min_price = prices[0] # keep track of the min of value price[0:index-1]\nmax_price = 0\nfor index, value in enumerate(prices):\nif index == 0:\ncontinue\nif max_price &lt; prices[index] - curr_min_price:\nmax_price = prices[index] - curr_min_price\nif curr_min_price &gt; prices[index]:\ncurr_min_price = prices[index]\nreturn max_price\n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/", "title": "122. Best Time to Buy and Sell Stock II", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/#problem", "title": "Problem", "text": "<p>You are given an integer array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day.</p> <p>On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.</p> <p>Find and return the maximum profit you can achieve.</p> <p>Example 1: <pre><code>**Input:** prices = [7,1,5,3,6,4]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/122.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/#dynamic-programing-python", "title": "Dynamic programing <code>python</code>", "text": "<ul> <li> <p>I already solve 714. Best Time to Buy and Sell Stock with Transaction Fee,  and it quite the same.</p> </li> <li> <p>Here is quick modified to get the right answer. Which just reduce the fee part <pre><code>class Solution:\ndef maxProfit(self, prices: List[int]) -&gt; int:\nbestProfit = [0, 0]\nfor step, price in enumerate(prices):\nif step == 0:\nbestProfit[1] = - price\ncontinue\ntmp = bestProfit[0]\nbestProfit[0] = max(bestProfit[0], bestProfit[1] + price)\nbestProfit[1] = max(bestProfit[1], tmp - price)\nreturn bestProfit[0]\n</code></pre></p> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/124.%20Binary%20Tree%20Maximum%20Path%20Sum/", "title": "124. Binary Tree Maximum Path Sum", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/124.%20Binary%20Tree%20Maximum%20Path%20Sum/#problem", "title": "Problem", "text": "<p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p> <p>The path sum of a path is the sum of the node\u2019s values in the path.</p> <p>Given the <code>root</code> of a binary tree, return the maximum path sum of any non-empty path.</p> <p>Example 1:</p> <p></p> <p>Input: root = [1,2,3] Output: 6 Explanation: The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.</p> <p>Example 2:</p> <p></p> <p>Input: root = [-10,9,20,null,null,15,7] Output: 42 Explanation: The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.</p> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[1, 3 * 104]</code>.</li> <li><code>-1000 &lt;= Node.val &lt;= 1000</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/124.%20Binary%20Tree%20Maximum%20Path%20Sum/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/124.%20Binary%20Tree%20Maximum%20Path%20Sum/#dynamic-programming-on-tree", "title": "Dynamic programming on Tree", "text": "<p>I hate it when I can\u2019t control how <code>TreeNode</code> work, my first approach to to populate all <code>TreeNode</code> with it <code>maxPath</code> (the max value of path that contain its self as the end node).</p> <p>We calculate base on this formula:</p> <ul> <li><code>maxPath(root) = Max(0, root.val) + max(maxPath(left), maxPath(right))</code></li> </ul> <p>After that, we try to find the Maximum Path Sum by checking all possible <code>TreeNode</code></p> <ul> <li><code>maxPathSum(root) = pathOnlyIn(Root) = max(pathOnlyIn(Left) , pathOnlyIn(Right) , pathGoTrough(Root))</code> </li> <li><code>pathGoTrough(Root) = maxPath(left) + maxPath(right) + root.val</code></li> <li><code>pathOnlyIn(None) = 0</code></li> <li><code>pathGoTrough(None) = Not define</code></li> </ul> <p>But, I can\u2019t just adding the <code>left.maxPath</code>, <code>right.maxPath</code>; so here is the code that combining both in one loop  <pre><code>class Solution:\ndef maxPathSum(self, root: Optional[TreeNode]) -&gt; int:\ndef helper(root):\nif root is None:\nreturn 0, -100000\nmaxLeftPath, onlyLeftMax = helper(root.left)\nmaxRightPath, onlyRightMax = helper(root.right)\nmaxRootPath = max(root.val, root.val + max(maxLeftPath, maxRightPath))\nonlyRootMax = root.val + max(0, maxLeftPath) + max(0, maxRightPath)\nmaxPathSum = max(onlyLeftMax, onlyRightMax, onlyRootMax)\nreturn maxRootPath, maxPathSum\n_, maxPathSum = helper(root) \nreturn maxPathSum\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/125.%20Valid%20Palindrome/", "title": "125. Valid Palindrome", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/125.%20Valid%20Palindrome/#problem", "title": "Problem", "text": "<p>A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p> <p>Given a string <code>s</code>, return <code>true</code> if it is a palindrome, or <code>false</code> otherwise.</p> <p>Example 1:</p> <pre><code>**Input:** s = \"A man, a plan, a canal: Panama\"\n**Output:** true\n**Explanation:** \"amanaplanacanalpanama\" is a palindrome.\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/125.%20Valid%20Palindrome/#solve", "title": "Solve", "text": "<p>Do as the problem ask, without any optimization:</p> <ol> <li>Lower key all character,</li> <li>Keep all alphabet and numbers character only, storing in a new variable call <code>alphabel_only</code></li> <li>Check if <code>alphabel_only</code> backward and forward is the same</li> </ol> <pre><code>class Solution:\ndef isPalindrome(self, s: str) -&gt; bool:\ns = s.lower()\nalphabel_only = \"\"\nfor c in s:\nif ord(\"a\") &lt;= ord(c) &lt;= ord(\"z\") or ord(\"0\") &lt;= ord(c) &lt;= ord(\"9\") :\nalphabel_only += c\nfor i, c in enumerate(alphabel_only):\nif alphabel_only[len(alphabel_only) - 1 - i] != c:\nreturn False\nreturn True\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/130.%20Surrounded%20Regions/", "title": "130. Surrounded Regions", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/130.%20Surrounded%20Regions/#problem", "title": "Problem", "text": "<p>Given an <code>m x n</code> matrix <code>board</code> containing <code>'X'</code> and <code>'O'</code>, capture all regions that are 4-directionally surrounded by <code>'X'</code>.</p> <p>A region is captured by flipping all <code>'O'</code>s into <code>'X'</code>s in that surrounded region.</p> <p>Example 1:</p> <p></p> <p>Input: board = [[\u201cX\u201d,\u201dX\u201d,\u201dX\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dO\u201d,\u201dO\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dX\u201d,\u201dO\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dO\u201d,\u201dX\u201d,\u201dX\u201d|\u201dX\u201d,\u201dX\u201d,\u201dX\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dO\u201d,\u201dO\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dX\u201d,\u201dO\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dO\u201d,\u201dX\u201d,\u201dX\u201d]] Output: [[\u201cX\u201d,\u201dX\u201d,\u201dX\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dX\u201d,\u201dX\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dX\u201d,\u201dX\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dO\u201d,\u201dX\u201d,\u201dX\u201d|\u201dX\u201d,\u201dX\u201d,\u201dX\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dX\u201d,\u201dX\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dX\u201d,\u201dX\u201d,\u201dX\u201d],[\u201cX\u201d,\u201dO\u201d,\u201dX\u201d,\u201dX\u201d]] Explanation: Notice that an \u2018O\u2019 should not be flipped if:</p> <ul> <li>It is on the border, or</li> <li>It is adjacent to an \u2018O\u2019 that should not be flipped. The bottom \u2018O\u2019 is on the border, so it is not flipped. The other three \u2018O\u2019 form a surrounded region, so they are flipped.</li> </ul> <p>Example 2:</p> <p>Input: board = \u201cX\u201d Output: \u201cX\u201d</p> <p>Constraints:</p> <ul> <li><code>m == board.length</code></li> <li><code>n == board[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 200</code></li> <li><code>board[i][j]</code> is <code>'X'</code> or <code>'O'</code>.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/130.%20Surrounded%20Regions/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/130.%20Surrounded%20Regions/#simulation-bfs", "title": "Simulation BFS", "text": "<p>Just focus on the rule in the example: </p> <p>an \u2018O\u2019 should not be flipped if:</p> <ul> <li>It is on the border, or</li> <li>It is adjacent to an \u2018O\u2019 that should not be flipped.</li> </ul> <p>So I check all the border for <code>'O'</code>. Adding them all to a queue, and start do a BFS on all of them to find if any Adj cell is also <code>'O'</code>.</p> <p>After visiting all <code>'O'</code> that we should not flip (Which being track with our visited array <code>v</code>), flipping all other remain one.</p> <pre><code>class Solution:\ndef solve(self, board: List[List[str]]) -&gt; None:\n\"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\nm = len(board)\nn = len(board[0])\nq = []\nv = set()\nfor i in range(n):\nif board[0][i] == 'O':\nq.append((0, i))\nv.add((0, i))\nif board[m - 1][i] == 'O':\nq.append((m - 1, i))\nv.add((m - 1, i))\nfor i in range(m):\nif (i,0) not in v:\nif board[i][0]  == 'O':\nq.append((i, 0))\nv.add((i, 0))\nif (i, n - 1) not in v:\nif board[i][n - 1]  == 'O':\nq.append((i, n- 1))\nv.add((i, n - 1))\nwhile len(q) &gt; 0:\nx, y = q.pop(0)\nfor nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]:\nif not (0 &lt;= nx &lt; m and 0 &lt;= ny &lt; n):\ncontinue\nif (nx,ny) in v:\ncontinue\nv.add((nx,ny))\nif board[nx][ny] == 'O':\nq.append((nx,ny))\nfor i in range(m):\nfor j in range(n):\nif (i, j) not in v:\nboard[i][j] = 'X'\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/", "title": "131. Palindrome Partitioning", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/#problem", "title": "Problem", "text": "<p>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of <code>s</code>.</p> <p>Example 1: <pre><code>**Input:** s = \"aab\"\n**Output:** [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"|\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</code></pre> Example 2: <pre><code>**Input:** s = \"a\"\n**Output:** [[\"a\"|\"a\"]]\n</code></pre> Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 16</code></li> <li><code>s</code> contains only lowercase English letters.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/#preprocess-data", "title": "Preprocess data", "text": "<p>The problem will be easier when we know all the palindrome substring of <code>s</code>. This is quite easy, we focusing this pattern of a palindrome string</p> <pre><code>palindrome_string = &lt; c &gt; + palindrome_substring + &lt; c &gt;\n</code></pre> <p>where <code>c</code> is repeating character.</p> <p>There is a lot of way to implement this function, the final result will be a <code>func(x,y)</code> that can quickly check substring <code>s[x:y]</code> is a palindrome or not in O(1) lookup time</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/#dynamic-programming", "title": "Dynamic programming", "text": "<pre><code>        palindrome_string = []\ndef isPalindrome(x, y):\nreturn palindrome_string[y - x][x]\n# Find all palindrome\nfor size in range(0, len(s)):\ncurr_palindrome_string = []\nfor i in range(0, len(s)-size):\nif size == 0:\ncurr_palindrome_string.append(True)\ncontinue\nif size == 1:\ncurr_palindrome_string.append(s[i] == s[i+size])\ncontinue\ncheck = s[i] == s[i+size]\ncheck &amp;= isPalindrome(i+1, i+size-1)\ncurr_palindrome_string.append(check)\npalindrome_string.append(curr_palindrome_string)\n</code></pre> <p>We have <code>isPalindrome</code> is the <code>func(x,y)</code></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/#recursion", "title": "Recursion", "text": "<pre><code>        cache2 = {}\ndef isPalindrome(x,y):\nif x &gt; y:\nreturn False\nif x == y:\nreturn True\nif (x,y) in cache2:\nreturn cache2[(x,y)]\nif s[x] != s[y]:\ncache2[(x, y)] = False\nreturn False\nif s[x+1:y] != \"\" and not isPalindrome(x+1,y-1):\ncache2[(x, y)] = False\nreturn False\ncache2[(x, y)] = True\nreturn True\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/#getting-all-the-palindrome-split", "title": "Getting all the palindrome split", "text": "<p>After preprocessing data, We can then try to split the string base on:</p> <ul> <li>If the substring is palindrome, then try split it, continue split the remaining substring.</li> <li>If the substring isn\u2019t palindrome, pass</li> </ul> <pre><code>class Solution:\ndef partition(self, s: str) -&gt; List[List[str]]:\ndef isPalindrome(x, y):\n# Last implementation\ncache = {}\ndef palindrome_split(x, y):\nif x &gt;= y:\nreturn [[|]]\nif x == y - 1:\nreturn [[s[x:y|s[x:y]]]\nif (x, y) in cache:\nreturn cache[(x,y)]\npossible = []\nfor end in range(x,y):\nstart = x\ncurr = s[start:end+1]\nres = []\nif isPalindrome(start, end):\nall_pali = palindrome_split(end+1, y)\nfor pali in all_pali:\nres.append([curr] + pali)\npossible += res\ncache[(x,y)] = possible\nreturn cache[(x,y)]\nreturn palindrome_split(0, len(s))\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/#java-implementation", "title": "Java implementation", "text": "<pre><code>class Solution {\nprivate int[][] cacheIsPalindrome;\nprivate int n;\nprivate List&lt;List&lt;String&gt;&gt;[][] cachePalindromeSplit;\nprivate String s;\nprivate boolean isPalindrome(int x, int y) {\nif (x &gt; y) return false;\nif (x == y) return true;\nif (cacheIsPalindrome[x][y] != 0) return cacheIsPalindrome[x][y] &gt; 0;\nif (s.charAt(x) != s.charAt(y)) {\ncacheIsPalindrome[x][y] = -1;\nreturn false;\n}\nif ((x + 1 &lt; y)   &amp;&amp; !isPalindrome(x + 1, y - 1)) {\ncacheIsPalindrome[x][y] = -1;\nreturn false;\n}\ncacheIsPalindrome[x][y] = 1;\nreturn true;\n}\nprivate List&lt;List&lt;String&gt;&gt; palindromeSplit(int x, int y) {\nif (x &gt;= y) {\nList&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();\nresult.add(new ArrayList&lt;&gt;());\nreturn result;\n}\nif (x == y - 1) {\nList&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();\nList&lt;String&gt; single = new ArrayList&lt;&gt;();\nsingle.add(s.substring(x, y));\nresult.add(single);\nreturn result;\n}\nif (!cachePalindromeSplit[x][y].isEmpty()) {\nreturn cachePalindromeSplit[x][y];\n}\nList&lt;List&lt;String&gt;&gt; possible = new ArrayList&lt;&gt;();\nfor (int end = x; end &lt; y; end++) {\nint start = x;\nString curr = s.substring(start, end + 1);\nList&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();\nif (isPalindrome(start, end)) {\nList&lt;List&lt;String&gt;&gt; all_pali = palindromeSplit(end + 1, y);\nfor (List&lt;String&gt; pali : all_pali) {\nList&lt;String&gt; combined = new ArrayList&lt;&gt;();\ncombined.add(curr);\ncombined.addAll(pali);\nres.add(combined);\n}\n}\npossible.addAll(res);\n}\ncachePalindromeSplit[x][y] = possible;\nreturn possible;\n}\npublic List&lt;List&lt;String&gt;&gt; partition(String s) {\nn = s.length();\ncacheIsPalindrome = new int[n+1][n+1];\ncachePalindromeSplit = new ArrayList[n+1][n+1];\nthis.s = s;\nfor (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= n; j++) cachePalindromeSplit[i][j] = new ArrayList&lt;&gt;();\nreturn palindromeSplit(0, n);\n}\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/131.%20Palindrome%20Partitioning/#comparison", "title": "Comparison", "text": "<ul> <li>Caching can make a different</li> <li>Generate data on the fly using recursion may help on overall python time cost</li> </ul> Time Submitted Status Runtime Memory Language 08/11/2023 19:44 Accepted 502 ms 33.2 MB python3 08/11/2023 19:05 Accepted 521 ms 32.1 MB python3 08/11/2023 19:02 Accepted 600 ms 32.3 MB python3 <ul> <li>The caching is replace by allocate a two dimension array, here is the different between caching and not</li> </ul> Time Submitted Status Runtime Memory Language 08/11/2023 22:05 Accepted 46 ms 56 MB java 08/11/2023 22:00 Accepted 7 ms 55.2 MB java <ul> <li>If you want to make it even faster, we can do some cleaver way utilizing bottom-up call to build up each <code>List&lt;String&gt;</code>. Also, the <code>y</code> variable in <code>palindromeSplit</code> can be remove, it\u2019s not changing after all of calculations. The result implementation look like this:</li> </ul> <pre><code>    private List&lt;List&lt;String&gt;&gt; ans;\nprivate void FindSubstringsq`1(int ind, ArrayList&lt;String&gt; list) {\nif (ind == n) {\nans.add(new ArrayList&lt;String&gt;(list));\nreturn;\n}\nfor (int i = ind + 1; i &lt;= n; i++) {\nif (!isPalindrome(ind, i-1)) continue;\nlist.add(s.substring(ind, i));\nFindSubstrings(i, list);\nlist.remove(list.size() - 1);\n}\n}\npublic List&lt;List&lt;String&gt;&gt; partition(String s) {\nn = s.length();\nthis.s = s;\nans = new ArrayList&lt;List&lt;String&gt;&gt;();\nFindSubstrings(0, new ArrayList&lt;String&gt;());\nreturn ans;\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/134.%20Gas%20Station/", "title": "134. Gas Station", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/134.%20Gas%20Station/#problem", "title": "Problem", "text": "<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>ith</code> station is <code>gas[i]</code>.</p> <p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>ith</code> station to its next <code>(i + 1)th</code> station. You begin the journey with an empty tank at one of the gas stations.</p> <p>Given two integer arrays <code>gas</code> and <code>cost</code>, return the starting gas station\u2019s index if you can travel around the circuit once in the clockwise direction, otherwise return <code>-1</code>. If there exists a solution, it is guaranteed to be unique</p> <p>Example 1:</p> <p>Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index.</p> <p>Example 2:</p> <p>Input: gas = [2,3,4], cost = [3,4,3] Output: -1 Explanation: You can\u2019t start at station 0 or 1, as there is not enough gas to travel to the next station. Let\u2019s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can\u2019t travel around the circuit once no matter where you start.</p> <p>Constraints:</p> <ul> <li><code>n == gas.length == cost.length</code></li> <li><code>1 &lt;= n &lt;= 105</code></li> <li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/134.%20Gas%20Station/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/136.%20Single%20Number/", "title": "136. Single Number", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/136.%20Single%20Number/#problem", "title": "Problem", "text": "<p>Given a non-empty array of integers <code>nums</code>, every element appears twice except for one. Find that single one.</p> <p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p> <p>Example 1: <pre><code>**Input:** nums = [2,2,1]\n**Output:** 1\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/136.%20Single%20Number/#solve", "title": "Solve", "text": "<ul> <li>Using binary <code>xor</code> (<code>^</code> operation in python), we can nullify any two time appear number  </li> <li>The remaining is the needed answer</li> </ul> <pre><code>class Solution:\ndef singleNumber(self, nums: List[int]) -&gt; int:\na_number = 0\nfor n in nums:\na_number ^= n\nreturn a_number\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/139.%20Word%20Break/", "title": "139. Word Break", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/139.%20Word%20Break/#problem", "title": "Problem", "text": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p> <p>Note that the same word in the dictionary may be reused multiple times in the segmentation.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 300</code></li> <li><code>1 &lt;= wordDict.length &lt;= 1000</code></li> <li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li> <li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li> <li>All the strings of <code>wordDict</code> are unique.</li> </ul> <p>Example 1: <pre><code>**Input:** s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n**Output:** true\n**Explanation:** Return true because \"leetcode\" can be segmented as \"leet code\".\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/139.%20Word%20Break/#solve", "title": "Solve", "text": "<p>A example of dynamic programming.</p> <ul> <li>Using <code>set()</code> hash map for better string finding</li> <li>Using evaluation: If <code>s[1]</code> can be create by provided word dict, <code>s[2]</code> is also a word =&gt; that mean <code>s[1]+s[2]</code> can be create by provided word dict. We can using this to form a dynamic programming approach</li> </ul> <pre><code>class Solution:\ndef wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:\nwordDict = set(wordDict)\ndp = [False]*(len(s)+1)\ndp[0] = True\nfor i in range(1, len(s)+1):\nfor j in range(i):\nif dp[j] and (s[j:i] in wordDict):\ndp[i] = True\nreturn dp[len(s)]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/141.%20Linked%20List%20Cycle/", "title": "141. Linked List Cycle", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/141.%20Linked%20List%20Cycle/#problem", "title": "Problem", "text": "<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p> <p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail\u2019s <code>next</code> pointer is connected to. Note that <code>pos</code> is not passed as a parameter.</p> <p>Return <code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.</p> <p>Example 1:</p> <p></p> <p>Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/141.%20Linked%20List%20Cycle/#solve", "title": "Solve", "text": "<p>Keep tracked of any node that we have pass by a hashmap. If we step in a tracked node, then there is a cycle, and we can return <code>True</code>.</p> <p>Return <code>False</code> if otherwise</p> <pre><code>class Solution:\ndef hasCycle(self, head: Optional[ListNode]) -&gt; bool:\ncache = set()\np = head\nwhile p:\nif p in cache:\nreturn True\ncache.add(p)\np = p.next\nreturn False \n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/146.%20LRU%20Cache/", "title": "146. LRU Cache", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/146.%20LRU%20Cache/#problem", "title": "Problem", "text": "<p>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</p> <p>Implement the <code>LRUCache</code> class:</p> <ul> <li><code>LRUCache(int capacity)</code> Initialize the LRU cache with positive size <code>capacity</code>.</li> <li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li> <li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, evict the least recently used key.</li> </ul> <p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= capacity &lt;= 3000</code></li> <li><code>0 &lt;= key &lt;= 104</code></li> <li><code>0 &lt;= value &lt;= 105</code></li> <li>At most <code>2 * 105</code> calls will be made to <code>get</code> and <code>put</code>.</li> </ul> <p>Example 1: <pre><code>**Input**\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4|2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n**Output**\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n</code></pre> Explanation <pre><code>LRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/146.%20LRU%20Cache/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/146.%20LRU%20Cache/#using-build-in", "title": "Using build-in", "text": "<p>Using built-in class <code>OrderedDict</code> of python</p> <pre><code>from collections import OrderedDict\nclass LRUCache:\ndef __init__(self, capacity: int):\nself.capacity = capacity\nself.cache = OrderedDict()\ndef get(self, key: int) -&gt; int:\nif key in self.cache:\nself.cache.move_to_end(key)\nreturn self.cache[key]\nelse:\nreturn -1\ndef put(self, key: int, value: int) -&gt; None:\nif key in self.cache:\nself.cache.move_to_end(key)\nelse:\nif len(self.cache) &gt;= self.capacity:\nself.cache.popitem(last=False)\nself.cache[key] = value\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/146.%20LRU%20Cache/#reimplementation-double-linked-list", "title": "Reimplementation - Double Linked list", "text": "<p>This is a hard task, and require a lot of knowledge from a person. Here is a double linked list version where</p> <ul> <li>Adding a node is pushing it in to end of the linked list, which cost O(1).</li> <li>Popping a node will need  <pre><code>class Node:\ndef __init__(self, key, value):\nself.key = key\nself.value = value\nself.prev = None\nself.next = None\nclass LRUCache:\ndef __init__(self, capacity: int):\nself.capacity = capacity\nself.count = 0\nself.head = None\nself.tail = None\nself.hashmap = {}\ndef delete_node(self, node):\nif node.prev:\nnode.prev.next = node.next\nelse:\nself.head = node.next\nif node.next:\nnode.next.prev = node.prev\nelse:\nself.tail = node.prev\ndef add_to_front(self, node):\nnode.next = self.head\nnode.prev = None\nif self.head:\nself.head.prev = node\nself.head = node\nif not self.tail:\nself.tail = node\ndef update_lru_cache(self, key, value):\nnode = self.hashmap[key]\nif node:\nnode.value = value\nself.delete_node(node)\nself.add_to_front(node)\ndef get(self, key: int) -&gt; int:\nnode = self.hashmap.get(key)\nif node:\nself.delete_node(node)\nself.add_to_front(node)\nreturn node.value\nelse:\nreturn -1\ndef put(self, key: int, value: int) -&gt; None:\nif key in self.hashmap:\nself.update_lru_cache(key, value)\nelse:\nif self.count == self.capacity:\nself.hashmap.pop(self.tail.key)\nself.delete_node(self.tail)\nself.count -= 1\nnew_node = Node(key, value)\nself.hashmap[key] = new_node\nself.add_to_front(new_node)\nself.count += 1\n</code></pre></li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#define MAX_LOOKUP_SIZE (unsigned long)1e4\ntypedef struct cache_node {\nint key;\nint val;\nstruct cache_node* next;\nstruct cache_node* prev;\n} cache_node;\ntypedef struct {\ncache_node* cache;\ncache_node head;\nint capacity;\nint size;\ncache_node* lookup[MAX_LOOKUP_SIZE];\n} LRUCache;\n// Function to create a new cache node\ncache_node* createNode(int key, int value) {\ncache_node* newNode = (cache_node*)malloc(sizeof(cache_node));\nnewNode-&gt;key = key;\nnewNode-&gt;val = value;\nnewNode-&gt;next = NULL;\nnewNode-&gt;prev = NULL;\nreturn newNode;\n}\n// Function to insert a node at the tail of the doubly linked list\nvoid insertAtTail(cache_node* head, cache_node* node) {\ncache_node* tail = head-&gt;prev;\nnode-&gt;next = tail-&gt;next;\nnode-&gt;prev = tail;\ntail-&gt;next = node;\nnode-&gt;next-&gt;prev = node;\n}\n// Function to remove a node from the doubly linked list\nvoid removeNode(cache_node* node) {\nnode-&gt;next-&gt;prev = node-&gt;prev;\nnode-&gt;prev-&gt;next = node-&gt;next;\n}\n// Function to move a node to the tail of the doubly linked list (mark as least recently used)\nvoid makeLRU(cache_node* head, cache_node* node) {\nremoveNode(node);\ninsertAtTail(head, node);\n}\nLRUCache* lRUCacheCreate(int capacity) {\nLRUCache* lru = (LRUCache*)malloc(sizeof(LRUCache));\nmemset(lru-&gt;lookup, 0, sizeof(lru-&gt;lookup));\nlru-&gt;cache = (cache_node*)malloc(sizeof(cache_node) * capacity);\nlru-&gt;size = 0;\nlru-&gt;capacity = capacity;\nlru-&gt;head.next = lru-&gt;head.prev = &amp;lru-&gt;head;\nreturn lru;\n}\nint lRUCacheGet(LRUCache* obj, int key) {\ncache_node* found = obj-&gt;lookup[key];\nif (!found) {\nreturn -1;\n}\nmakeLRU(&amp;obj-&gt;head, found);\nreturn found-&gt;val;\n}\nvoid lRUCachePut(LRUCache* obj, int key, int value) {\ncache_node* found = obj-&gt;lookup[key];\nif (found) {\nfound-&gt;val = value;\nmakeLRU(&amp;obj-&gt;head, found);\nreturn;\n}\ncache_node* head = obj-&gt;head.next;\ncache_node* tmp;\n/* Evict case */\nif (obj-&gt;capacity == obj-&gt;size) {\nobj-&gt;lookup[head-&gt;key] = NULL;\nremoveNode(head);\ntmp = head;\n} else {\ntmp = &amp;obj-&gt;cache[obj-&gt;size++];\n}\ntmp-&gt;key = key;\ntmp-&gt;val = value;\nobj-&gt;lookup[key] = tmp;\ninsertAtTail(&amp;obj-&gt;head, tmp);\n}\nvoid lRUCacheFree(LRUCache* obj) {\nfree(obj-&gt;cache);\nfree(obj);\n}\n</code></pre> <p>For compiler file and testing, you want to add main function <pre><code>int main() {\nLRUCache* cache = lRUCacheCreate(2);\nlRUCachePut(cache, 1, 1);\nlRUCachePut(cache, 2, 2);\nprintf(\"%d\\n\", lRUCacheGet(cache, 1)); // Output: 1\nlRUCachePut(cache, 3, 3);\nprintf(\"%d\\n\", lRUCacheGet(cache, 2)); // Output: -1\nlRUCachePut(cache, 4, 4);\nprintf(\"%d\\n\", lRUCacheGet(cache, 1)); // Output: -1\nprintf(\"%d\\n\", lRUCacheGet(cache, 3)); // Output: 3\nprintf(\"%d\\n\", lRUCacheGet(cache, 4)); // Output: 4\nlRUCacheFree(cache);\nreturn 0;\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/169.%20Majority%20Element/", "title": "169. Majority Element", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/169.%20Majority%20Element/#problem", "title": "Problem", "text": "<p>Given an array <code>nums</code> of size <code>n</code>, return the majority element.</p> <p>The majority element is the element that appears more than <code>\u230an / 2\u230b</code> times. You may assume that the majority element always exists in the array.</p> <p>Constraints:</p> <ul> <li><code>n == nums.length</code></li> <li><code>1 &lt;= n &lt;= 5 * 104</code></li> <li><code>-109 &lt;= nums[i] &lt;= 109</code></li> </ul> <p>Follow-up: Could you solve the problem in linear time and in <code>O(1)</code> space?</p> <p>Example 1: <pre><code>**Input:** nums = [3,2,3]\n**Output:** 3\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/169.%20Majority%20Element/#solve", "title": "Solve", "text": "<p>Let quickly settle this with a hash map counting cache array, ideally with built-in implementation <code>dict()</code> or <code>{}</code> in python</p> <pre><code>class Solution:\ndef majorityElement(self, nums: List[int]) -&gt; int:\nnums_count = {}\nfor n in nums:\nif n not in nums_count:\nnums_count[n] = 0\nnums_count[n] += 1\nif nums_count[n] &gt; len(nums)//2:\nreturn n\nreturn \"Some thing isn't right\"\n</code></pre> <p>A better that using lower memory is using quicksort and return the value of middle <code>n//2</code> index element  <pre><code>class Solution:\ndef majorityElement(self, nums: List[int]) -&gt; int:\nnums.sort()\nreturn nums[n//2]\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/169.%20Majority%20Element/#follow-up-madness", "title": "Follow up madness", "text": "<p>Here is the <code>Crtl + C</code> code: <pre><code>class Solution:\ndef majorityElement(self, nums: List[int]) -&gt; int:\nconfident = 0\nmajority_number = None\nfor current_number in nums:\nif confident == 0:\nmajority_number = current_number\nif current_number == majority_number:\nconfident += 1 \nelse:\nconfident -= 1\nreturn majority_number\n</code></pre></p> <ul> <li>You assuming any number to be the <code>majority_number</code>. </li> <li>With each loop through all available number in <code>nums</code> array we check our <code>confident</code> level<ul> <li>If it appear again: raise our <code>confident</code> by 1</li> <li>Else reducing it by 1</li> <li>When <code>confident = 0</code>, we try change our <code>majority_number</code></li> </ul> </li> <li>Return <code>majority_number</code> after</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/169.%20Majority%20Element/#compare", "title": "Compare?", "text": "<p>Barely notice-able different, the input really easy on us. Unless we using a compiler, a interpreter language like <code>python</code> does not provide good enough information on which faster</p> Argo Time Submitted Status Runtime Memory Language Linear 07/13/2023 14:38 Accepted 180 ms 17.8 MB python3 Sort 07/13/2023 14:22 Accepted 170 ms 17.8 MB python3 Dict 07/13/2023 14:07 Accepted 193 ms 17.8 MB python3", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/171.%20Excel%20Sheet%20Column%20Number/", "title": "171. Excel Sheet Column Number", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/171.%20Excel%20Sheet%20Column%20Number/#problem", "title": "Problem", "text": "<p>Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return its corresponding column number.</p> <p>For example: <pre><code>A -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</code></pre> Example 1: <pre><code>**Input:** columnTitle = \"A\"\n**Output:** 1\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/171.%20Excel%20Sheet%20Column%20Number/#solve", "title": "Solve", "text": "<p>A special base 26 to base 10 problem. That has character set <code>[\"A\", \"B\", ..., \"Z\" ]</code> with corresponds value <code>[1,2,3,4,...,26]</code> </p> <pre><code>class Solution:\ndef titleToNumber(self, columnTitle: str) -&gt; int:\nsub_base26 = columnTitle[::-1]\ntrue_value = 0\nfor index, char in enumerate(sub_base26):\ntrue_value += (ord(char) - ord(\"A\") + 1) * (26 ** index)\nreturn true_value\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/190.%20Reverse%20Bits/", "title": "190. Reverse Bits", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/190.%20Reverse%20Bits/#problem", "title": "Problem", "text": "<p>Reverse bits of a given 32 bits unsigned integer.</p> <p>Note:</p> <ul> <li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer\u2019s internal binary representation is the same, whether it is signed or unsigned.</li> <li>In Java, the compiler represents the signed integers using 2\u2019s complement notation. Therefore, in Example 2 above, the input represents the signed integer <code>-3</code> and the output represents the signed integer <code>-1073741825</code>.</li> </ul> <p>Constraints:</p> <ul> <li>The input must be a binary string of length <code>32</code></li> </ul> <p>Example 1: <pre><code>**Input:** n = 00000010100101000001111010011100\n**Output:**    964176192 (00111001011110000010100101000000)\n**Explanation:** The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596, so return 964176192 which its binary representation is **00111001011110000010100101000000**.\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/190.%20Reverse%20Bits/#solve", "title": "Solve", "text": "<p>Here is what i done:</p> <ul> <li>Turn number <code>n</code> to binary string using <code>bin(n)</code></li> <li>Padding <code>0</code> to get enough 32 bit, by adding <code>(1&lt;&lt;32)</code> and remove first bit of the string <code>bin(n)</code> (And <code>0b</code> string from the result, which in total is 3 character)</li> <li>Revert the product string using <code>[::-1]</code></li> <li>And finally turn the revert binary string back to number using <code>int(&lt;binary_string&gt;, base=2)</code> <pre><code>class Solution:\ndef reverseBits(self, n: int) -&gt; int:\nreturn int`-1], base=2`\n</code></pre></li> </ul> <p>Or just simple adding it bit by bit, using binary manipulation <pre><code>uint32_t reverseBits(uint32_t n) {\nuint32_t r_num = 0;\nfor (int i = 0; i &lt; 32; i++) {\nr_num &lt;&lt;= 1; //r_num = r_num * 2\nr_num += (n &gt;&gt; i) &amp; 1; // r_num = r_num + n[32-i] \n}\nreturn r_num;\n}\n</code></pre></p> Time Submitted Status Runtime Memory Language 07/17/2023 22:57 Accepted 1 ms 5.4 MB c 07/17/2023 22:45 Accepted 53 ms 16.2 MB python3", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/191.%20Number%20of%201%20Bits/", "title": "191. Number of 1 Bits", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/191.%20Number%20of%201%20Bits/#problem", "title": "Problem", "text": "<p>Write a function that takes the binary representation of an unsigned integer and returns the number of \u20181\u2019 bits it has (also known as the Hamming weight).</p> <p>Constraints:</p> <ul> <li>The input must be a binary string of length <code>32</code>.</li> </ul> <p>Note:</p> <ul> <li>Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer\u2019s internal binary representation is the same, whether it is signed or unsigned.</li> <li>In Java, the compiler represents the signed integers using 2\u2019s complement notation. Therefore, in Example 3, the input represents the signed integer. <code>-3</code>.</li> </ul> <p>Example 1: <pre><code>**Input:** n = 00000000000000000000000000001011\n**Output:** 3\n**Explanation:** The input binary string **00000000000000000000000000001011** has a total of three '1' bits.\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/191.%20Number%20of%201%20Bits/#solve", "title": "Solve", "text": "<p>Python have a exact function <code>int.bit_count()</code> to do this task</p> <pre><code>class Solution:\ndef hammingWeight(self, n: int) -&gt; int:\nreturn n.bit_count()\n</code></pre> <p>Other than that could be: Turn any number to binary <pre><code>class Solution:\ndef hammingWeight(self, n: int) -&gt; int:\nreturn bin(n)[2:].count(\"1\")\n</code></pre></p> <p>While with C/C++, counting using bit manipulation <pre><code>int hammingWeight(uint32_t n) {\nint count = 0;\nwhile (n != 0) {\ncount += n &amp; 1; // count = count + n % 2;\nn &gt;&gt;= 1; // n = n / 2\n}\nreturn count;\n}\n</code></pre></p> Time Submitted Status Runtime Memory Language 07/17/2023 22:33 Accepted 2 ms 5.5 MB c 07/17/2023 22:29 Accepted 47 ms 16.3 MB python3 07/17/2023 22:25 Accepted 41 ms 16.2 MB python3", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/202.%20Happy%20Number/", "title": "202. Happy Number", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/202.%20Happy%20Number/#problem", "title": "Problem", "text": "<p>Write an algorithm to determine if a number <code>n</code> is happy.</p> <p>A happy number is a number defined by the following process:</p> <ul> <li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li> <li>Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</li> <li>Those numbers for which this process ends in 1 are happy.</li> </ul> <p>Return <code>true</code> if <code>n</code> is a happy number, and <code>false</code> if not.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 2**31 - 1</code></li> </ul> <p>Example 1:</p> <pre><code>**Input:** n = 19\n**Output:** true\n**Explanation:**\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/202.%20Happy%20Number/#solve", "title": "Solve", "text": "<p>Loop until n == 1. No cycle found return <code>True</code> If we found a cycle, return <code>False</code></p> <p>We can stored visited node into a hash map to check cycle</p> <pre><code>class Solution:\ndef isHappy(self, n: int) -&gt; bool:\nvisited = set()\nwhile n != 1:\nif n in visited:\nreturn False\nvisited.add(n)\nm = 0\ntmp = n\nwhile tmp:\nm += (tmp % 10) ** 2\ntmp = tmp // 10\nn = m\nreturn True\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/206.%20Reverse%20Linked%20List/", "title": "206. Reverse Linked List", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/206.%20Reverse%20Linked%20List/#problem", "title": "Problem", "text": "<p>Given the <code>head</code> of a singly linked list, reverse the list, and return the reversed list.</p> <p>Constraints:</p> <ul> <li>The number of nodes in the list is the range <code>[0, 5000]</code>.</li> <li><code>-5000 &lt;= Node.val &lt;= 5000</code></li> </ul> <p>Example 1:</p> <p></p> <p>Input: head = [1,2,3,4,5] Output: [5,4,3,2,1]</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/206.%20Reverse%20Linked%20List/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/206.%20Reverse%20Linked%20List/#stack", "title": "Stack", "text": "<pre><code>class Solution:\ndef reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\nqueue = []\np = head\nwhile p:\nqueue.append(p)\np = p.next\nresult = None\np = None\nwhile queue:\nif result is None:\nresult = queue.pop()\np = result\nelse:\np.next = queue.pop()\np = p.next\nif p:\np.next = None\nreturn result\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/206.%20Reverse%20Linked%20List/#recursion", "title": "Recursion", "text": "<p>We start with this order: go to the node first, then process our current node value (using <code>print</code> as a place holder) </p> <pre><code>class Solution:\ndef reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\nresult = None\ndef helper(node):\nif node:\nhelper(node.next)\nprint(node.val)\nhelper(head)\nreturn None\n</code></pre> <p>Now instead of printing, we adding node to result instead. Here I using <code>p</code> as a temporary storing the end of <code>result</code> linked list  of link list for O(1) time insert.</p> <pre><code>class Solution:\ndef reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\nself.result = None\nself.p = None\ndef helper(node):\nif node:\nhelper(node.next)\nif self.result is None:\nself.result = node\nself.p = self.result\nelse:\nself.p.next = node\nself.p = self.p.next\nself.p.next = None\nhelper(head)\nreturn self.result\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/207.%20Course%20Schedule/", "title": "207. Course Schedule", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/207.%20Course%20Schedule/#problem", "title": "Problem", "text": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [ai, bi]</code> indicates that you must take course <code>bi</code> first if you want to take course <code>ai</code>.</p> <ul> <li>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</li> </ul> <p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= numCourses &lt;= 2000</code></li> <li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li> <li><code>prerequisites[i].length == 2</code></li> <li><code>0 &lt;= ai, bi &lt; numCourses</code></li> <li>All the pairs <code>prerequisites[i]</code> are unique.</li> </ul> <p>Example 1:</p> <pre><code>**Input:** numCourses = 2, prerequisites = [[1,0|1,0]]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/207.%20Course%20Schedule/#solve", "title": "Solve", "text": "<p>We have solve 802. Find Eventual Safe States, which do the same problem. The course that can finish need to be a safe node in graph (node that can\u2019t start a cycle path).</p> <ul> <li>We change the input Graph Edges table into better Graph Adj Node table representation. </li> <li>Run the already solve find safe node and get all finish-able course.</li> <li>We now check every course, if we found one isn\u2019t a is safe node then return <code>False</code>, else return <code>True</code></li> </ul> <p>Here we get the best approach, which is a DFS solution to find safe node.  <pre><code>class Solution:\ndef canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\ngraph = [[] for i in range(numCourses)]\nfor u, v in prerequisites:\ngraph[u].append(v)\nis_safe_node = [None] * len(graph)\ndef DFS(current_node_id):\nif not is_safe_node[current_node_id] is None:\nreturn is_safe_node[current_node_id]\nis_safe_node[current_node_id] = False\nfor adj_node_id in graph[current_node_id]:\nif DFS(adj_node_id) == False:\nreturn False\nis_safe_node[current_node_id] = True\nreturn True\nfor course_id in range(numCourses):\nif not DFS(course_id):\nreturn False\nreturn True\n</code></pre></p> <p>I also give Simulation approach a try, which give almost the same in result.  <pre><code>class Solution:\ndef canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:\ngraph = [[] for i in range(numCourses)]\nfor u, v in prerequisites:\ngraph[u].append(v)\nindegree = [0] * len(graph)\nis_safe_node = [False] * len(graph)\nref_table = [set() for _ in graph]\nfound_safe_node = []\nfor node_id, adjNodes in enumerate(graph):\nif len(adjNodes) == 0:\nfound_safe_node.append(node_id)\nis_safe_node[node_id] = True\nindegree[node_id] = len(adjNodes)\nfor adjNode in adjNodes:\nref_table[adjNode].add(node_id)\nwhile len(found_safe_node) &gt; 0:\nnode_id = found_safe_node.pop(0)\nfor ref_node in ref_table[node_id]:\nif is_safe_node[ref_node]:\nref_table[ref_node] -= set([node_id])\ncontinue\nindegree[ref_node] -= 1\nif indegree[ref_node] == 0:\nfound_safe_node.append(ref_node)\nis_safe_node[ref_node] = True\nfor node_id, is_safe in enumerate(is_safe_node):\nif not is_safe:\nreturn False\nreturn True\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/207.%20Course%20Schedule/#final-comparation", "title": "Final comparation", "text": "Argo Time Submitted Status Runtime Memory Language DFS 07/13/2023 12:14 Accepted 108 ms 17.6 MB python3 Simulation 07/13/2023 12:03 Accepted 112 ms 19.1 MB python3", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/", "title": "215. Kth Largest Element in an Array", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/#problem", "title": "Problem", "text": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>kth</code> largest element in the array.</p> <p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p> <p>Can you solve it without sorting?</p> <p>Example 1:</p> <p>Input: nums = [3,2,1,5,6,4], k = 2 Output: 5</p> <p>Example 2:</p> <p>Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= k &lt;= nums.length &lt;= 10**5</code></li> <li><code>-10**4 &lt;= nums[i] &lt;= 10**4</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/#quick-select-similarity-to-quick-sort", "title": "Quick select - similarity to quick sort", "text": "<p>Using same ideal of quick sort, we chose a <code>target</code>, split the <code>nums</code> array to 3 subarray base on the comparing result of <code>target</code> and <code>nums[i]</code>, which is</p> <pre><code>[smaller] [equal] [bigger]\n</code></pre> <p>To find any <code>k</code>\u2018th largest position, we select in the range that <code>k</code> in, which mean:</p> <ul> <li><code>k</code> in <code>[bigger]</code> sub array If <code>k &lt;= len(bigger)</code></li> <li><code>k</code> in <code>[equal]</code> sub array If <code>len(bigger) &lt; k &lt;= len(bigger) + len(equal)</code></li> <li><code>k</code> in <code>[smaller]</code> sub array If <code>len(bigger) + len(equal) &lt; k</code></li> </ul> <p>Base on where <code>k</code> is, we narrow down the finding process. Stop if k in <code>[equal]</code> sub array and return <code>target</code>. </p> <p>By randomly chose the target, we effectively preventing bad input (already sorted) array. </p> Time Submitted Status Runtime Memory Language 08/14/2023 14:59 Accepted 6347 ms 29.7 MB python3 08/14/2023 14:58 Accepted 2348 ms 30 MB python3 <pre><code>class Solution:\ndef findKthLargest(self, nums: List[int], k: int) -&gt; int:\nremain = nums.copy()\npos = k\nwhile len(remain) &gt; 0:\ntarget = remain[randrange(0, len(remain))]\n# target = remain[0]\nbigger = []\nequad = []\ni = 0\nwhile i &lt; len(remain):\nif remain[i] &gt; target:\nbigger.append(remain.pop(i))\nelif remain[i] == target:\nequad.append(remain.pop(i))\nelse:\ni += 1\n# print(remain, equad, bigger, pos)\nif  pos &lt;= len(equad) + len(bigger):\nif pos &lt;= len(bigger):\nremain = bigger\nelse:\nreturn target\nelse:\npos = pos - len(bigger) - len(equad)\nreturn 0\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/#sorting-counting-sort", "title": "Sorting - Counting sort", "text": "<p>Counting sort could give the best way to sort a low range of number value (`-104 &lt;= nums[i] &lt;= 104)</p> <p>Base on sort result, we can easily get the k\u2019th largest result</p> Time Submitted Status Runtime Memory Language 08/14/2023 15:32 Accepted 403 ms 29.5 MB python3 <pre><code>class Solution:\ndef findKthLargest(self, nums: List[int], k: int) -&gt; int:\ncount = [0] * 20001\nfor n in nums:\ncount[n + 10000] += 1\npos = 0\nfor `-1]`:\npos += c\nif pos &gt;= k:\nreturn 10000 - i\nreturn 0\n</code></pre> <p>There isn\u2019t negative for array value, while you can use <code>dict</code>, it quite slower. </p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/#c-implementation", "title": "<code>c</code> implementation", "text": "<p>While I hate how you [[pass around variable|pass around variable]] in <code>c</code> language, and how hard it is to set up a proper project folder.</p> <p>This is me trying to implement the quick select solution. But we don\u2019t want to implement Vector like (Using Linked list) or hard code allocating <code>[0..10**5]</code> length array like python code, I try implement <code>O(1)</code> memory space solution </p> <p>Final file: https://github.com/ylsama/leetcode/blob/main/215/c/src/main.c</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/#quick-sort", "title": "Quick sort", "text": "<p>To implement quick select, it is likely require you to know how to implement quicksort algorithms. By sorting, we can just then return the <code>k'th</code> largest value to finish the problem.</p> Time Submitted Status Runtime Memory Language 08/14/2023 20:03 Accepted 210 ms 11.2 MB c <pre><code>void swap(int *x, int *y) {\nint tmp = *x;\n*x = *y;\n*y = tmp;\n}\nint partition(int *nums, int low, int high) {\nint pivot = nums[high];\nint i = (low - 1);\nfor (int j = low; j &lt;= high - 1; j++) {\nif (nums[j] &lt;= pivot) {\ni++;\nswap(&amp;nums[i], &amp;nums[j]);\n}\n}\nswap(&amp;nums[i + 1], &amp;nums[high]);\nreturn (i + 1);\n}\nvoid quicksort(int *nums, int low, int high) {\nif (low &lt; high) {\nint pivotIndex = partition(nums, low, high);\nquicksort(nums, low, pivotIndex - 1);\nquicksort(nums, pivotIndex + 1, high);\n}\n}\nint findKthLargest(int *nums, int numsSize, int k) {\nquicksort(nums, 0, numsSize - 1);\nreturn nums[numsSize - k];\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/#quick-select", "title": "Quick select", "text": "<p>Quick select in O(1) space is just us effectively sort the <code>nums</code> array only in needed part. </p> Time Submitted Status Runtime Memory Language 08/14/2023 19:47 Accepted 91 ms 11.5 MB c <pre><code>void swap(int *x, int *y) {\nint tmp = *x;\n*x = *y;\n*y = tmp;\n}\nint partition(int *nums, int low, int high) {\nint pivot = nums[high];\nint i = (low - 1);\nfor (int j = low; j &lt;= high - 1; j++) {\nif (nums[j] &lt;= pivot) {\ni++;\nswap(&amp;nums[i], &amp;nums[j]);\n}\n}\nswap(&amp;nums[i + 1], &amp;nums[high]);\nreturn (i + 1);\n}\nint quickSellect(int *nums, int low, int high, int pos) {\nif (low &lt; high) {\nint pivotIndex = partition(nums, low, high);\nif (pivotIndex == pos) {\nreturn nums[pivotIndex];\n} else if (pivotIndex &gt; pos) {\nreturn quickSellect(nums, low, pivotIndex - 1, pos);\n} else {\nreturn quickSellect(nums, pivotIndex + 1, high, pos);\n}\n} else if (low == pos) {\nreturn nums[low];\n}\nreturn -1;\n}\nint findKthLargest(int *nums, int numsSize, int k) {\nint res = quickSellect(nums, 0, numsSize - 1, numsSize - k);\nreturn res;\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/215.%20Kth%20Largest%20Element%20in%20an%20Array/#rust-implementation", "title": "<code>rust</code> implementation", "text": "<ul> <li>OOP in rust is quite weird (meaning I mean I haven\u2019t done in it enough), while rust does provide <code>self</code>, it not being used here.</li> </ul> <pre><code>impl Solution {\nfn partition(nums: &amp;mut [i32], low: usize, high: usize) -&gt; usize {\nlet pivot = nums[high];\nlet mut i = low as isize - 1;\nfor j in low..high {\nif nums[j] &lt;= pivot {\ni += 1;\nnums.swap(i as usize, j);\n}\n}\nnums.swap((i + 1) as usize, high);\n(i + 1) as usize\n}\nfn quick_select(nums: &amp;mut [i32], low: usize, high: usize, pos: usize) -&gt; i32 {\nif low &lt; high {\nlet pivot_index = Solution::partition(nums, low, high);\nif pivot_index == pos {\nreturn nums[pivot_index];\n} else if pivot_index &gt; pos {\nreturn Solution::quick_select(nums, low, pivot_index - 1, pos);\n} else {\nreturn Solution::quick_select(nums, pivot_index + 1, high, pos);\n}\n} else if low == pos {\nreturn nums[low];\n}\n-1\n}\npub fn find_kth_largest(nums: Vec&lt;i32&gt;, k: i32) -&gt; i32 {\nlet mut nums_mut = nums.to_vec();\nSolution::quick_select(&amp;mut nums_mut, 0, nums.len() - 1, nums.len() - k as usize)\n}\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "sort", "divide_and_conquer"]}, {"location": "notes/Leetcode%20100-1000/217.%20Contains%20Duplicate/", "title": "217. Contains Duplicate", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/217.%20Contains%20Duplicate/#problem", "title": "Problem", "text": "<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears at least twice in the array, and return <code>false</code> if every element is distinct.</p> <p>Example 1: <pre><code>**Input:** nums = [1,2,3,1]\n**Output:** true\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/217.%20Contains%20Duplicate/#solve", "title": "Solve", "text": "<p>We can use hash map to make our cache memory of found number</p> <ul> <li>Loop through all number If we found a collision then return <code>True</code>,</li> <li>Return <code>False</code> </li> </ul> <pre><code>class Solution:\ndef containsDuplicate(self, nums: List[int]) -&gt; bool:\ncache = set()\nfor n in nums:\nif n in cache:\nreturn True\ncache.add(n)\nreturn False\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/234.%20Palindrome%20Linked%20List/", "title": "234. Palindrome Linked List", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/234.%20Palindrome%20Linked%20List/#problem", "title": "Problem", "text": "<p>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome or <code>false</code> otherwise.</p> <p>Constraints:</p> <ul> <li>The number of nodes in the list is in the range <code>[1, 105]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 9</code></li> <li>Example 1:</li> </ul> <p></p> <p>Input: head = [1,2,2,1] Output: true</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/234.%20Palindrome%20Linked%20List/#solve", "title": "Solve", "text": "<pre><code>class Solution:\ndef isPalindrome(self, head: Optional[ListNode]) -&gt; bool:\nif not head or not head.next:  # Handle empty list or single-node list\nreturn True\n# Helper function to reverse a linked list\ndef reverse_list(node):\nbefore = None\nwhile node:\ntmp = node.next\nnode.next = before\nbefore = node\nnode = tmp\nreturn before\nslow, fast = head, head\nwhile fast and fast.next:\nslow = slow.next\nfast = fast.next.next\nif fast:  # Odd number of nodes\nslow = slow.next\nreversed_second_half = reverse_list(slow)\n# Compare the first half and the reversed second half\nwhile reversed_second_half:\nif head.val != reversed_second_half.val:\nreturn False\nhead = head.next\nreversed_second_half = reversed_second_half.next\nreturn True\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/239.%20Sliding%20Window%20Maximum/", "title": "239. Sliding Window Maximum", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/239.%20Sliding%20Window%20Maximum/#problem", "title": "Problem", "text": "<p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p> <p>Return the max sliding window.</p> <p>Example 1:</p> <p>Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: <pre><code>Window position                 Max\n---------------                 -----\n[1  3  -1] -3  5  3  6  7       **3**\n 1 [3  -1  -3] 5  3  6  7       **3**\n 1  3 [-1  -3  5] 3  6  7       **5**\n 1  3  -1 [-3  5  3] 6  7       **5**\n 1  3  -1  -3 [5  3  6] 7       **6**\n 1  3  -1  -3  5 [3  6  7]      **7**\n</code></pre> Example 2:</p> <p>Input: nums = [1], k = 1 Output: [1]</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 105</code></li> <li><code>-10**4 &lt;= nums[i] &lt;= 10**4</code></li> <li><code>1 &lt;= k &lt;= nums.length</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/239.%20Sliding%20Window%20Maximum/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/239.%20Sliding%20Window%20Maximum/#re-run-sum-every-time", "title": "Re-run sum every time", "text": "<p>This is a TLE solution</p> <p>There isn\u2019t much thing to said, still I try to do some thing cleaver:</p> <ul> <li>We use a circle to store the current sliding window</li> <li>The max function O(k) is call only if the added number is smaller than replace value and replace value is our current maximum number </li> </ul> Time Submitted Status Runtime Memory Language 08/16/2023 18:17 Time Limit Exceeded N/A N/A python3 <pre><code>class Solution:\ndef maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:\ncircle = nums[:k]\ncurrMax = max(circle)\nres = [currMax]\nindex = 0\nrerun = False\nfor v in nums[k:]:\nif circle[index] == currMax:\nrerun = True\nif v &gt;= currMax:\nrerun = False\ncurrMax = v\ncircle[index] = v\nif rerun:\nrerun = False\ncurrMax = max(circle)\nres.append(currMax)\nindex += 1\nindex %= k\nreturn res\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/239.%20Sliding%20Window%20Maximum/#min-max-tree", "title": "Min-max tree", "text": "<p>A good close to O(log n) time complexity to find any Maximum number in any range. The process is that we build and storing divide by 2 of the array maximum</p> <pre><code>array:  1 2 3 4 5 6 7 8\ntree :  [2] [4] [6] [8]\n        [  4  ] [  8  ] \n        [      8      ]\n</code></pre> <p>We then travel through and comparing all node that covering <code>[x, y]</code> range  </p> Time Submitted Status Runtime Memory Language 08/16/2023 23:24 Accepted 8451 ms 352 MB python3 <pre><code>class Solution:\ndef maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:\ncache = {}\n# inclusive\ndef buildCache(l, r):\nif l == r:\ncache[(l,r)] = nums[l]\nelse:\nm = (l + r) // 2\nbuildCache(l, m)\nbuildCache(m+1, r)\ncache[(l,r)] = max(cache[(l,m)], cache[(m+1,r)])\nbuildCache(0, len(nums) - 1)\ndef getCache(x, y, l=0, r=len(nums)-1):\nif (y &lt; l) or (r &lt; x):\nreturn -100000\nif (x &lt;= l &lt;= r &lt;= y):\nreturn cache[(l,r)]\nm = (l + r) // 2\nreturn max(getCache(x,y, l,m), getCache(x,y, m+1,r))\nres = []\nfor i in range(len(nums)-k+1):\nres.append(getCache(i, i+k-1))\nreturn res\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/239.%20Sliding%20Window%20Maximum/#priority-queue-with-random-access-update", "title": "Priority Queue with random access update", "text": "<p>Another good close to O(log n) time complexity that creating a Heap to easily find Maximum number. </p> <p>The process is that we build a modified heap with a replace that can access the last insert number and replace it with the next number, base on:</p> <ul> <li>A cycle, fixed size <code>array</code>, that use to mimic the current sliding window. In the implement already remove that.</li> <li>A heap <code>self.heap</code></li> <li>Array <code>possition</code> that index <code>i</code> store the position of <code>heap</code> element <code>i</code>  in <code>array</code>. Or <code>array[i] == heap[pos[i]]</code></li> <li>Array <code>revertPossition</code> that index <code>i</code> store the position of <code>array</code> element <code>i</code> in the <code>heap</code>. Or <code>array[revPos[i]] == heap[i]</code></li> </ul> <p>Example: <pre><code>index  [1, 2, 3, 4, 5, 6, 7, 8]\n---\nnums   [1, 9, 8, 4, 4, 3, 2, 5, 1, 3 , ...\narray  [1, 9, 8, 4, 4, 3, 2, 5]\nheap   [9, 5, 8, 4, 4, 3, 2, 1]\npos    [2, 8, 3, 4, 5, 6, 7, 1]\nrevPos [8, 1, 3, 4, 5, 6, 7, 2]\n</code></pre></p> <p>Explain: </p> <ul> <li>Element <code>9</code> have position <code>1</code> in the <code>heap</code>, but have the position <code>2</code> in the array; So its <code>possition</code> is <code>2</code></li> <li>Element <code>1</code> have position <code>1</code> in the <code>array</code>, but have the position <code>1</code> in the array; So its <code>revertPossition</code> is <code>8</code> </li> </ul> <p>So, when we update our sliding window <code>array</code>. We remove the last insert <code>next</code> element of cycle, fixed size <code>array</code>, change it to new value <code>v</code> of the next number in <code>nums</code> array. While doing so, we update:</p> <ul> <li><code>heap</code>: Replacing <code>heap[revPos[next]]</code> with new value <code>v</code></li> <li>We then update the <code>heap</code> base on <code>v</code> value (go up or down in the heap). We also keep track of <code>pos</code> and <code>revPos</code> change by swapping them correspond with <code>heap</code> element position change:<ul> <li><code>swap(pos[parrent], pos[child])</code> : Basic swaping</li> <li><code>swap(revertPos[ pos[child] ], self.revertPos[ pos[parrent] ])</code> : Advantage swap, took me too long when trying to done the <code>revertPos</code> array directly (no <code>pos</code> array). After lot of trial and error, I have to go back to this implementation for simplicity.</li> </ul> </li> </ul> <p>It took quite some time to reimplement heap, quite great that I can done it.  </p> <p>The <code>Heap</code> data structure is implement base on array. To reduce the complexity of the calculation I use array <code>[1..n]</code> by padding  all of my array with element <code>[0]</code> (as array in python start at <code>0</code>)</p> <p>Start at node <code>x</code> in the heap, we can access</p> <ul> <li>To get parent node: <code>x//2</code> (<code>if x != 1</code>) </li> <li>To get child node: <code>x*2</code> , <code>x*2 + 1</code> (<code>if them inside the heap</code>)</li> </ul> <p>The heap have fixed size, and the update is change directly on one of heap node, so we only implement <code>up</code>, <code>down</code> function to update the element position after change.</p> <p>The main component is keep track of <code>next</code> element that need to replace. The <code>array</code> is cycle, with index <code>[1..n]</code> (inclusive), so <code>next</code> is increase by one or restart to <code>1</code> at <code>next == n+1</code> every loop  </p> <pre><code>from typing import List\nclass Heap:\ndef getChild(self, x):\nres = []\nif x*2+1 &lt;= self.size:\nres.append(x*2+1)\nif x*2 &lt;= self.size:\nres.append(x*2)\nreturn res\ndef getParrent(x):\nreturn x // 2\ndef __init__(self, arr):\nself.heap = [-1] + arr\nself.size = len(arr)\nself.pos = list(range(self.size + 1))\nself.revertPos = list(range(self.size + 1))\nself.next = 1\nfor i in range(1, self.size+1):\nself.update(i)\nfor i in range(1, self.size+1):\nself.revertPos[self.pos[i]] = i\ndef update(self, x):\nif x == 1:\nreturn\npx = Heap.getParrent(x)\nif self.heap[x] &gt; self.heap[px]:\nself.heap[x], self.heap[px] = self.heap[px], self.heap[x]\nself.pos[x], self.pos[px] = self.pos[px], self.pos[x]\nself.revertPos[self.pos[x]], self.revertPos[self.pos[px]\n] = self.revertPos[self.pos[px]], self.revertPos[self.pos[x]]\nself.update(px)\ndef downgrade(self, x):\ncx_arr = self.getChild(x)\nif len(cx_arr) == 2 and self.heap[cx_arr[1]] &gt; self.heap[cx_arr[0]]:\ncx_arr.pop(0)\nfor cx in cx_arr:\nif self.heap[x] &lt; self.heap[cx]:\nself.heap[x], self.heap[cx] = self.heap[cx], self.heap[x]\nself.pos[x], self.pos[cx] = self.pos[cx], self.pos[x]\nself.revertPos[self.pos[x]], self.revertPos[self.pos[cx]\n] = self.revertPos[self.pos[cx]], self.revertPos[self.pos[x]]\nself.downgrade(cx)\nbreak\ndef incNext(self):\nif self.next &gt;= self.size:\nself.next = 1\nelse:\nself.next += 1\ndef replace(self, v):\npos = self.revertPos[self.next]\nself.incNext()\nold = self.heap[pos]\nself.heap[pos] = v\nif old &lt; v:\nself.update(pos)\nelse:\nself.downgrade(pos)\nclass Solution:\ndef maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:\nheap = Heap(nums[:k])\nres = [heap.heap[1]]\nfor i in nums[k:]:\nheap.replace(i)\nres.append(heap.heap[1])\nreturn res\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/242.%20Valid%20Anagram/", "title": "242. Valid Anagram", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/242.%20Valid%20Anagram/#problem", "title": "Problem", "text": "<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if <code>t</code> is an anagram of <code>s</code>, and <code>false</code> otherwise.</p> <p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li> <li><code>s</code> and <code>t</code> consist of lowercase English letters.</li> </ul> <p>Example 1: <pre><code>**Input:** s = \"anagram\", t = \"nagaram\"\n**Output:** true\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/242.%20Valid%20Anagram/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/242.%20Valid%20Anagram/#sort-and-compare-using-hash", "title": "Sort and compare using hash", "text": "<p>Re-arrange both string with sort or count each character them comparing. I prefer Re-arrange as it has the lowest memory</p> <pre><code>class Solution:\ndef isAnagram(self, s: str, t: str) -&gt; bool:\nreturn sorted(s) == sorted(t)\n</code></pre> <p>I want to implement C code that using similar approach. C not have provided <code>hash</code> function so we use a implement of djb2 hash <pre><code>// djb2 hash function for strings\nunsigned long hash_string(const char* str) {\nunsigned long hash = 5381;\nint c;\nwhile ((c = *str++)) {\nhash = ((hash &lt;&lt; 5) + hash) + c; /* hash * 33 + c */\n}\nreturn hash;\n}\nint compare_char(const void* a, const void* b) {\nreturn *(char*)a - *(char*)b;\n}\nbool isAnagram(char* s, char* t) {\nint len_s = strlen(s);\nint len_t = strlen(t);\nif (len_s != len_t) {\nreturn false;\n}\nqsort(s, len_s, sizeof(char), compare_char);\nqsort(t, len_t, sizeof(char), compare_char);\nreturn hash_string(s) == hash_string(t);\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/242.%20Valid%20Anagram/#counting", "title": "Counting", "text": "<p>While this isn\u2019t a general way, we only have a range of 26 character, which quite low, and count sort is a great <code>O(n)</code> way to deal with these type of problem.</p> <pre><code>int isAnagram(char * s, char * t){\nint lens = strlen(s);\nif (lens != strlen(t)) return 0;\nint s_counter[26] = {0};\nint t_counter[26] = {0};\nfor (int i = 0; i &lt; lens; i++){\nint curr_letter_s = s[i] - 97;\ns_counter[curr_letter_s]++;\nint curr_letter_t = t[i] - 97;\nt_counter[curr_letter_t]++;\n}\nfor (int i = 0; i &lt; 26; i++){\nif (s_counter[i] != t_counter[i]) return 0;\n}\nreturn 1;\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/242.%20Valid%20Anagram/#compare", "title": "Compare", "text": "Time Submitted Status Runtime Memory Language 07/19/2023 22:07 Accepted 6 ms 5.8 MB c 07/19/2023 22:04 Accepted 30 ms 6.3 MB c 07/19/2023 21:59 Accepted 71 ms 17.4 MB python3", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/268.%20Missing%20Number/", "title": "268. Missing Number", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/268.%20Missing%20Number/#problem", "title": "Problem", "text": "<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return the only number in the range that is missing from the array.</p> <p>Constraints:</p> <ul> <li><code>n == nums.length</code></li> <li><code>1 &lt;= n &lt;= 10**4</code></li> <li><code>0 &lt;= nums[i] &lt;= n</code></li> <li>All the numbers of <code>nums</code> are unique.</li> </ul> <p>Example 1: <pre><code>**Input:** nums = [3,0,1]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/268.%20Missing%20Number/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/268.%20Missing%20Number/#bit-manipulation", "title": "Bit manipulation", "text": "<p>We can use <code>xor</code> to get needed information: </p> <ul> <li><code>Xor</code> two same number will return 0</li> <li>While <code>Xor</code> any number with 0 return it self</li> </ul> <p>We already know <code>nums</code> array is range <code>[0..len(nums)]</code> with a missing number. By <code>xor</code> all available number in range <code>[0..len(nums)]</code> again, we effectively negative all exist number in <code>nums</code> array, leaving only one missing number left being <code>xor</code> with <code>0</code>.</p> <p>Which mean, the sum <code>s</code> of <code>xor</code> all number is our needed result missing number</p> <pre><code>class Solution:\ndef missingNumber(self, nums: List[int]) -&gt; int:\ns = 0\nfor i, x in enumerate(nums):\ns = s ^ i ^ x\ns = s ^ len(nums)\nreturn s\n</code></pre> <p>Same implement in C <pre><code>int missingNumber(int* nums, int numsSize){\nint s = 0;\nfor (int i = 0; i &lt; numsSize; i++) {\ns ^= i ^ nums[i];\n}\ns ^= numsSize;\nreturn s;\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/268.%20Missing%20Number/#sort-counting-caching-binary-search-tree", "title": "Sort, Counting, Caching, Binary search tree\u2026", "text": "<p>Try to find missing number by checking all possible answer one by one:</p> <ul> <li>Loop through <code>nums</code> array, remember all found number</li> <li>Checking again in range <code>[0..len(number)]</code> and our chosen caching information from previous step to quickly separate: which number is in <code>nums</code> array, and which is the missing one</li> </ul> <pre><code>class Solution:\ndef missingNumber(self, nums: List[int]) -&gt; int:\nisFound = [False] * (len(nums)+1)\nfor x in nums:\nisFound[x] = True\nfor i, f in enumerate(isFound):\nif not f:\nreturn i\nreturn len(nums)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/274.%20H-Index/", "title": "274. H Index", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "binary_search"]}, {"location": "notes/Leetcode%20100-1000/274.%20H-Index/#problem", "title": "Problem", "text": "<p>Given an array of integers <code>citations</code> where <code>citations[i]</code> is the number of citations a researcher received for their <code>ith</code> paper, return the researcher\u2019s h-index.</p> <p>According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of <code>h</code> such that the given researcher has published at least <code>h</code> papers that have each been cited at least <code>h</code> times.</p> <p>Example 1:</p> <p>Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.</p> <p>Example 2:</p> <p>Input: citations = [1,3,1] Output: 1</p> <p>Constraints:</p> <ul> <li><code>n == citations.length</code></li> <li><code>1 &lt;= n &lt;= 5000</code></li> <li><code>0 &lt;= citations[i] &lt;= 1000</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "binary_search"]}, {"location": "notes/Leetcode%20100-1000/274.%20H-Index/#solve", "title": "Solve", "text": "<p>O(n log n) because of sort. Count sort could make this better - Using binary search knowing that \u201cat least <code>h</code> papers that have each been cited at least <code>h</code> times.\u201d Which mean, finding the starting point where <code>citations[m] &gt;= n-m</code></p> <pre><code>class Solution:\ndef hIndex(self, citations: List[int]) -&gt; int:\ncitations.sort()\nn = len(citations)\nl = -1\nr = n\nwhile True:\nm = (l + r) // 2\nif l == m:\nbreak\nif citations[m] &gt;= n-m:\nr = m\nelse:\nl = m\nreturn n-r\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "array", "binary_search"]}, {"location": "notes/Leetcode%20100-1000/283.%20Move%20Zeroes/", "title": "283. Move Zeroes", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/283.%20Move%20Zeroes/#problem", "title": "Problem", "text": "<p>Given an integer array <code>nums</code>, move all <code>0</code>\u2019s to the end of it while maintaining the relative order of the non-zero elements.</p> <p>Note that you must do this in-place without making a copy of the array.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10**4</code></li> <li><code>-2**31 &lt;= nums[i] &lt;= 2**31 - 1</code></li> </ul> <p>Example 1: <pre><code>**Input:** nums = [0,1,0,3,12]\n**Output:** [1,3,12,0,0]\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/283.%20Move%20Zeroes/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/283.%20Move%20Zeroes/#bubble-sort", "title": "Bubble Sort", "text": "<ul> <li><code>-2**31 &lt;= nums[i] &lt;= 2**31 - 1</code> so we not want to count that much, even of you want to, consider using a <code>dict()</code> hash map</li> <li>Quite simple problem, but they want you to keeping <code>nums</code> in-place which causing some trouble as we dealing with python array (Which is way more than just a normal array)</li> </ul> <p>Here i using bubble sort to push all <code>0</code> number to the end, which is a <code>O(n**2)</code> time complexity function</p> <pre><code>class Solution:\ndef moveZeroes(self, nums: List[int]) -&gt; None:\nfor i in range(len(nums)):\nfor j in range(len(nums)-i-1):\nif nums[j] == 0:\nnums[j], nums[j+1] = nums[j+1], nums[j]\nreturn nums\n</code></pre> <pre><code>void moveZeroes(int* nums, int numsSize){\nfor (int i = 0; i &lt; numsSize; i++) {\nfor (int j = 0; j &lt; numsSize - i - 1; j++) {\nif (nums[j] == 0) {\nint temp = nums[j];\nnums[j] = nums[j + 1];\nnums[j + 1] = temp;\n}\n}\n}\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/283.%20Move%20Zeroes/#just-sort-it", "title": "Just sort it", "text": "<p>Change all number 0 value to max number, sort it, using temp array to store processing data, update the <code>nums</code> array to match with processed result. </p> <pre><code>class Solution:\ndef moveZeroes(self, nums: List[int]) -&gt; None:\nkey = [len(nums)+1] * len(nums)\nindex = 0\nfor i, v in enumerate(nums):\nif v != 0:\nkey[index] = i\nindex += 1\nkey.sort()\ntmp = [0] * len(nums)\nfor i, k in enumerate(key):\nif k &gt;= len(nums):\nbreak\ntmp[i] = nums[k]\nfor i, v in enumerate(tmp):\nnums[i] = v\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/283.%20Move%20Zeroes/#not-even-sorting", "title": "Not even sorting", "text": "<p>Create a temp table. Loop through all available number and if it not <code>0</code> push to <code>tmp</code> array one by one</p> <pre><code>class Solution:\ndef moveZeroes(self, nums: List[int]) -&gt; None:\ntmp = [0] * len(nums)\nindex = 0\nfor v in nums:\nif v != 0:\ntmp[index] = v\nindex += 1\nfor i, v in enumerate(tmp):\nnums[i] = v\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/326.%20Power%20of%20Three/", "title": "326. Power of Three", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/326.%20Power%20of%20Three/#problem", "title": "Problem", "text": "<p>Given an integer <code>n</code>, return <code>true</code> if it is a power of three. Otherwise, return <code>false</code>.</p> <p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3x</code>.</p> <p>Constraints:</p> <ul> <li><code>-231 &lt;= n &lt;= 231 - 1</code></li> </ul> <p>Example 1: <pre><code>**Input:** n = 27\n**Output:** true\n**Explanation:** 27 = 33\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/326.%20Power%20of%20Three/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/326.%20Power%20of%20Three/#actually-using-a-computer-to-compute", "title": "Actually using a computer to compute", "text": "<p>We can use <code>math</code> to do it. Which is trying to check if <code>n = 3**x</code>  =&gt; <code>x = log_3(n)</code></p> <p>Need to consider some off by 1 changing between integer and float using <code>trunc</code> because of floating point error</p> <pre><code>class Solution:\ndef isPowerOfThree(self, n: int) -&gt; bool:\nif n &lt;= 0:\nreturn False\nm = trunc(log(n,3))\nreturn 3**m == n or 3**(m+1) == n\n</code></pre> <p>or equal c code <pre><code>bool isPowerOfThree(int n){\nif (n &lt;= 0) {\nreturn false;\n}\nint m = (int)trunc(log(n) / log(3));\nreturn pow(3, m) == n || pow(3, m + 1) == n;\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/326.%20Power%20of%20Three/#counting-with-loop", "title": "Counting with loop", "text": "<p>Looping until n == 0:</p> <ul> <li>Check <code>n mod 3 == 0</code>, if not return False</li> <li>Update <code>n = n div 3</code></li> </ul> <p>This to make sure we find  <code>n = 3 * 3 * 3 ...</code> (k times), count the process and we can return the final <code>k</code> count number.</p> <pre><code>bool isPowerOfThree(int n){\nif (n == 0)\nreturn false;\nwhile (n != 1)\n{\nif (n % 3 != 0)\nreturn false;\nn = n / 3;\n}\nreturn true;\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/344.%20Reverse%20String/", "title": "344. Reverse String", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/344.%20Reverse%20String/#problem", "title": "Problem", "text": "<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p> <p>You must do this by modifying the input array in-place with <code>O(1)</code> extra memory.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 105</code></li> <li><code>s[i]</code> is a printable ascii character.</li> </ul> <p>Example 1: <pre><code>**Input:** s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n**Output:** [\"o\",\"l\",\"l\",\"e\",\"h\"]\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/344.%20Reverse%20String/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/344.%20Reverse%20String/#create-temporarystored-memory", "title": "Create temporary/stored memory", "text": "<p>Create <code>tmp</code> string, process to reversed it\u2019s order,  and re-update s after</p> <pre><code>class Solution:\ndef reverseString(self, s: List[str]) -&gt; None:\n\"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\ntmp = s[::-1]\nfor i,c in enumerate(tmp):\ns[i] = c\nreturn s\n</code></pre> <p>equal c code <pre><code>void reverseString(char* s, int sSize){\nchar* tmp = (char*)malloc(sSize * sizeof(char));\nfor (int i = 0; i &lt; sSize; i++) {\ntmp[i] = s[sSize - i - 1];\n}\nfor (int i = 0; i &lt; sSize; i++) {\ns[i] = tmp[i];\n}\nfree(tmp);\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/344.%20Reverse%20String/#reverse-in-place", "title": "Reverse in-place", "text": "<p>We can start from both of the start and the end of string. Swap them, go to the next pair and stop at the middle of the string</p> <pre><code>class Solution(object):\ndef reverseString(self, s):\nfor i in range(len(s)//2):\ns[i], s[len(s) -1 - i] = s[len(s) -1 - i], s[i]\n</code></pre> <p>equal c code <pre><code>void reverseString(char* s, int sSize){\nif (sSize == 0){\nreturn;\n}\nfor (int i = 0 ; i &lt; sSize/2 ; i++){\nchar tmp = s[i];\ns[i] = s[sSize-1-i];\ns[sSize-1-i] = tmp;\n}\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/350.%20Intersection%20of%20Two%20Arrays%20II/", "title": "350. Intersection of Two Arrays II", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/350.%20Intersection%20of%20Two%20Arrays%20II/#problem", "title": "Problem", "text": "<p>Given two integer arrays <code>nums1</code> and <code>nums2</code>, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li> <li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li> </ul> <p>Example 1: <pre><code>**Input:** nums1 = [1,2,2,1], nums2 = [2,2]\n**Output:** [2,2]\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/350.%20Intersection%20of%20Two%20Arrays%20II/#solve", "title": "Solve", "text": "<p>I do exactly this:</p> <ul> <li>Count all number of both array</li> <li>Find intersect number value (don\u2019t care about duplicate)</li> <li>Rebuild result array using needed information: <code>&lt;Total time appear both nums&gt; * [value]</code></li> </ul> <pre><code>class Solution(object):\ndef intersect(self, nums1, nums2):\ninterset = set(nums1).intersection(set(nums2))\ncount = {}\nfor i in nums1:\nif i not in count:\ncount[i] = [0, 0]\ncount[i][0] += 1\nfor i in nums2:\nif i not in count:\ncount[i] = [0, 0]\ncount[i][1] += 1\nresult = []\nfor key in interset:\nresult += min(count[key])* [key]\nreturn result\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/350.%20Intersection%20of%20Two%20Arrays%20II/#counting-using-a-large-predefined-array", "title": "Counting, using a large predefined array", "text": "<p>I need more time to done the same with C, as C not have good hash map for set() available from the language standard library at all, we using fully the provided Constant:</p> <ul> <li>Count all the number appear on <code>nums1</code> and <code>nums2</code>, storing in a predefined array that cover all possible number. Which is  <code>[0..1000]</code>(as <code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code>)</li> <li>Build up the intersection by going through all possible number, by using the same logic:<ul> <li>If our current number <code>i</code> appear on both, adding that <code>i</code> to the  <code>intersectArr</code> for the total <code>occur = min(count1[i], count2[i])</code> times</li> <li>If it not appear <code>occur = 0</code>, go to the next number</li> </ul> </li> </ul> <p>Now to the \u201cslow\u201d part, why it slow? Because I need to check:</p> <ul> <li>The return type is <code>int*</code>, which is a persistence memory in heap, while our <code>intersectArr</code> is allocating inside a C local function scope, which being clear/disappear after going back to main function. So, we need to <code>malloc</code> new memory and transfer <code>intersectArr</code> over one by one. </li> <li>The <code>int* returnSize</code>, this is where we have to return the length or our <code>result</code>. It quite confusion as <code>returnSize</code> is a pointer (which why using <code>printf(\"%d\", returnSize)</code> output some thing like <code>91267892</code>). We need to know syntax to correctly pass the required value to  <code>returnSize</code>, which is <code>*returnSize = intersectArrLen</code>.</li> </ul> <pre><code>/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\nint* result;\nint count1[1005] = {0};\nint count2[1005] = {0};\nint intersectArr[1005] = {0};\nint intersectArrLen = 0;\nint occur = 0;\nfor (int i = 0; i &lt; nums1Size; i++) count1[nums1[i]] ++;\nfor (int i = 0; i &lt; nums2Size; i++) count2[nums2[i]] ++;\nfor (int i = 0; i &lt; 1001; i++){\noccur = count1[i];\nif (count1[i] &gt; count2[i]) occur = count2[i];\nfor (int _j = 0; _j &lt; occur; _j ++) {\nintersectArr[intersectArrLen] = i;\nintersectArrLen ++;\n}\n}\nresult = (int*)malloc(intersectArrLen * sizeof(int));\nfor (int i = 0; i &lt; intersectArrLen; i++){\nresult[i] = intersectArr[i];\n}\n*returnSize = intersectArrLen;\nreturn result;\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/", "title": "373. Find K Pairs with Smallest Sums", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#problem", "title": "Problem", "text": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> sorted in ascending order and an integer <code>k</code>.</p> <p>Define a pair <code>(u, v)</code> which consists of one element from the first array and one element from the second array.</p> <p>Return the <code>k</code> pairs <code>(u1, v1), (u2, v2), ..., (uk, vk)</code> with the smallest sums.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums1.length, nums2.length &lt;= 10**5</code></li> <li><code>-10**9 &lt;= nums1[i], nums2[i] &lt;= 10**9</code></li> <li><code>nums1</code> and <code>nums2</code> both are sorted in ascending order.</li> <li><code>1 &lt;= k &lt;= 10**4</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#first-look", "title": "First look", "text": "<ol> <li>You want to get minimal value: Which could be heap, sorting, min binary tree, </li> <li>We don\u2019t care about the duplicate or position so we could go for: heap, sorting</li> <li>Sorting give overall better performance, as the <code>nums_1</code> and <code>nums_2</code> is already sorted in ascending order. By define, sum of a pair number <code>(x1,y1)</code> will be less than <code>(x2,y2)</code> if <code>x1.index &lt;= x2.index</code> and <code>y1.index &lt;= y2.index</code> (<code>x in nums_1</code>, <code>y in nums_2</code>)</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#1-quick-first-thought", "title": "1. Quick first thought", "text": "<ol> <li>Create a pointer <code>p</code> for each <code>num_arr</code> , index from <code>0</code>, we calling their created pair<code>(p1, p2)</code> which start at  <code>(0,0)</code></li> <li>Loop k times, push pair <code>(p1, p2)</code> into result <code>arr</code> and increase either <code>p1</code> or <code>p2</code> (base on value of <code>nums_1[p1]</code> and <code>nums_2[p2]</code>)</li> <li>Return created <code>arr</code></li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#2-wow-that-wrong", "title": "2. Wow, that wrong", "text": "<ol> <li>The first one don\u2019t reuse index after <code>p1</code> and <code>p2</code> already passing it, so we can\u2019t detect answer that use the <code>index</code> back to back</li> <li>Quick fix is running a max cap of <code>p1</code> and <code>p2</code>, if we reach and break the max cap, we can reuse all element that in the range of either <code>[0..p1]</code> or <code>[0..p2]</code> </li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#3-heap-attempt-update-the-pointer-case", "title": "3. Heap attempt, update the pointer case", "text": "<p>Seem like heap still coming back, as rerunning and pointer can\u2019t handle all case where we actually need to consider the sum of pair <code>(p1,p2)</code></p> <ol> <li>Quickly add all available pair create by <code>nums1</code> and <code>nums2</code> into each correspond separated heap, every heap element is a pair <code>(p1, p2)</code> with priority value of <code>sum = nums1[p1] + nums2[p2]</code> </li> <li>Update: Every element <code>p1</code> of <code>nums1</code> will be pair with the lowest available <code>p2</code> of <code>nums2</code> ; After append to the result; we will increase <code>p2</code> to make the new pair from <code>p1</code> and push it back to heap  </li> <li>Run in a loop until we get <code>k</code> element in the result <code>arr</code>; We use a <code>set()</code> hash map to handle with the duplication</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#implement", "title": "Implement", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#1-first-implement", "title": "1. First implement", "text": "<p>Quick and easy, follow first thought process <pre><code>class Solution:\ndef kSmallestPairs(self,\nnums1: List[int],\nnums2: List[int],\nk: int) -&gt; List[List[int]]:\np1, p2 = 0, 0\narr = []\nfor _ in range(k):\narr.append([nums1[p1], nums2[p2]])\nif not p1 + 1 &lt; len(nums1) and not p2 + 1 &lt; len(nums2):\nbreak\nif not p1 + 1 &lt; len(nums1):\np2 += 1\ncontinue\nif not p2+1 &lt; len(nums2):\np1 += 1\ncontinue\nif nums1[p1+1] &gt; nums2[p2+1]:\np2 += 1\nelse:\np1 += 1\nreturn arr\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#2-second-attempt", "title": "2. Second attempt", "text": "<p>After seeing the problem that come with reusing number <pre><code>class Solution:\ndef kSmallestPairs(self,\nnums1: List[int],\nnums2: List[int],\nk: int) -&gt; List[List[int]]:\np1, p2 = 0, 0\nmax_p1, max_p2 = p1, p2\narr = []\nfor _ in range(k):\narr.append([nums1[p1], nums2[p2]])\nif not p1 + 1 &lt; len(nums1) and not p2 + 1 &lt; len(nums2):\nbreak\nif not p1 + 1 &lt; len(nums1):\np2 += 1\nif p2 &gt; max_p2:\nmax_p2 = p2\np1 = 0\ncontinue\nif not p2+1 &lt; len(nums2):\np1 += 1\nif p1 &gt; max_p1:\nmax_p1 = p1\np2 = 0\ncontinue\nif nums1[p1+1] &gt; nums2[p2+1]:\np2 += 1\nif p2 &gt; max_p2:\nmax_p2 = p2\np1 = 0\nelse:\np1 += 1\nif p1 &gt; max_p1:\nmax_p1 = p1\np2 = 0\nreturn arr\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#3-heap-attempt", "title": "3. Heap attempt", "text": "<ul> <li>Running pointer for every element of both <code>nums1</code> and <code>nums2</code> instead</li> <li>If we add a <code>(pos1, pos2)</code> pair into result <code>arr</code>; Try increase the correspond pointer, and push newly created pair either <code>(pos1 +1, pos2)</code> or <code>(pos1 , pos2+1)</code> to possible answer.</li> <li>Handle the find minimal answer by using <code>heap</code></li> <li>Handle possible duplication by using a <code>set()</code> hash map</li> </ul> <pre><code>class Solution:\ndef kSmallestPairs(self,\nnums1: List[int],\nnums2: List[int],\nk: int) -&gt; List[List[int]]:\ntrace = set()\np1 = [(value + nums2[0], (index, 0))\nfor index, value in enumerate(nums1)]\np2 = [(value + nums1[0], (0, index))\nfor index, value in enumerate(nums2)]\nheapq.heapify(p1)\nheapq.heapify(p2)\narr = []\nfor _ in range(k*len(nums1)*len(nums2)):\nif len(trace) == k:\nbreak\nif len(p1) == len(p2) == 0:\nbreak\nneedPopP1 = False\nif len(p1) == 0:\nneedPopP1 = False\nelif len(p2) == 0:\nneedPopP1 = True\nelse:\nv1, (_, _) = p1[0]\nv2, (_, _) = p2[0]\nneedPopP1 = v1 &lt;= v2\nif needPopP1:\n_, (pos1, pos2) = heapq.heappop(p1)\nif (pos1, pos2) not in trace:\narr.append([nums1[pos1], nums2[pos2]])\ntrace.add((pos1, pos2))\nif pos2+1 &lt; len(nums2):\nheapq.heappush(\np1, (nums1[pos1] + nums2[pos2+1], (pos1, pos2+1)))\nelse:\n_, (pos1, pos2) = heapq.heappop(p2)\nif (pos1, pos2) not in trace:\narr.append([nums1[pos1], nums2[pos2]])\ntrace.add((pos1, pos2))\nif pos1+1 &lt; len(nums1):\nheapq.heappush(\np2, (nums1[pos1+1] + nums2[pos2], (pos1+1, pos2)))\nreturn arr\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#4-final-refactor", "title": "4. Final refactor", "text": "<ul> <li>The <code>heap</code> for <code>nums2</code> isn\u2019t necessary, we only need allocate pointer for every element of either  <code>nums1</code> or <code>nums2</code> (This implement using <code>nums1</code>)</li> <li>Also, this implementation won\u2019t have duplicate value, so <code>set()</code> hash map isn\u2019t necessary</li> </ul> <pre><code>class Solution:\ndef kSmallestPairs(self,\nnums1: List[int],\nnums2: List[int],\nk: int) -&gt; List[List[int]]:\np1 = [(value + nums2[0], (index, 0))\nfor index, value in enumerate(nums1)]\nheapq.heapify(p1)\narr = []\nfor _ in range(k):\nif len(arr) == k:\nbreak\nif len(p1) == 0:\nbreak\n_, (pos1, pos2) = heapq.heappop(p1)\narr.append([nums1[pos1], nums2[pos2]])\nif pos2+1 &lt; len(nums2):\nheapq.heappush(\np1, (nums1[pos1] + nums2[pos2+1], (pos1, pos2+1)))\nreturn arr\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/373.%20Find%20K%20Pairs%20with%20Smallest%20Sums/#complexity", "title": "Complexity", "text": "<ul> <li>Time <code>O( k * log(len(nums1)) )</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/380.%20Insert%20Delete%20GetRandom%20O%281%29/", "title": "380. Insert Delete GetRandom O(1)", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/380.%20Insert%20Delete%20GetRandom%20O%281%29/#problem", "title": "Problem", "text": "<p>Implement the <code>RandomizedSet</code> class:</p> <ul> <li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li> <li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li> <li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li> <li><code>int getRandom()</code> Returns a random element from the current set of elements (it\u2019s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.</li> </ul> <p>You must implement the functions of the class such that each function works in average <code>O(1)</code> time complexity.</p> <p>Example 1: <pre><code>**Input**\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], [|], [1], [2], [2], [], [1], [2], []]\n**Output**\n[null, true, false, true, 2, true, false, 2]\n</code></pre> Explanation <pre><code>RandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n</code></pre> Constraints:</p> <ul> <li><code>-2**31 &lt;= val &lt;= 2**31 - 1</code></li> <li>At most <code>2 *</code> <code>10**5</code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li> <li>There will be at least one element in the data structure when <code>getRandom</code> is called.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/380.%20Insert%20Delete%20GetRandom%20O%281%29/#solve", "title": "Solve", "text": "<pre><code>class RandomizedSet:\ndef __init__(self):\nself.a = set()\ndef insert(self, val: int) -&gt; bool:\nif val in self.a:\nreturn False\nself.a.add(val)\nreturn True\ndef remove(self, val: int) -&gt; bool:\nif val not in self.a:\nreturn False\nself.a.remove(val)\nreturn True\ndef getRandom(self) -&gt; int:\nreturn list(self.a)[randrange(0,len(self.a))]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/387.%20First%20Unique%20Character%20in%20a%20String/", "title": "387. First Unique Character in a String", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/387.%20First%20Unique%20Character%20in%20a%20String/#problem", "title": "Problem", "text": "<p>Given a string <code>s</code>, find the first non-repeating character in it and return its index. If it does not exist, return <code>-1</code>.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/387.%20First%20Unique%20Character%20in%20a%20String/#solve", "title": "Solve", "text": "<pre><code>class Solution(object):\ndef firstUniqChar(self, s):\ncount = {}\npos = {}\nfor i, c in enumerate(s):\nif c not in count:\ncount[c] = 0\npos[c] = i\ncount[c] += 1\npossible = []\nfor k in count:\nif count[k] == 1:\npossible.append(pos[k])\nif len(possible) == 0:\nreturn -1\nreturn min(possible)``\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/412.%20Fizz%20Buzz/", "title": "412. Fizz Buzz", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/412.%20Fizz%20Buzz/#problem", "title": "Problem", "text": "<p>Given an integer <code>n</code>, return a string array <code>answer</code> (1-indexed) where:</p> <ul> <li><code>answer[i] == \"FizzBuzz\"</code> if <code>i</code> is divisible by <code>3</code> and <code>5</code>.</li> <li><code>answer[i] == \"Fizz\"</code> if <code>i</code> is divisible by <code>3</code>.</li> <li><code>answer[i] == \"Buzz\"</code> if <code>i</code> is divisible by <code>5</code>.</li> <li><code>answer[i] == i</code> (as a string) if none of the above conditions are true.</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 104</code></li> </ul> <p>Example 1:</p> <pre><code>**Input:** n = 3\n**Output:** [\"1\",\"2\",\"Fizz\"]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/412.%20Fizz%20Buzz/#solve", "title": "Solve", "text": "<pre><code>class Solution(object):\ndef fizzBuzz(self, n):\nans = []\nfor i in range(1,n+1):\nif i % 3 == i % 5 == 0:\nans += [\"FizzBuzz\"]\nelif i % 3 == 0:\nans += [\"Fizz\"]\nelif i % 5 == 0:\nans += [\"Buzz\"]\nelse:\nans += [str(i)]\nreturn ans\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/435.%20Non-overlapping%20Intervals/", "title": "435. Non overlapping Intervals", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/435.%20Non-overlapping%20Intervals/#problem", "title": "Problem", "text": "<p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= intervals.length &lt;= 105</code></li> <li><code>intervals[i].length == 2</code></li> <li><code>-5 * 104 &lt;= starti &lt; endi &lt;= 5 * 104</code></li> </ul> <p>Example 1: <pre><code>**Input:** intervals = [[1,2],[2,3],[3,4],[1,3|1,2],[2,3],[3,4],[1,3]]\n**Output:** 1\n**Explanation:** [1,3] can be removed and the rest of the intervals are non-overlapping.\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/435.%20Non-overlapping%20Intervals/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/435.%20Non-overlapping%20Intervals/#bottom-up-dynamic-programming", "title": "Bottom-up dynamic programming", "text": "<p>Dynamic problem, which is a lot similar to 2008. Maximum Earnings From Taxi, 1751. Maximum Number of Events That Can Be Attended II, we try to minimize the value of total element you want to remove.</p> <p>This is bottom-up approach, where we focus on solve and building necessary all lower information first :</p> <ul> <li>Sort all intervals by end value, this to ensure when we calculate result of a interval <code>[s_i, e_i]</code>, we can already get the best result from range <code>[...e_i-1]</code>.</li> <li>Try to find the best result <code>cacheResult[i]</code> on each step <code>[s_i, e_i]</code>, either:<ul> <li>Case 1: Remove our current interval, meaning <code>cacheResult[e_i] = cacheResult[e_i-1] +1</code></li> <li>Case 2: Use our current interval, meaning <code>cacheResult[e_i] = cacheResult[s_i-1] + &lt;total_of_interval_between_s_i_and_e_i&gt;</code></li> </ul> </li> <li>To do this, I keeping track of already processed <code>interval</code> in <code>cacheKey</code> array, while <code>cacheResult</code> keeping the best result of our current set interval of <code>cacheKey</code>, adding them key by key.<ul> <li>The expression of above Case 1, and Case 2 replace by calculating using <code>index</code> of current processed interval and <code>key</code> value in  <code>cacheKey</code> array.</li> <li><code>bisect_right</code> here is a perform a literal binary searching on already sorted array <code>cacheKey</code> (by default, as we already sort the <code>intervals</code> by end value), which get the <code>closest</code> index where <code>key[closest-1] &lt;= value &lt; key[closest]</code>. Here I need to check some Off by one error to find the exact equivalence.</li> </ul> </li> </ul> <pre><code>class Solution:\ndef eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:\ndef getEnds(interval):\nreturn interval[1]\nintervals.sort(key = getEnds)\ncacheResult = []\ncacheKey = []\nfor i, (s, e) in enumerate(intervals):\ncacheKey.append(e)\nif i == 0:\ncacheResult[0] = 0\ncontinue\nclosest = bisect_right(cacheKey, s) - 1\ncacheResult.append(cacheResult[i-1] + 1)\nif closest &gt;= 0:\ncacheResult[i] = min(cacheResult[i], cacheResult[closest] + i - closest -1)\nreturn cacheResult[len(intervals) -1]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/435.%20Non-overlapping%20Intervals/#greedy", "title": "Greedy", "text": "<p>There isn\u2019t a need of caching the result, as all value with the interval with start <code>s_i</code> come before last end <code>e_(i-1)</code> is an overlap and need to be remove. These isn\u2019t any better case at all. So we can remove them, directly increase our result by  <code>1</code></p> <ul> <li>Still sort every intervals by end value</li> <li>If start <code>s_i</code> overlap last <code>[...last_end]</code>, consider we remove this interval, <code>ans = ans + 1</code>, <code>last_end</code> is un-change as we not adding this interval in to result.  </li> <li>If start <code>s_i</code> not overlap, consider adding this current interval into our result and update the <code>last_end</code> value</li> </ul> <p>Here is provided Answer from Leetcode <pre><code>class Solution:\ndef eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:\nintervals.sort(key = lambda x: x[1])\nans = 0\nk = -inf\nfor x, y in intervals:\nif x &gt;= k:\n# Case 1\nk = y\nelse:\n# Case 2\nans += 1\nreturn ans\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/445.%20Add%20Two%20Numbers%20II/", "title": "445. Add Two Numbers II", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/445.%20Add%20Two%20Numbers%20II/#problem", "title": "Problem", "text": "<p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p> <p>Constraints:</p> <ul> <li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 9</code></li> <li>It is guaranteed that the list represents a number that does not have leading zeros.</li> </ul> <p>Follow up: Could you solve it without reversing the input lists?</p> <p>Example 1:</p> <p></p> <pre><code>**Input:** l1 = [7,2,4,3], l2 = [5,6,4]\n**Output:** [7,8,0,7]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/445.%20Add%20Two%20Numbers%20II/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/445.%20Add%20Two%20Numbers%20II/#remove-link-list", "title": "Remove link-list", "text": "<p>Quick and fast solution is removing list link, as python handle the big integer by default (standard library) and way faster than loop through the linked list</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/445.%20Add%20Two%20Numbers%20II/#definition-for-singly-linked-list-class-listnode-def-__init__self-val0-nextnone-selfval-val-selfnext-next-class-solution-def-addtwonumbersself-l1-optionallistnode-l2-optionallistnode-optionallistnode-n-0-p-l1-while-p-n-10-n-pval-p-pnext-m-0-q-l2-while-q-m-10-m-qval-q-qnext-result-n-m-if-result-0-return-listnode0-head-none-while-result-0-head-listnoderesult10-head-result-10-return-head", "title": "<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        n = 0\n        p = l1\n        while p:\n            n *= 10\n            n += p.val\n            p = p.next\n        m = 0\n\n        q = l2\n        while q:\n            m *= 10\n            m += q.val\n            q = q.next\n\n        result = n + m\n        if result == 0:\n            return ListNode(0)\n\n        head = None\n        while result &gt; 0:\n            head = ListNode(result%10, head)\n            result //= 10\n        return head\n</code></pre>", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/445.%20Add%20Two%20Numbers%20II/#forcing-to-use-the-linked-list", "title": "Forcing to use the linked list?", "text": "<p>While there is no reason to do so (in Python). We can still do it for some challenge, using linked list as a big number handling. </p> <p>Still, the provided input isn\u2019t the best way to implement big number, here should be an ideal one: <pre><code>class BigNumber:\ndef __init__(self):\nself.head = None\nself.end = None\ndef toListNode(self):\nresult = ListNode()\np = self \nwhile p:\nresult = ListNode(p.val, result)\np = p.next\nreturn self.end\ndef add_number(self, val):\nif self.head is None:\nself.head = self.end = ListNode(val)\nreturn\nself.end.next = ListNode(val)\nself.end = self.end.next\ndef add(self, otherBigNumber):\nresult = BigNumber()\np, q = self.end, otherBigNumber.end\ncarry = 0\nwhile p or q:\nval_1, val_2 = 0, 0\nif p:\nval_1 = p.val\np = p.next\nif q:\nval_2 = q.val\nq = q.next\nresult.add_number((val_1 + val_2 + carry) % 10)\ncarry = (val_1 + val_2 + carry) // 10\nif carry:\nresult.add_number(carry)\n</code></pre></p> <p>Class <code>BigNumber</code> is the implementation for O(1) insert, O(n) adding time complexity, where: </p> <ul> <li>The number representation in revert order: Number <code>123459</code> will be storing as <code>9 -&gt; 5 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1</code> . Which helping <code>add</code> function which also done in revert order.</li> <li>To change the input to our crafted class, I create a <code>Helper</code> function to revert the order of Linked List <code>ListNode</code> and return correspond <code>BigNumber</code> </li> </ul> <p>Here is final implementation <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass BigNumber:\ndef __init__(self):\nself.head = None\nself.end = None\ndef add_number(self, val):\nif self.head is None:\nself.head = self.end = ListNode(val)\nreturn\nself.end.next = ListNode(val)\nself.end = self.end.next\ndef toListNode(self):\nresult = None\np = self.head\nwhile p:\nresult = ListNode(p.val, result)\np = p.next\nreturn result\ndef add(self, otherBigNumber):\nresult = BigNumber()\np, q = self.head, otherBigNumber.head\ncarry = 0\nwhile p or q:\nval_1, val_2 = 0, 0\nif p:\nval_1 = p.val\np = p.next\nif q:\nval_2 = q.val\nq = q.next\nresult.add_number((val_1 + val_2 + carry) % 10)\ncarry = (val_1 + val_2 + carry) // 10\nif carry:\nresult.add_number(carry)\nreturn result\nclass Solution:\ndef addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\ndef helper(p):\nresult = None\nif p is None:\nresult = BigNumber()\nelse:\nresult = helper(p.next)\nresult.add_number(p.val)\nreturn result\nreturn helper(l1).add(helper(l2)).toListNode()\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/445.%20Add%20Two%20Numbers%20II/#comparing", "title": "Comparing", "text": "<p>Just don\u2019t. It a basic to handle number operation in most of non support language. Most of the time you will want to use close to minimalism library or OS/Hardware standard (example https://gmplib.org/).</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/", "title": "518. Coin Change II", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#problem", "title": "Problem", "text": "<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p> <p>Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p> <p>You may assume that you have an infinite number of each kind of coin.</p> <p>The answer is guaranteed to fit into a signed 32-bit integer.</p> <p>Example 1:</p> <p>Input: amount = 5, coins = [1,2,5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p> <p>Example 2:</p> <p>Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.</p> <p>Example 3:</p> <p>Input: amount = 10, coins = [10] Output: 1</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= coins.length &lt;= 300</code></li> <li><code>1 &lt;= coins[i] &lt;= 5000</code></li> <li>All the values of <code>coins</code> are unique.</li> <li><code>0 &lt;= amount &lt;= 5000</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#dynamic-programming", "title": "Dynamic programming", "text": "<p>The ideal start with a update function: <pre><code>stage_a + coin_value -&gt; stage_b = stage_&lt;a+ coin_value&gt;\n</code></pre></p> <p>Which lead to: <pre><code>total_way_of_stage_b = total_way_of_stage_a (with coin_value) + &lt;other_way&gt;\n</code></pre></p> <p>With every coins, we loop and adding up the total way to reach each amount. <pre><code>class Solution {\npublic int change(int amount, int[] coins) {\nint[] count = new int[amount + 1];\ncount[0] = 1;\nfor (int i : coins) {\nfor (int c = i; c &lt;= amount; c++) {\ncount[c] += count[c-i];\n}\n}\nreturn count[amount];\n}\n}\n</code></pre></p> <p>The for loop odder have an impact on how the Calculation run:</p> <p>If you instead doing this: <pre><code>for (int c = 0; c &lt;= amount; c++) {\nfor (int i : coins) {\nif (c-i &gt; 0) count[c] += count[c-i];\n}\n}\n</code></pre></p> <ul> <li>We have total of way adding coin (that count with all possible different position <code>1 2 1 != 1 1 2</code>) to reach that amount</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#comparing", "title": "Comparing", "text": "<p>I also try some more language to help me familiar with other language array too, it quite surprise to see rust and java beat c in runtime.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#java", "title": "<code>java</code>:", "text": "<p>We have <code>int</code> array automate initiation as 0</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#c", "title": "<code>c</code>:", "text": "<p>It keep yelling me about how I can\u2019t using <code>int count[amount+1] = {0}</code>; This just mean I have to use a hard code value to use this feature of the language. <pre><code>#define MAX_AMOUNT 5001\nint count[MAX_AMOUNT] = {0};\n</code></pre></p> <p>To initiation use a variable size, we instead use <code>memset</code>. Also, C not have <code>for each</code> built-in the language syntax, so I use a normal iterator loop <pre><code>int change(int amount, int* coins, int coinsSize){\nint count[amount + 1];\nmemset(count, 0, sizeof(count));  count[0] = 1;\nfor (int i = 0; i &lt; coinsSize; i++) {\nfor (int c = coins[i]; c &lt;= amount; c++) {\ncount[c] += count[c-coins[i]];\n}\n}\nreturn count[amount];\n}\n</code></pre></p> <p>For an un-know reason, but it c quite slow some time when I try to submit result.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#python3", "title": "<code>python3</code>:", "text": "<p>I can\u2019t seem to know better way to initiation a array in python. Also, I use python to make my first implementation, planning process.</p> <pre><code>class Solution:\ndef change(self, amount: int, coins: List[int]) -&gt; int:\ncount = [0] * (amount + 1)\ncount[0] = 1\nfor i in coins:\nfor c in range(amount+1):\nif c-i &lt; 0:\ncontinue\ncount[c] += count[c-i]\nreturn count[amount]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#rust", "title": "<code>rust</code>:", "text": "<p>While rust have some more similar way to create array like <code>c</code>, it require the variable to be constant example.  <pre><code>const MAX_AMOUNT: usize = 5000;\nlet mut count = [0; MAX_AMOUNT];\n</code></pre></p> <ul> <li>To create and allocation array, using dynamic size variable, we have to use <code>vec!</code> </li> </ul> <pre><code>impl Solution {\npub fn change(amount: i32, coins: Vec&lt;i32&gt;) -&gt; i32 {\nlet mut count = vec![0; (amount + 1) as usize];\ncount[0] = 1;\nfor coin in coins {\nfor c in coin..=amount {\ncount[c as usize] += count[(c - coin) as usize];\n}\n}\ncount[amount as usize]\n}\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/518.%20Coin%20Change%20II/#time-and-memory-for-comparation", "title": "Time and memory for comparation:", "text": "Time Submitted Status Runtime Memory Language 08/11/2023 17:30 Accepted 3 ms 5.6 MB c 08/11/2023 15:39 Accepted 2 ms 2.1 MB rust 08/11/2023 15:17 Accepted 2 ms 40.1 MB java 08/11/2023 15:09 Accepted 5 ms 5.7 MB c 08/11/2023 09:49 Accepted 194 ms 16.6 MB python3", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/", "title": "530. Minimum Absolute Difference in BST", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#problem", "title": "Problem", "text": "<p>Given the <code>root</code> of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.</p> <p>Example 1:</p> <p></p> <p>Input: root = [4,2,6,1,3] Output: 1</p> <p>Example 2:</p> <p></p> <p>Input: root = [1,0,48,null,null,12,49] Output: 1</p> <p>Constraints:</p> <ul> <li>The number of nodes in the tree is in the range <code>[2, 104]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 105</code></li> </ul> <p>Note: This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#solution", "title": "Solution", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#my-sane-approach", "title": "My sane approach", "text": "<p>BTS is a searching Tree, and it cost O(log n) time to find any target value I using a try and error, where with each node, I make an assumption that:</p> <ul> <li><code>root</code> node is one of the two different nodes that we need to find to <code>getMinimumDifference</code></li> <li>To get the minimum different node pair knowing <code>(root, &lt;unknow&gt;)</code> , </li> <li>I will loop trough every node in the tree, find  <pre><code>class Solution: \ndef getLargest(self, root):\np = root\nwhile p.right:\np = p.right\nreturn p\ndef getSmallest(self, root):\np = root\nwhile p.left:\np = p.left\nreturn p\ndef getValueDiff(self, x, y):\nreturn abs(x.val - y.val)\ndef getMin(self, array):\nminValue = None\nfor val in array:\nif val == None:\ncontinue    \nif minValue == None:\nminValue = val\nif minValue &gt; val:\nminValue = val\nreturn minValue\ndef getMinimumDifference(self, root: Optional[TreeNode]) -&gt; int:\nminDiff = None\np = root\nif p.left:\nminLeftDiff = self.getValueDiff(p, self.getLargest(p.left))\nminLeftChild = self.getMinimumDifference(p.left)\nminDiff = self.getMin([minDiff, minLeftDiff, minLeftChild])\nif p.right:\nminRightDiff = self.getValueDiff(p, self.getSmallest(p.right))\nminRightChild = self.getMinimumDifference(p.right)\nminDiff = self.getMin([minDiff, minRightDiff, minRightChild])\nreturn minDiff \n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#overview", "title": "Overview", "text": "<p>Given the <code>root</code> of a Binary Search Tree (BST).</p> <p>Our task is to return the minimum absolute difference between the values of any two different nodes in the tree.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#approach-1-depth-first-search", "title": "Approach 1: Depth First Search", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#intuition", "title": "Intuition", "text": "<p>Let\u2019s try to solve a simpler problem first. Given a sorted array of integers, find the minimum difference between any two integers in the array. To solve this problem, we don\u2019t need to check every pair of integers. Instead, checking the difference between every two consecutive integers would work. This is because the array is sorted. We will make use of this to solve our original problem.</p> <p>In the original problem, we have some integer values (i.e. node values), and we need to find the minimum difference between any two values. Thus, the original problem is similar to the problem we discussed above if we keep those values in the sorted order.</p> <p>To get all the node values we can use a graph traversal algorithm like depth-first search (DFS).</p> <p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring.</p> <p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the \u2018starting node\u2019 and solve the subproblem.</p> <p>If you are new to Depth First Search, please see our Leetcode Explore Card for more information on it!</p> <p>After gathering all of the node values into a list of integers, we sort the list and compare the difference between every two consecutive integers to determine the minimum difference between the values.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#algorithm", "title": "Algorithm", "text": "<ol> <li>Create a list of integers <code>nodeValues</code> to store the node values.</li> <li>Perform the DFS traversal over the given binary search tree. We call <code>dfs(root)</code> where <code>dfs</code> is a recursive method that takes <code>TreeNode node</code> as a parameter. We perform the following in this method:<ul> <li>If <code>node</code> is <code>null</code>, return.</li> <li>Add the current node\u2019s value, <code>node.val</code>, in the <code>nodeValues</code> list.</li> <li>Recursively perform DFS from <code>node.left</code>.</li> <li>Recursively perform DFS from <code>node.right</code>.</li> </ul> </li> <li>Sort the <code>nodeValues</code> list.</li> <li>Create an integer variable <code>minDifference</code> and initialize it to infinity.</li> <li>Iterate over <code>inorderNodes</code> starting from index <code>1</code>, and for each element at index <code>i</code>, find the difference with the element at index <code>i - 1</code> and update the variable <code>minDifference</code> accordingly.</li> <li>Return <code>minDifference</code>.</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#implementation", "title": "Implementation", "text": "<pre><code>class Solution:\ndef getMinimumDifference(self, root: Optional[TreeNode]) -&gt; int:\nnodeValues = []\ndef dfs(node):\nif node is None:\nreturn\nnodeValues.append(node.val)\ndfs(node.left)\ndfs(node.right)\ndfs(root)\nnodeValues.sort()\nminDifference = 1e9\nfor i in range(1, len(nodeValues)):\nminDifference = min(minDifference, nodeValues[i] - nodeValues[i-1])\nreturn minDifference\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#complexity-analysis", "title": "Complexity Analysis", "text": "<p>Here, \ufffdn is the number of nodes in the given binary search tree.</p> <ul> <li> <p>Time complexity: O(n\u22c5logn)</p> <ul> <li>We traverse once over each node of the BST using DFS traversal which takes O(n) time.</li> <li>We take O(n\u22c5logn) time to sort a list of n elements.</li> <li>We iterate over the list of size n elements to find the minimum difference which also takes O(n) time.</li> <li> <p>Space complexity: O(n)</p> </li> <li> <p>The DFS traversal is recursive and would take some space to store the stack calls. The maximum number of active stack calls at a time would be the tree\u2019s height, which in the worst case would be O(n) when the tree is a straight line.</p> </li> <li>We also need a list of size O(n) to store the values of all the nodes.</li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#approach-2-in-order-traversal-using-list", "title": "Approach 2: In-order Traversal Using List", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#intuition_1", "title": "Intuition", "text": "<p>In the previous approach, we found all the values and then sorted them. This would work for any binary tree. However, we are given a binary search tree, which we didn\u2019t take advantage of. A unique property of a binary search tree is that an inorder traversal handles the nodes in sorted order. This allows us to skip the sorting at the end.</p> <p>The in-order traversal works by visiting the left subtree of a node first, then handling the node itself and finally visiting the right subtree. Since all the nodes in the left subtree are lesser than the current node\u2019s value and all nodes in the right subtree are greater than the current node\u2019s value, it generates a sorted list of values.</p> <p>Here\u2019s a visual representation of how inorder traversal works in a BST:</p> <p></p> <p>As you can see, we continue to move towards the left node until we no longer can, then handle the current node and repeat the process with the right node as the new starting node.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#algorithm_1", "title": "Algorithm", "text": "<ol> <li>Create a list of integers <code>inorderNodes</code> to store the node values.</li> <li>Perform the inorder traversal of the binary search tree (BST). Call <code>inorderTraversal(root)</code> where <code>inorderTraversal</code> is a recursive method that takes <code>TreeNode node</code> as a parameter. We perform the following in this method:<ul> <li>If <code>node</code> is <code>null</code>, return.</li> <li>Recursively perform the in-order traversal for <code>node.left</code>.</li> <li>Add the current node\u2019s value, <code>node.val</code>, in the <code>inorderNodes</code> list.</li> <li>Recursively perform the in-order traversal for <code>node.right</code>.</li> </ul> </li> <li>Create an integer variable <code>minDifference</code> and initialize it to infinity.</li> <li>Iterate over <code>inorderNodes</code> starting from index <code>1</code>, and for each element at index <code>i</code>, find the difference with the element at index <code>i - 1</code> and update the variable <code>minDifference</code> accordingly.</li> <li>Return <code>minDifference</code>.</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#implementation_1", "title": "Implementation", "text": "<pre><code>class Solution:\ndef getMinimumDifference(self, root: Optional[TreeNode]) -&gt; int:\ninorderNodes = []\ndef inorder(node):\nif node is None:\nreturn\ninorder(node.left)\ninorderNodes.append(node.val)\ninorder(node.right)\ninorder(root)\nminDifference = 1e9\nfor i in range(1, len(inorderNodes)):\nminDifference = min(minDifference, inorderNodes[i] - inorderNodes[i-1])\nreturn minDifference\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#complexity-analysis_1", "title": "Complexity Analysis", "text": "<p>Here, n is the number of nodes in the given binary search tree.</p> <ul> <li> <p>Time complexity: O(n)</p> <ul> <li>We traverse once over each node of the BST using in-order traversal which takes O(n) time.</li> <li>We iterate over the list of size n elements to find the minimum difference which also takes O(n) time.</li> <li> <p>Space complexity: O(n)</p> </li> <li> <p>The in-order traversal is recursive and would take some space to store the stack calls. The maximum number of active stack calls at a time would be the tree\u2019s height, which in the worst case would be O(n) when the tree is a straight line.</p> </li> <li>We also need a list of size O(n) to store the values of all the nodes.</li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#approach-3-in-order-traversal-without-list", "title": "Approach 3: In-order Traversal Without List", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#intuition_2", "title": "Intuition", "text": "<p>As we can notice in the previous approach, we only need the immediate in-order predecessor of any node to calculate the minimum difference. The rest of the nodes will not be needed and are stored unnecessarily in the list.</p> <p>Thus, we can avoid storing elements in a list if we can find the difference between consecutive nodes on the fly during in-order traversal. For each node in the tree, we need the previous node we have handled, and then we can find the difference. This can be done using another variable <code>prevNode</code> that will store the value of the node we handled previously in the in-order traversal. This way, we don\u2019t have to store the elements in an array and at the same time, don\u2019t have to re-iterate over the nodes again.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#algorithm_2", "title": "Algorithm", "text": "<ol> <li>Create an answer variable <code>minDifference</code> and initialize it to infinity.</li> <li>Create a <code>TreeNode</code> variable <code>prevNode</code> to keep track of the previous node we have traversed. Initialize it to <code>null</code>.</li> <li>Perform the inorder traversal of the binary search tree (BST). Call <code>inorderTraversal(root)</code> where <code>inorderTraversal</code> is a recursive method that takes <code>TreeNode node</code> as a parameter. We perform the following in this method:<ul> <li>If <code>node</code> is <code>null</code>, return.</li> <li>Recursively perform the in-order traversal for <code>node.left</code>.</li> <li>We handle <code>node</code> now. We check its difference with the previously visited node <code>prevNode</code>. If <code>prevNode != null</code>, it means we have visited a node previously and hence, we try to update <code>minDifference</code> using <code>minDifference = min(minDifference, node.val - prevNode.val)</code>.</li> <li>Recursively perform the in-order traversal for <code>node.right</code>.</li> </ul> </li> <li>Return <code>minDifference</code>.</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#implementation_2", "title": "Implementation", "text": "<pre><code>class Solution:\ndef getMinimumDifference(self, root: Optional[TreeNode]) -&gt; int:\nself.minDistance = 1e9\n# Initially, it will be null.\nself.prevNode = None\ndef inorder(node):\nif node is None:\nreturn\ninorder(node.left)\n# Find the difference with the previous value if it is there.\nif self.prevNode is not None:\nself.minDistance = min(self.minDistance, node.val - self.prevNode)\nself.prevNode = node.val\ninorder(node.right)\ninorder(root)\nreturn self.minDistance\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/530.%20Minimum%20Absolute%20Difference%20in%20BST/#complexity-analysis_2", "title": "Complexity Analysis", "text": "<p>Here, n is the number of nodes in the given binary search tree.</p> <ul> <li> <p>Time complexity: O(n)</p> <ul> <li>We traverse once over each node of the BST using in-order traversal which takes O(n) time.</li> <li> <p>Space complexity: O(n)</p> </li> <li> <p>The in-order traversal is recursive and would take some space to store the stack calls. The maximum number of active stack calls at a time would be the tree\u2019s height, which in the worst case would be O(n) when the tree is a straight line.</p> </li> <li>Note that this space complexity is only for the worst-case scenario, and in the average case we have greatly improved our space complexity since we don\u2019t need to create a list to store all the nodes.</li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/542.%2001%20Matrix/", "title": "542. 01 Matrix", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "BFS"]}, {"location": "notes/Leetcode%20100-1000/542.%2001%20Matrix/#problem", "title": "Problem", "text": "<p>Given an <code>m x n</code> binary matrix <code>mat</code>, return the distance of the nearest <code>0</code> for each cell.</p> <p>The distance between two adjacent cells is <code>1</code>.</p> <p>Example 1:</p> <p></p> <p>Input: <code>mat = [[0,0,0],[0,1,0],[0,0,0|0,0,0],[0,1,0],[0,0,0]]</code> Output: <code>[[0,0,0],[0,1,0],[0,0,0|0,0,0],[0,1,0],[0,0,0]]</code></p> <p>Example 2:</p> <p></p> <p>Input: <code>mat = [[0,0,0],[0,1,0],[1,1,1|0,0,0],[0,1,0],[1,1,1]]</code> Output: <code>[[0,0,0],[0,1,0],[1,2,1|0,0,0],[0,1,0],[1,2,1]]</code></p> <p>Constraints:</p> <ul> <li><code>m == mat.length</code></li> <li><code>n == mat[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 10**4</code></li> <li><code>1 &lt;= m * n &lt;= 10**4</code></li> <li><code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.</li> <li>There is at least one <code>0</code> in <code>mat</code>.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "BFS"]}, {"location": "notes/Leetcode%20100-1000/542.%2001%20Matrix/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "BFS"]}, {"location": "notes/Leetcode%20100-1000/542.%2001%20Matrix/#bfs-on-matrix", "title": "BFS on matrix", "text": "<p><code>python</code></p> <p>We consider the matrix as a graph, where a cell of the matrix is <code>&lt;node&gt;</code> in graph</p> <p>There are a lot of graph problem like this on matrix (or any other form), my general approach is build a helper <code>getAdj(&lt;node&gt;)</code> function that return all adj-nodes of current node <code>(x, y)</code>.</p> <p>We then adding all the cell <code>&lt;node&gt; = (x,y)</code> that have value <code>mat[x][y] == 0</code> to our queue <code>queue</code>, adding <code>step = 0</code> to each and start BFS from there.</p> <p>Still, In bellow implementation when adding the first loop, I also process to have BFS <code>queue</code> start at step <code>1</code>, all the result is store in <code>cache</code> matrix array (where <code>mat[x][y] == 0</code> =&gt; <code>cache[x][y] == 0</code>)</p> Time Submitted Status Runtime Memory Language 08/17/2023 21:29 Accepted 630 ms 20.2 MB python3 <pre><code>class Solution:\ndef getAdj(x, y, m,n):\nt = [(x-1, y), (x, y - 1), (x+1, y) , (x, y + 1)]\nres = []\nfor i, j in t:\nif 0 &lt;= i &lt; m and 0 &lt;= j &lt; n:\nres.append((i,j))\nreturn res\ndef updateMatrix(self, mat: List[List[int]]) -&gt; List[List[int]]:\nm = len(mat)\nn = len(mat[0])\ncache = [[-1] * n for _ in range(m)]\nqueue = []\nvisited = [[False] * n for _ in range(m)]\nfor i in range(m):\nfor j in range(n):\nif mat[i][j] != 0:\ncontinue\ncache[i][j] = 0\nvisited[i][j] = True\nadj = Solution.getAdj(i,j, m,n)\nfor ai, aj in adj:\nif mat[ai][aj] != 0 and not visited[ai][aj]:\nqueue.append((ai, aj, 1))\nvisited[ai][aj] = True\nwhile len(queue) &gt; 0:\ni, j, step = queue.pop(0)\ncache[i][j] = step\nadj = Solution.getAdj(i,j, m,n)\nfor ai, aj in adj:\nif not visited[ai][aj]:\nqueue.append((ai, aj, step + 1))\nvisited[ai][aj] = True\nreturn cache\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "BFS"]}, {"location": "notes/Leetcode%20100-1000/688.%20Knight%20Probability%20in%20Chessboard/", "title": "688. Knight Probability in Chessboard", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/688.%20Knight%20Probability%20in%20Chessboard/#problem", "title": "Problem", "text": "<p>On an <code>n x n</code> chessboard, a knight starts at the cell <code>(row, column)</code> and attempts to make exactly <code>k</code> moves. The rows and columns are 0-indexed, so the top-left cell is <code>(0, 0)</code>, and the bottom-right cell is <code>(n - 1, n - 1)</code>.</p> <p>A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.</p> <p></p> <p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p> <p>The knight continues moving until it has made exactly <code>k</code> moves or has moved off the chessboard.</p> <p>Return the probability that the knight remains on the board after it has stopped moving.</p> <p>Example 1:</p> <p>Input: n = 3, k = 2, row = 0, column = 0 Output: 0.06250 Explanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board. From each of those positions, there are also two moves that will keep the knight on the board. The total probability the knight stays on the board is 0.0625.</p> <p>Example 2:</p> <p>Input: n = 1, k = 0, row = 0, column = 0 Output: 1.00000</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 25</code></li> <li><code>0 &lt;= k &lt;= 100</code></li> <li><code>0 &lt;= row, column &lt;= n - 1</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/688.%20Knight%20Probability%20in%20Chessboard/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/688.%20Knight%20Probability%20in%20Chessboard/#simulation", "title": "Simulation", "text": "<p>Based on the problem description, we are trying to find the probability that a knight remains on the chessboard after making exactly <code>k</code> moves, starting from a given cell <code>(row, column)</code> on an <code>n x n</code> chessboard. The knight has eight possible moves it can make, as illustrated in the image provided in the problem.</p> <p>To solve this problem, we can use a simulation approach to calculate the probability. We can implement a recursive function <code>move</code> that simulates the knight\u2019s movement. At each step, the knight chooses one of the eight possible moves uniformly at random, and then recursively makes the next move until <code>k</code> moves are reached.</p> <p>To improve efficiency, we can use memorization to store the results of subproblems in a <code>cache</code> dictionary. This way, we can avoid redundant calculations and speed up the computation.</p> <p>Here\u2019s how the simulation-based approach works:</p> <p>The <code>knightProbability</code> function initializes the memorization cache and calls <code>move</code> with the starting position and zero steps taken so far.</p> <ol> <li> <p>Define a function <code>isValid</code> to check if a given position <code>(x, y)</code> is within the chessboard bounds.</p> </li> <li> <p>Implement the recursive function <code>move</code> that calculates the probability of the knight staying on the board after <code>k</code> moves starting from position <code>(x, y)</code>.</p> </li> <li> <p>In the <code>move</code> function, check if <code>k</code> moves have been reached; if yes, return 1 (representing the knight stays on the board).</p> </li> <li> <p>Check if the current state <code>(x, y, step)</code> exists in the cache dictionary; if yes, return the cached probability.</p> </li> <li> <p>For each of the eight possible moves the knight can make, calculate the next position <code>(nX, nY)</code>.</p> </li> <li> <p>If the next position is valid (within the chessboard bounds), recursively call <code>move</code> for the next position and increment the probability with the result.</p> </li> <li> <p>Divide the accumulated probability by 8 (since there are eight possible moves) and store it in the cache.</p> </li> <li> <p>Finally, call the <code>move</code> function with the initial position <code>(row, column, 0)</code> and return the result.</p> </li> </ol> <p>This simulation-based approach accurately calculates the probability of the knight staying on the board after <code>k</code> moves starting from a given cell <code>(row, column)</code> on the chessboard. The use of memorization ensures that the function runs efficiently and avoids redundant computations.</p> <pre><code>class Solution:\ndef isValid(self, x, y):\nreturn 0 &lt;= x &lt; self.n and 0 &lt;= y &lt; self.n\ndef move(self, x, y, step):\nif step &gt;= self.k:\nreturn 1\nif (x, y, step) in self.cache:\nreturn self.cache[(x,y, step)]\nmovementDown = [(2,-1), (2,+1), (1,+2), (1,-2)]\nmovementUp = [(-2,-1), (-2,+1), (-1,+2), (-1,-2)]\nnextPosition = [(x+dx, y+dy) for dx, dy in movementDown]\nnextPosition += [(x+dx, y+dy) for dx, dy in movementUp]\nprobability = 0\nfor nX, nY in nextPosition:\nif self.isValid(nX, nY):\nnextMove = self.move(nX, nY, step + 1)\nprobability += nextMove/8\nself.cache[(x,y,step)] = probability\nreturn probability\ndef knightProbability(self, n: int, k: int, row: int, column: int) -&gt; float:\nself.n = n\nself.k = k\nself.cache = {}\nreturn self.move(row, column, 0)\n</code></pre> <p>I also working on C implementation using same concept, and to my surprise, it throw a Time Limit Exceeded. (Which then later I found out the reason is because I forgot to update cache value) </p> <pre><code>typedef struct {\nint x;\nint y;\n} Pair;\ndouble cache[26][26][101];\nbool isValid(int x,int y,int n) { return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;}\ndouble move(int x, int y, int step, int n, int k) {\nif (step &gt;= k) return 1;\n// printf(\"Log point 2\\n\");\nif (cache[x][y][step] &gt;= 0.) return cache[x][y][step];\n// printf(\"Log point 3\\n\");\nPair nextPosition[] = {\n{x+2, y-1}, {x+2, y+1}, {x+1, y+2}, {x+1, y-2},\n{x-2, y-1}, {x-2, y+1}, {x-1, y+2}, {x-1, y-2}\n};\n// printf(\"Log point 4\\n\");\ndouble probability = 0.;\ndouble nextMove = 0.;\nfor (int i=0; i&lt;8; i++){\nint nX = nextPosition[i].x;\nint nY = nextPosition[i].y; nextMove = 0.; // &lt;- I forgot this\nif (isValid(nX, nY, n)) {\n// printf(\"Log point 5: nX = %d, nY = %d, step = %d,\\n\", nX, nY, step + 1);\nnextMove = move(nX, nY, step + 1, n, k);\n}\nprobability += nextMove/8;\n}\ncache[x][y][step] = probability; // &lt;- I forgot this\nreturn probability;\n}\ndouble knightProbability(int n, int k, int row, int column){\nfor (int i = 0; i &lt; n; i++) {\nfor (int j = 0; j &lt; n; j++) {\nfor (int step = 0; step &lt; k; step++) {\ncache[i][j][step] = -1.0;\n}\n}\n}\n// printf(\"Log point\\n\");\nreturn move(row, column, 0, n, k);\n}\n</code></pre> <p>This instead, work out, which is the same one again but with way less code. <pre><code>int dx[] = {1, 2, 2, 1, -1, -2, -2, -1};\nint dy[] = {2, 1, -1, -2, -2, -1, 1, 2};\ndouble dp[26][26][101];\nint isValid(int x, int y, int n) {\nreturn x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;\n}\ndouble move(int x, int y, int step, int n, int k) {\nif (step &gt;= k) {\nreturn 1.0;\n}\nif (dp[x][y][step] != -1.0) {\nreturn dp[x][y][step];\n}\ndouble probability = 0.0;\nfor (int i = 0; i &lt; 8; i++) {\nint nx = x + dx[i];\nint ny = y + dy[i];\nif (isValid(nx, ny, n)) {\nprobability += move(nx, ny, step+1, n, k);\n}\n}\nprobability /= 8.0;\ndp[x][y][step] = probability;\nreturn probability;\n}\ndouble knightProbability(int n, int k, int row, int column) {\nfor (int i = 0; i &lt; n; i++) {\nfor (int j = 0; j &lt; n; j++) {\nfor (int s = 0; s &lt;= k; s++) {\ndp[i][j][s] = -1.0;\n}\n}\n}\nreturn move(row,column,0,n,k);\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/688.%20Knight%20Probability%20in%20Chessboard/#possible-improvements", "title": "Possible Improvements", "text": "<ol> <li> <p>Dynamic Programming (Bottom-up Approach): Instead of using recursion and memorization, we can utilize a dynamic programming approach to avoid excessive function calls and improve performance. We can build the solution iteratively, starting from the base case (when <code>k = 0</code>) and progressively calculate the probabilities for increasing <code>k</code> values until we reach the target value. This way, we can avoid stack overflow and reduce redundant computations.</p> </li> <li> <p>Optimized Data Structure: The current implementation uses a 3D array to store the memorized values, which can be memory-intensive and slower. We can consider using a 1D array or a hash table with a suitable hashing function to store the computed probabilities.</p> </li> <li> <p>Optimize Data Access: The current implementation uses a 3D array to store the probabilities for each <code>(x, y, step)</code> combination. However, in each step, we only need the probabilities from the previous step. Therefore, we can optimize data access by using two arrays, one for the current step\u2019s probabilities and another for the previous step\u2019s probabilities, and keep swapping them as we progress through the steps.</p> </li> </ol> <p>Based on the above improvements, here\u2019s a refactored C implementation using dynamic programming:</p> <pre><code>typedef struct {\nint x;\nint y;\n} Pair;\ndouble cache[2][26][26];\nint curStep = 0;\nint prevStep = 1;\nbool isValid(int x,int y,int n) { return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;}\ndouble move(int x, int y, int n, int k) {\nPair nextPosition[] = {\n{x+2, y-1}, {x+2, y+1}, {x+1, y+2}, {x+1, y-2},\n{x-2, y-1}, {x-2, y+1}, {x-1, y+2}, {x-1, y-2}\n};\ndouble probability = 0.;\nfor (int i=0; i&lt;8; i++){\nint nX = nextPosition[i].x;\nint nY = nextPosition[i].y; if (isValid(nX, nY, n)) {\nprobability += cache[prevStep][nX][nY] /8;\n}\n}\nreturn probability;\n}\ndouble knightProbability(int n, int k, int row, int column) {\nfor (int i = 0; i &lt; n; i++) {\nfor (int j = 0; j &lt; n; j++) {\ncache[curStep][i][j] = 0.;\ncache[prevStep][i][j] = 0.;\n}\n}\ncache[prevStep][row][column] = 1.;\ndouble currentTotal = 1.;\nfor (int step = 1; step &lt;= k; step++) {\ncurrentTotal = 0.;\nfor (int x = 0; x &lt; n; x++) {\nfor (int y = 0; y &lt; n; y++) {\ncache[curStep][x][y] = move(x, y, n, k);\ncurrentTotal += cache[curStep][x][y];\n}\n}\nint temp = prevStep;\nprevStep = curStep;\ncurStep = temp;\n}\nreturn currentTotal;\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/712.%20Minimum%20ASCII%20Delete%20Sum%20for%20Two%20Strings/", "title": "712. Minimum ASCII Delete Sum for Two Strings", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/712.%20Minimum%20ASCII%20Delete%20Sum%20for%20Two%20Strings/#problem", "title": "Problem", "text": "<p>Given two strings <code>s1</code> and <code>s2</code>, return the lowest ASCII sum of deleted characters to make two strings equal.</p> <p>Example 1:</p> <p>Input: s1 = \u201csea\u201d, s2 = \u201ceat\u201d Output: 231 Explanation: Deleting \u201cs\u201d from \u201csea\u201d adds the ASCII value of \u201cs\u201d (115) to the sum. Deleting \u201ct\u201d from \u201ceat\u201d adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.</p> <p>Example 2:</p> <p>Input: s1 = \u201cdelete\u201d, s2 = \u201cleet\u201d Output: 403 Explanation: Deleting \u201cdee\u201d from \u201cdelete\u201d to turn the string into \u201clet\u201d, adds 100[d] + 101[e] + 101[e] to the sum. Deleting \u201ce\u201d from \u201cleet\u201d adds 101[e] to the sum. At the end, both strings are equal to \u201clet\u201d, and the answer is 100+101+101+101 = 403. If instead we turned both strings into \u201clee\u201d or \u201ceet\u201d, we would get answers of 433 or 417, which are higher.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= s1.length, s2.length &lt;= 1000</code></li> <li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/712.%20Minimum%20ASCII%20Delete%20Sum%20for%20Two%20Strings/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/712.%20Minimum%20ASCII%20Delete%20Sum%20for%20Two%20Strings/#recursion-with-cache", "title": "Recursion with cache", "text": "<p>This is a good tactic to do any code challenger:</p> <ul> <li>To solve any problem with some form of Dynamic programming, we should start finding pattern.</li> <li>By using Recursion, we can try: Reuse the same function, using cache to have some form of reuse result from our last calculation</li> </ul> <p>Here, I found a pattern that, with provided <code>s1</code> and <code>s2</code>, we can try:</p> <ul> <li>Delete one char from <code>s1</code></li> <li>Delete one char from <code>s2</code></li> <li>Keep same char both on <code>s1</code> and <code>s2</code> </li> </ul> <p>To make the problem repeatable, by forcing the character we care about is last char of each string: <pre><code>class Solution:\ndef minimumDeleteSum(self, s1: str, s2: str, cache = None) -&gt; int:\nif cache is None:\ncache = {}\nif (s1, s2) in cache:\nreturn cache[(s1, s2)]\nif s1 == s2 == \"\":\nreturn 0\npossible = []\nif len(s2) &gt; 0:\npossible.append(self.minimumDeleteSum(s1, s2[:len(s2) - 1], cache) + ord(s2[-1]))\nif len(s1) &gt; 0:\npossible.append(self.minimumDeleteSum(s1[:len(s1) - 1], s2, cache) + ord(s1[-1]))\nif len(s2) &gt; 0 and len(s1) &gt; 0 and s2[-1] == s1[-1]:\npossible.append(self.minimumDeleteSum(s1[:len(s1) - 1], s2[:len(s2) - 1], cache))\ncache[(s1, s2)] = min(possible)\nreturn cache[(s1, s2)] \n</code></pre></p> <p>(or first char) <pre><code>class Solution:\ndef minimumDeleteSum(self, s1: str, s2: str, cache = None) -&gt; int:\nif cache is None:\ncache = {}\nif (s1, s2) in cache:\nreturn cache[(s1, s2)]\nif s1 == s2 == \"\":\nreturn 0\npossible = []\nif len(s2) &gt; 0:\npossible.append(self.minimumDeleteSum(s1, s2[1:], cache) + ord(s2[0]))\nif len(s1) &gt; 0:\npossible.append(self.minimumDeleteSum(s1[1:], s2, cache) + ord(s1[0]))\nif len(s2) &gt; 0 and len(s1) &gt; 0 and s2[0] == s1[0]:\npossible.append(self.minimumDeleteSum(s1[1:], s2[1:], cache))\ncache[(s1, s2)] = min(possible)\nreturn cache[(s1, s2)] \n</code></pre></p> <p>We can then calculating any possible combination of delete (and keep) character with provided <code>(s1, s2)</code> pair.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/712.%20Minimum%20ASCII%20Delete%20Sum%20for%20Two%20Strings/#dynamic-programming", "title": "Dynamic programming", "text": "<p>By using the same logic, but instead of using string and dictionary, I represent the string by its index <code>i -&gt; s[:i]</code> , which mean when <code>i == 0 -&gt; s[:i] = \"\"</code> . We need <code>cache</code> array covering <code>[0..=n]</code> (inclusive) range</p> <pre><code>class Solution:\ndef minimumDeleteSum(self, s1: str, s2: str, cache = None) -&gt; int:\ncache = [[0]* (len(s2)+1) for i in range(len(s1)+1)]\nfor i in range(0, len(s1)+1):\nfor j in range(0, len(s2)+1):\npossible = []\nif j &gt; 0:\npossible.append(cache[i][j-1] + ord(s2[j-1]))\nif i &gt; 0:\npossible.append(cache[i-1][j] + ord(s1[i-1]))\nif i &gt; 0 and j &gt; 0 and s1[i-1] == s2[j-1]:\npossible.append(cache[i-1][j-1])\nif possible:\ncache[i][j] = min(possible)\nreturn cache[-1][-1] \n</code></pre> <p>This C code technically do the same thing: <pre><code>int min(int x, int y){\nif (x == -1)\nreturn y;\nif (x &gt; y)\nreturn y;\nreturn x;\n}\nint minimumDeleteSum(char * s1, char * s2){\nint len1 = strlen(s1);\nint len2 = strlen(s2);\nint cache[1001][1001] = {0};\nfor (int i = 0; i &lt;= len1; i++) {\nfor (int j = 0; j &lt;= len2; j++) {\nint possible = -1;\nif (j &gt; 0) possible = min(possible, cache[i][j - 1] + s2[j - 1]);\nif (i &gt; 0) possible = min(possible, cache[i - 1][j] + s1[i - 1]);\nif (i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; s1[i - 1] == s2[j - 1]) possible = min(possible, cache[i - 1][j - 1]);\nif (possible &gt; 0) cache[i][j] = possible;\n}\n}\nreturn cache[len1][len2];\n}\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/714.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/", "title": "714. Best Time to Buy and Sell Stock with Transaction Fee", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/714.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/#problem", "title": "Problem", "text": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>ith</code> day, and an integer <code>fee</code> representing a transaction fee.</p> <p>Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.</p> <p>Note:</p> <ul> <li>You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</li> <li>The transaction fee is only charged once for each stock purchase and sale.</li> </ul> <p>Example 1:</p> <p>Input: prices = [1,3,2,8,4,9], fee = 2 Output: 8 Explanation: The maximum profit can be achieved by:</p> <ul> <li>Buying at prices[0] = 1</li> <li>Selling at prices[3] = 8</li> <li>Buying at prices[4] = 4</li> <li>Selling at prices[5] = 9 The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/714.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20with%20Transaction%20Fee/#solve", "title": "Solve", "text": "<p>I track the profit I can make the most of when I:</p> <ul> <li>Not holding any stock <code>bestProfit[0]</code></li> <li>Holding a stock <code>bestProfit[1]</code></li> </ul> <p>With each step of prices change:</p> <ul> <li> <p>If I don\u2019t want to holding stock in this step, my <code>bestProfit[0]</code> is affect by two case:</p> <ul> <li>I could try to sell my currently holding stock <code>last_bestProfit[1]</code> and get <code>last_bestProfit[1] + price - fee</code> asset value </li> <li>or I could do not thing and keep <code>last_bestProfit[0]</code> asset value</li> </ul> </li> <li> <p>If I want to holding a stock now, my <code>bestProfit[1]</code> is also affect by two case: </p> <ul> <li>I could try to buy a stock, which make my asset value down to  <code>last_bestProfit[0] - price</code> </li> <li>or I could doing any thing and keep <code>last_bestProfit[1]</code></li> </ul> </li> </ul> <pre><code>class Solution:\ndef maxProfit(self, prices: List[int], fee: int) -&gt; int:\nbestProfit = [0, 0]\nfor step, price in enumerate(prices):\nif step == 0:\nbestProfit[1] = -price\ncontinue\ntmp = bestProfit[0]\nbestProfit[0] = max(bestProfit[0], bestProfit[1] + price - fee)\nbestProfit[1] = max(bestProfit[1], tmp - price)\nreturn bestProfit[0]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/735.%20Asteroid%20Collision/", "title": "735. Asteroid Collision", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/735.%20Asteroid%20Collision/#problem", "title": "Problem", "text": "<p>We are given an array <code>asteroids</code> of integers representing asteroids in a row.</p> <p>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p> <p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p> <p>Constraints:</p> <ul> <li><code>2 &lt;= asteroids.length &lt;= 104</code></li> <li><code>-1000 &lt;= asteroids[i] &lt;= 1000</code></li> <li><code>asteroids[i] != 0</code></li> </ul> <p>Example 1: <pre><code>**Input:** asteroids = [5,10,-5]\n**Output:** [5,10]\n**Explanation:** The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/735.%20Asteroid%20Collision/#solve", "title": "Solve", "text": "<p>Just imagine it not left right, but up and down. We used a stack to handle asteroids simulation:</p> <ul> <li>Every asteroid adding to the stack, we check for collision, which meaning checking the sign of asteroid on then stack top, vs newly added one.<ul> <li>added asteroid (+) with <code>value&gt;0</code>:The asteroids (-) and (+) in the stack have nothing to do with newly added asteroid (+)</li> <li>added asteroid (-) with <code>value&lt;0</code>: collision happen, simulation the collapsing until either:<ul> <li>All asteroid going up (+) explode, the stack remain the added asteroid (-).</li> <li>Or added asteroid (-) being stop.</li> </ul> </li> </ul> </li> </ul> <p>This should do the same in C: <pre><code>/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize){\nint* stack = (int*)malloc(asteroidsSize * sizeof(int));\nint size = 0;\nint asteroid;\nfor (int i = 0; i &lt; asteroidsSize; i++){\nasteroid = asteroids[i];\nif (size == 0) {\nstack[size] = asteroid;\nsize ++;\n}\nelse if (stack[size-1] &lt; 0 || asteroid &gt; 0) {\nstack[size] = asteroid;\nsize ++;\n}\nelse {\nstack[size] = asteroid;\nwhile (size &gt; 0 &amp;&amp; stack[size-1] &gt; 0 &amp;&amp; stack[size] &lt; 0) {\nif (stack[size-1] &lt; -stack[size])\nstack[size-1] = stack[size];\nelse if (stack[size-1] == -stack[size])\nstack[size-1] = 0;\nsize--;\n}\nif (stack[size] != 0) size++;\n}\n}\n*returnSize = size;\nreturn stack;\n}\n</code></pre></p> <p>minimal C code: <pre><code>int* asteroidCollision(int* asteroids, int asteroidsSize, int* returnSize){\nint *stack = (int *) malloc (asteroidsSize * sizeof(int));\nint k = -1; // no elements\nfor(int i = 0; i&lt;asteroidsSize; i++){\nk++;\nstack[k] = asteroids[i];\nwhile(k &gt; 0 &amp;&amp; stack[k] &lt; 0 &amp;&amp; stack[k-1] &gt; 0){\nif(abs(stack[k]) &gt; abs(stack[k-1])){\nstack[k-1] = stack[k];\nk--;\n} else if(abs(stack[k]) == abs(stack[k-1])){\nk = k - 2;\n} else {\nk--;\n}\n}\n}\n*returnSize = k + 1;\nreturn stack;\n}\n</code></pre></p> <p>While this, is python implementation <pre><code>class Solution(object):\ndef asteroidCollision(self, asteroids):\nstack = []\nfor asteroid in asteroids:\nwhile stack and asteroid &lt; 0 &lt; stack[-1]:\nif stack[-1] &lt; -asteroid:\nstack.pop()\nelif stack[-1] == -asteroid:\nstack.pop()\nbreak\nelse:\nbreak\nelse:\nstack.append(asteroid)\nreturn stack\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/", "title": "802. Find Eventual Safe States", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#problem", "title": "Problem", "text": "<p>There is a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n - 1</code>. The graph is represented by a 0-indexed 2D integer array <code>graph</code> where <code>graph[i]</code> is an integer array of nodes adjacent to node <code>i</code>, meaning there is an edge from node <code>i</code> to each node in <code>graph[i]</code>.</p> <p>A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).</p> <p>Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.</p> <p>Constraints:</p> <ul> <li><code>n == graph.length</code></li> <li><code>1 &lt;= n &lt;= 10**4</code></li> <li><code>0 &lt;= graph[i].length &lt;= n</code></li> <li><code>0 &lt;= graph[i][j] &lt;= n - 1</code></li> <li><code>graph[i]</code> is sorted in a strictly increasing order.</li> <li>The graph may contain self-loops.</li> <li>The number of edges in the graph will be in the range <code>[1, 4 * 10**4]</code>.</li> </ul> <p>Example 1:</p> <p> <pre><code>**Input:** graph = [[1,2],[2,3],[5],[0],[5],[],[|1,2],[2,3],[5],[0],[5],[],[]]\n**Output:** [2,4,5,6]\n**Explanation:** The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#solve", "title": "Solve", "text": "<p>A hard to understand problem.</p> <ul> <li>You have terminated node, which have no outgoing edges . A terminated node is also a safe node : <code>if len(graph[i]) == 0 then i is \"terminated node\" and i is \"safe node\"</code></li> <li>A safe node is node that run into a terminated node or other safe node</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#first-approach", "title": "First approach", "text": "<p>A quick <code>O(n**3)</code> which could be close to <code>O(n**2)</code> which utilize hash map do exactly that</p> <ul> <li>Find all terminated node on first loop, put it into <code>safe_node</code> array</li> <li>Find all node that only point to <code>safe_node</code> array, which we call <code>found_safe_node</code>, putting them into result</li> <li>Repeat until there is no longer node to put in to <code>safe_node</code> array</li> <li>Return <code>safe_node</code> array <pre><code>class Solution:\ndef eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\ngraph = [set(i) for i in graph]\nsafe_node = set()\nfor loop_round in range(len(graph)):\nfound_safe_node = set()\nfor node_id, adjNodes in enumerate(graph):\nif node_id in safe_node:\ncontinue\nif len(adjNodes) == 0:\nfound_safe_node.add(node_id)\nsafe_node.add(node_id)\nif len(found_safe_node) == 0:\nbreak\nfor adjNodes in graph:\nadjNodes -= found_safe_node\nsafe_node = list(safe_node)\nsafe_node.sort()\nreturn safe_node\n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#second-approach", "title": "Second approach", "text": "<p>Further optimize, a more better approach, where after found a safe node, we recheck other node pointed to them only.</p> <ul> <li>From input graph, create a <code>ref_table</code>. Where <code>ref_table[i]</code> storing all node that could point/go to <code>i</code> </li> <li>Still slow as we use too much hash map and memory though <pre><code>class Solution:\ndef eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\ngraph = [set(i) for i in graph]\nsafe_node = set()\nref_table = [set() for _ in graph]\nfound_safe_node = set()\nfor node_id, adjNodes in enumerate(graph):\nif len(adjNodes) == 0:\nfound_safe_node.add(node_id)\nsafe_node.add(node_id)\nfor adjNode in adjNodes:\nref_table[adjNode].add(node_id)\nfor loop_round in range(len(graph)):\nneed_to_check_node = set()\nnew_found_safe_node = set()\nfor node_id in found_safe_node:\nneed_to_check_node = need_to_check_node.union(ref_table[node_id])\nfor node_id in need_to_check_node:\ngraph[node_id] = graph[node_id] - found_safe_node\nif len(graph[node_id]) == 0:\nnew_found_safe_node.add(node_id)\nsafe_node.add(node_id)\nif len(new_found_safe_node) == 0:\nbreak\nfound_safe_node = new_found_safe_node\nsafe_node = list(safe_node)\nsafe_node.sort()\nreturn safe_node\n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#third-approach", "title": "Third approach", "text": "<p>We will try to minimize the need of memory allocation</p> <ul> <li>Stop try to solved and find safe node on each round of loop. Instead, checking each found safe node one by one. With simple queue/stack <code>found_safe_node</code>, we check each <code>curr_safe_node_id</code> and reducing a lot of logic in our inner loop (the code implementation using simple name <code>node_id</code>, changing the inner for loop interrater variable to <code>ref_node</code>)<ul> <li>We can skip our need to use <code>set()</code> in <code>ref_table</code> for as we no longer need <code>set.union</code> function to find <code>need_to_check_node</code> (since <code>need_to_check_node = ref_table[curr_safe_node_id]</code>)</li> <li><code>new_found_safe_node</code> can be append directly into <code>found_safe_node</code> and will be process later</li> <li>On each loop, we do the same <code>graph[node_id] = graph[node_id] - set([curr_safe_node_id])</code> and check if our <code>len(graph[node_id]) == 0</code> to find if it a new found safe node</li> <li>The loop round can be change to a proper <code>while loop</code> that run until all <code>found_safe_node</code> is processed </li> </ul> </li> <li>Another optimization is our <code>safe_node</code> result array, we can use a Boolean array to keep track which node is safe node instead of using set, and later loop through for an <code>O(n)</code> time tracking and sorting solution <pre><code>class Solution:\ndef eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\ngraph = [set(i) for i in graph]\nis_safe_node = [False] * len(graph)\nref_table = [[] for _ in graph]\nfound_safe_node = []\nfor node_id, adjNodes in enumerate(graph):\nif len(adjNodes) == 0:\nfound_safe_node.append(node_id)\nis_safe_node[node_id] = True\nfor adjNode in adjNodes:\nref_table[adjNode].append(node_id)\nwhile len(found_safe_node) &gt; 0:\nnode_id = found_safe_node.pop(0)\nfor ref_node in ref_table[node_id]:\nif is_safe_node[ref_node]:\ncontinue\ngraph[ref_node] = graph[ref_node] - set([node_id])\nif len(graph[ref_node]) == 0:\nfound_safe_node.append(ref_node)\nis_safe_node[ref_node] = True\nsafe_node = []\nfor node_id, is_safe in enumerate(is_safe_node):\nif is_safe:\nsafe_node.append(node_id)\nreturn safe_node\n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#fun-fact", "title": "Fun fact:", "text": "<p>With out using <code>ref_node</code> that we have at our second attempt, we will  get <code>Time limit Exceeded</code>. Which mean the crafted input is quite generous on us and not have many edges case with lager input.</p> <p>This also mean, I not even have to optimize using set <code>ref_node</code>, where every update will remove the found safe node to make <code>ref_table[node_id]</code> loop even lower</p> <p>Here is implement we we not using  <code>ref_node</code> <pre><code>class Solution:\ndef eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\ngraph = [set(i) for i in graph]\nis_safe_node = [False] * len(graph)\nfound_safe_node = []\nfor node_id, adjNodes in enumerate(graph):\nif len(adjNodes) == 0:\nfound_safe_node.append(node_id)\nis_safe_node[node_id] = True\nwhile len(found_safe_node) &gt; 0:\nfound_safe_node_id = found_safe_node.pop()\nfor node_id, adjNodes in enumerate(graph):\nif is_safe_node[node_id]:\ncontinue\nadjNodes -= set([found_safe_node_id])\nif len(adjNodes) == 0:\nfound_safe_node.append(node_id)\nis_safe_node[node_id] = True\nsafe_node = []\nfor node_id, is_safe in enumerate(is_safe_node):\nif is_safe:\nsafe_node.append(node_id)\nreturn safe_node\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#read-the-solution-and-realization", "title": "Read the solution and realization", "text": "<p>We can still further optimization</p> <p>We treat graph as literal hash map set() and tracking all node with no edge go out from it to find safe node. This could be improved by only keep track off total node can go to our current <code>node_id</code> instead, we call it  <code>indegree</code> of node, where <code>indegree[node_id] = len(graph[node_id]).</code></p> <ul> <li>Every terminated node and safe node only need to be visited once and we delete/reduction all edges related to that node</li> <li>This happened one time only and not overlap, so we could just keep track off total node can go to our current <code>node_id</code> instead, we call it  <code>indegree</code> array where <code>indegree[i] = len(graph[i])</code>.</li> <li>Every update, <code>graph[node_id] = graph[node_id] - found_safe_node</code> can be replacing with <code>indegree[node_id] -= len(found_safe_node)</code></li> <li>We can even further simplify this process by calculating one  <code>found_safe_node</code> each looped time, and <code>indegree[node_id] -= 1</code> with each loop</li> </ul> <p>While I\u2019m at it, I try to minimize the loop on <code>ref_table</code> too anyway <pre><code>class Solution:\ndef eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\nindegree = [0] * len(graph)\nis_safe_node = [False] * len(graph)\nref_table = [set() for _ in graph]\nfound_safe_node = []\nfor node_id, adjNodes in enumerate(graph):\nif len(adjNodes) == 0:\nfound_safe_node.append(node_id)\nis_safe_node[node_id] = True\nindegree[node_id] = len(adjNodes)\nfor adjNode in adjNodes:\nref_table[adjNode].add(node_id)\nwhile len(found_safe_node) &gt; 0:\nnode_id = found_safe_node.pop(0)\nfor ref_node in ref_table[node_id]:\nif is_safe_node[ref_node]:\nref_table[ref_node] -= set([node_id])\ncontinue\nindegree[ref_node] -= 1\nif indegree[ref_node] == 0:\nfound_safe_node.append(ref_node)\nis_safe_node[ref_node] = True\nsafe_node = []\nfor node_id, is_safe in enumerate(is_safe_node):\nif is_safe:\nsafe_node.append(node_id)\nreturn safe_node\n</code></pre></p> <p>^Simulation</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#just-getting-it", "title": "Just getting it", "text": "<p>Here is some of the best <code>Crtl + C</code> solution</p> <ul> <li>We create a mark array for caching result of <code>Helper</code> function <ul> <li>It start at <code>-1</code> for not doing any calculation yet</li> </ul> </li> <li><code>Helper</code> check if a node is <code>safe</code> or not: <ul> <li>Where with each <code>node</code>, we actually try to do a DFS <code>Helper</code> function and find if our DFS search function through graph ran in to a visited <code>node</code> . </li> <li>The function keep track of visited node by marking them as <code>0</code></li> <li>If any of <code>Helper</code> DFS search that have <code>adjNode</code> connected to our current node <code>idx</code> in <code>graph[idx]</code> return <code>0</code> (Which mean it have been visited by the  <code>Helper</code> DFS function or run into a know not safe node), return <code>0</code> which mean our current node <code>idx</code> is not safe</li> <li>Otherwise, our current node <code>idx</code> is a safe node, cache the result into our <code>mark</code> cache array and return <code>1</code> <pre><code>class Solution:\ndef eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\nmask = [-1] * len(graph)\ndef helper(idx):\nif mask[idx] != -1:\nreturn mask[idx]\nmask[idx] = 0\nfor i in graph[idx]:\nif helper(i) == 0:\nreturn 0\nmask[idx] = 1\nreturn 1\nreturn [i for i in range(len(graph)) if helper(i)]\n</code></pre></li> </ul> </li> </ul> <p>I try to be more clear changing all function and variable name, but this have some quite elegant, and quite challenging to break it down into smaller component:</p> <ul> <li>Keeping track of visited node into <code>is_safe_node</code> array by using 3 stage <code>[None, False, True]</code> </li> <li>Pre-set our current node <code>current_node_id</code> into unsafe node (<code>is_safe_node[current_node_id] = false</code> stage phase) until proven a safe node (<code>is_safe_node[current_node_id] = True</code> stage). Each connection/edge of our <code>current_node_id -&gt; adj_node_id</code> will be check to see if:<ul> <li>when we have a <code>adj_node_id</code> with a <code>False</code> node stage: <ul> <li><code>adj_node_id</code> either is a Visited node in current call stack BFS path that and currently being Pre-set as unsafe node (which mean it haven\u2019t been proven a safe node). This mean our BFS function found a cycle path (or can\u2019t be terminated path) from our current call stack BFS path.</li> <li>or <code>adj_node_id</code> is an already know unsafe node that have been process. We can start a cycle path from this <code>adj_node_id</code> node</li> </ul> </li> <li>We have a <code>adj_node_id</code> with <code>True</code> node stage: <ul> <li>Which mean it pass it the pre-set phase, no cycle path can be from start from this <code>adj_node_id</code> node</li> <li>And <code>adj_node_id</code> become a know safe node that have been process</li> </ul> </li> </ul> </li> <li>Immediately return a <code>DFS</code> as <code>False</code> will break out of all our current call stack, which make all node trace down preset as unsafe node is now become a know a unsafe node.</li> </ul> <pre><code>class Solution:\ndef eventualSafeNodes(self, graph: List[List[int]]) -&gt; List[int]:\nis_safe_node = [None] * len(graph)\ndef DFS(current_node_id):\nif not is_safe_node[current_node_id] is None:\nreturn is_safe_node[current_node_id]\nis_safe_node[current_node_id] = False\nfor adj_node_id in graph[current_node_id]:\nif DFS(adj_node_id) == False:\nreturn False\nis_safe_node[current_node_id] = True\nreturn True\nreturn [node_id for node_id in range(len(graph)) if DFS(node_id)]\n</code></pre> <p>^DFS</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/802.%20Find%20Eventual%20Safe%20States/#comparation", "title": "Comparation", "text": "<p>Overall, a too intelligent DFS code for sure, that reduce about ~100 ms ~ 1/7 time complexity (Here is comparation of DFS (Bellow row) and Simulation (Above row) code implementation)</p> Agro Time Submitted Status Runtime Memory Language Simulation 07/13/2023 11:05 Accepted 716 ms 25 MB python3 DFS 07/13/2023 11:04 Accepted 634 ms 24.2 MB python3", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/852.%20Peak%20Index%20in%20a%20Mountain%20Array/", "title": "852. Peak Index in a Mountain Array", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/852.%20Peak%20Index%20in%20a%20Mountain%20Array/#problem", "title": "Problem", "text": "<p>An array <code>arr</code> a mountain if the following properties hold:</p> <ul> <li><code>arr.length &gt;= 3</code></li> <li>There exists some <code>i</code> with <code>0 &lt; i &lt; arr.length - 1</code> such that:<ul> <li><code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]</code></li> <li><code>arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code></li> </ul> </li> </ul> <p>Given a mountain array <code>arr</code>, return the index <code>i</code> such that <code>arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code>.</p> <p>You must solve it in <code>O(log(arr.length))</code> time complexity.</p> <p>Example 1:</p> <pre><code>**Input:** arr = [0,1,0]\n**Output:** 1\n</code></pre> <p>Constraints:</p> <ul> <li><code>3 &lt;= arr.length &lt;= 105</code></li> <li><code>0 &lt;= arr[i] &lt;= 106</code></li> <li><code>arr</code> is guaranteed to be a mountain array.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/852.%20Peak%20Index%20in%20a%20Mountain%20Array/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/852.%20Peak%20Index%20in%20a%20Mountain%20Array/#linear", "title": "Linear", "text": "<p>Create a pointer <code>left</code> at the start and a pointer <code>right</code> at the end of the array. Loop using there:</p> <ul> <li>If <code>arr[left] &lt;= arr[right]</code>: increase Left</li> <li>else: <code>arr[left] &gt; arr[right]</code>: increase Right</li> <li>Stop when <code>left == right</code> Because we always can found <code>arr[left] &lt; arr[i] &gt; arr[right]</code>, so the function stop at <code>left == right == i</code></li> </ul> <pre><code>class Solution:\ndef peakIndexInMountainArray(self, arr: List[int]) -&gt; int:\nl, r = 0, len(arr) - 1\nwhile l != r:\nif arr[l] &lt;= arr[r]:\nl += 1\nelse:\nr -= 1\nreturn l\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/852.%20Peak%20Index%20in%20a%20Mountain%20Array/#using-binary-search-to-find-the-maximum-value-in-a-discrete-parabolic-like-array-gave-up", "title": "Using Binary Search to Find the Maximum Value in a Discrete Parabolic-Like Array (Gave up)", "text": "<p>This could possibly use in all discrete Parabolic search</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/852.%20Peak%20Index%20in%20a%20Mountain%20Array/#intuition", "title": "Intuition", "text": "<p>In a mountain array with peak index <code>i</code>, any element at <code>index</code> with <code>index</code> less than <code>i</code> would obey <code>arr[index] &lt; arr[index + 1]</code>. Furthermore, any <code>index</code> greater than or equal to <code>i</code> would follow the rule <code>arr[index] &gt; arr[index + 1]</code> (and not obey <code>arr[index] &lt; arr[index + 1]</code>).</p> <p>A scenario like this where our task is to search for an element <code>i</code> from a given range <code>(l, r)</code> where all values smaller than <code>i</code> satisfy a certain condition and all values greater than or equal to <code>i</code> do not satisfy it (or vice-versa) can be solved optimally with a binary search algorithm. In binary search, we repeatedly divide the solution space where the answer could be in half until the range contains just one element.</p> <p>Following the above discussion, we use binary search to solve this problem. We create an integer <code>l</code> and initialize it to the starting index <code>0</code>. We also create another integer variable <code>r</code> and set it to the last index of <code>arr</code>, i.e., <code>arr.length - 1</code>.</p> <p>We get the middle of the range <code>mid = (l + r) / 2</code> and compare <code>arr[mid]</code> with the next element. If <code>arr[mid] &lt; arr[mid + 1]</code>, we move to the upper half of the range by setting <code>l = mid + 1</code> as our peak index is definitely greater than <code>mid</code>. Otherwise, if <code>arr[mid] &gt; arr[mid + 1]</code>, we move to the lower half of the range by setting <code>r = mid</code> as the peak index is either <code>mid</code> or some index smaller than <code>mid</code>.</p> <p>The answer would be within the range <code>(l, r)</code> at any point. All the indices smaller than <code>l</code> are indices smaller than the peak index and all indices greater than <code>r</code> are indices greater than the peak index. We continue the search as long as <code>l &lt; r</code>.</p> <p>When <code>l == r</code>, <code>l</code> (or <code>r</code>) denotes the required peak index.</p> <p>Here is a visual representation of an example to illustrate how it works:</p> <p></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/852.%20Peak%20Index%20in%20a%20Mountain%20Array/#algorithm", "title": "Algorithm", "text": "<ol> <li>Create two integer variables <code>l</code> and <code>r</code> to store the solution space of the problem. We initialize <code>l</code> with <code>0</code> and <code>r</code> to <code>arr.length - 1</code>.</li> <li>While <code>l &lt; r</code>:<ul> <li>Get the index of the middle element using <code>mid = (l + r) / 2</code>.</li> <li>If <code>arr[mid] &lt; arr[mid + 1]</code>, it indicates peak index is greather than <code>mid</code>. As a result, we move to upper half of the range by setting <code>left = mid + 1</code>.</li> <li>Else, if <code>arr[mid] &gt;= arr[mid + 1]</code>, it indicates that the peak index is either <code>mid</code> or some index smaller than <code>mid</code>. As a result, we move to the lower half of the range by setting <code>r = mid</code>.</li> </ul> </li> <li>Return <code>l</code> (or <code>r</code> as both are equal now).</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/852.%20Peak%20Index%20in%20a%20Mountain%20Array/#implementation", "title": "Implementation", "text": "<pre><code>class Solution:\ndef peakIndexInMountainArray(self, arr: List[int]) -&gt; int:\nl = 0\nr = len(arr)\nwhile l &lt; r:\nmid = (l + r) // 2\nif arr[mid] &lt; arr[mid + 1]:\nl = mid + 1\nelse:\nr = mid\nreturn l\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/859.%20Buddy%20Strings/", "title": "859. Buddy Strings", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/859.%20Buddy%20Strings/#problem", "title": "Problem", "text": "<p>Given two strings <code>s</code> and <code>goal</code>, return <code>true</code> if you can swap two letters in <code>s</code> so the result is equal to <code>goal</code>, otherwise, return <code>false</code>.</p> <p>Swapping letters is defined as taking two indices <code>i</code> and <code>j</code> (0-indexed) such that <code>i != j</code> and swapping the characters at <code>s[i]</code> and <code>s[j]</code>.</p> <ul> <li>For example, swapping at indices <code>0</code> and <code>2</code> in <code>\"abcd\"</code> results in <code>\"cbad\"</code>.</li> </ul> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length, goal.length &lt;= 2 * 10**4</code></li> <li><code>s</code> and <code>goal</code> consist of lowercase letters.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/859.%20Buddy%20Strings/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/859.%20Buddy%20Strings/#read-the-problem", "title": "Read the problem", "text": "<ul> <li>Only one swap is allow, and we get two identical string</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/859.%20Buddy%20Strings/#analysis", "title": "Analysis", "text": "<ul> <li>The constrain is really low</li> <li>There should be two case that return <code>True</code>, which is: 1. String <code>s</code> and <code>goal</code> have no different, we swap an identical character so the string remain unchanged; 2. String <code>s</code> and <code>goal</code> have a pair <code>(x,y)</code> being swap</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/859.%20Buddy%20Strings/#code-it", "title": "Code it", "text": "<ul> <li>Just a regular loop through all character of <code>pair(s, goal)</code> check to find if there is any different character. Storing their position in <code>diff</code> array</li> <li>If <code>len(s) &gt; len(goal)</code> or <code>len(diff) != 0 and len(diff) != 2</code> then we can just return <code>False</code></li> <li>For case 1. <code>len(diff) == 0</code> we can loop through string <code>s</code> and find if any character is repeat (using <code>set()</code> to keep track which char have show up). Return <code>True</code> if found or <code>False</code> if not</li> <li>For case 2. <code>len(diff) == 2</code> we can quick check if swapping 2 character with position <code>diff[0], diff[1]</code> of either <code>s</code> or <code>goal</code> is equal to the other one or not: Using <code>s[diff[1]] == goal[diff[0]] and s[diff[0]] == goal[diff[1]]</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/859.%20Buddy%20Strings/#implement", "title": "Implement", "text": "<pre><code>class Solution:\ndef buddyStrings(self, s: str, goal: str) -&gt; bool:\n# Find different of s and goal\nif len(s) != len(goal):\nreturn False\ndiff = []\nfor i, (x, y) in enumerate(zip(s, goal)):\nif x != y:\ndiff.append(i)\nif len(diff) != 0 and len(diff) != 2:\nreturn False\nif len(diff) == 2:\nreturn s[diff[1]] == goal[diff[0]] and s[diff[0]] == goal[diff[1]]\ncheck = set()\nfor c in s:\nif c not in check:\ncheck.add(c)\nelse:\nreturn True\nreturn False\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/894.%20All%20Possible%20Full%20Binary%20Trees/", "title": "894. All Possible Full Binary Trees", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/894.%20All%20Possible%20Full%20Binary%20Trees/#problem", "title": "Problem", "text": "<p>Given an integer <code>n</code>, return a list of all possible full binary trees with <code>n</code> nodes. Each node of each tree in the answer must have <code>Node.val == 0</code>.</p> <p>Each element of the answer is the root node of one possible tree. You may return the final list of trees in any order.</p> <p>A full binary tree is a binary tree where each node has exactly <code>0</code> or <code>2</code> children.</p> <p>Example 1:</p> <p></p> <pre><code>**Input:** n = 7\n**Output:** [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0|0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 20</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/894.%20All%20Possible%20Full%20Binary%20Trees/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/894.%20All%20Possible%20Full%20Binary%20Trees/#over-complicating-simulation-approach", "title": "Over complicating simulation approach", "text": "<p>hash </p> <p>There isn\u2019t any thing said we could reused the tree node, which I mean all <code>TreeNode</code> object from Root A should be different from Root B . We assuming that this No reused rule is required.</p> <p>We try to build up all solution from bottom:</p> <ul> <li>If <code>n</code> is even (<code>n % 2 == 0</code>), there are no possible full binary trees since we always need to have an odd number of nodes to form a full binary tree.</li> <li>If <code>n</code> is 1, there is only one possible full binary tree with a single node having a value of 0.</li> </ul> <p>For any odd <code>n = 2x + 1</code>, where <code>x</code> is an integer, we can generate the full binary trees from the previous <code>n - 2 = 2x - 1</code> trees. We use the following building blocks:</p> <ul> <li><code>self.roots</code>: We keep track of an array of roots math have previous <code>n-2</code> nodes, which starting with a tree containing a single node with value 0 when <code>n = 1</code>.</li> <li><code>self.leafs</code>: We also keep track of all leaf nodes in each tree of <code>self.roots</code> array. The purpose of this is to quickly add new nodes directly to the leaf nodes instead of looping through all the nodes to find the leaf nodes.</li> </ul> <p>In the implementation, I using <code>tuple</code> to store both of <code>self.roots</code> and <code>self.leafs</code> in one array <code>self.roots</code> </p> <p>We then follow these steps to build the trees:</p> <ol> <li>We start with <code>n = 1</code>, and initialize <code>self.roots</code> with a tree containing a single node with value 0. Also, we initialize <code>self.leafs[root] = [&lt;all leaf nodes of the root tree&gt;]</code>.</li> <li>For any <code>n = 2x + 1</code> (where <code>n = 3, 5, 7, ...</code>), we try to generate new trees from the previous <code>n - 2</code> trees. To do this efficiently:<ol> <li>We loop through each <code>curr_root</code> root tree in <code>self.roots</code> and their corresponded <code>self.leafs</code></li> <li>(Step 2) Add two leaf nodes to any of this root leaf.</li> <li>Use the <code>copyTree</code> function to create a copy of the all tree and then revert the change from step 2. </li> <li>We then hash the new tree using the <code>hashNode</code> function to check for any collision with previously generated trees.</li> <li>If there is no collision (the hash is not in <code>visited</code>), we add the new tree to the <code>result</code> list along with its leaf nodes.</li> <li>Update our <code>self.roots</code> to new <code>result</code></li> </ol> </li> <li>We continue this process until we reach <code>n</code>. Finally, we return the generated trees in <code>self.roots</code></li> </ol> <p>The simulation-based approach works, but it is unnecessarily complex and slow due to the copying of trees and hash computations.</p> <pre><code>class Solution:\ndef hashNode(self, root, index = 1):\nif root is None:\nreturn 0\nresult = index &lt;&lt; 5 + index\nif root.left:\nresult += self.hashNode(root.left, 2*index)\nif root.right:\nresult += self.hashNode(root.right, 2*index + 1)\nreturn result\ndef copyTree(self, source):\nresult = None\nleafs = []\nresult = TreeNode(source.val)\nif source.left:\nresult.left, leafsLeft = self.copyTree(source.left)\nleafs += leafsLeft\nif source.right:\nresult.right, leafsRight = self.copyTree(source.right)\nleafs += leafsRight\nif source.left is None and source.right is None:\nleafs.append(result)\nreturn result, leafs\ndef addLeaf(self):\nresult = []\nvisited = set()\nfor root, leafs in self.roots:\nfor leaf in leafs[::-1]:\nleaf.left = TreeNode(0)\nleaf.right = TreeNode(0)\nnew_root, new_leafs = self.copyTree(root)\nhashN = self.hashNode(new_root)\nif hashN not in visited:\nresult.append((new_root, new_leafs))\nvisited.add(hashN)\nleaf.left = None\nleaf.right = None\nreturn result\ndef allPossibleFBT(self, n: int) -&gt; List[Optional[TreeNode]]:\nif n%2 == 0:\nreturn []\nself.roots = []\nfor i in range(1, n+1, 2):\ntmp = []\nif i == 1:\nroot = TreeNode(0)\ntmp = [(root, [root])]\nself.roots = tmp\ncontinue\ntmp = self.addLeaf()\nself.roots = tmp\nreturn [root for root, _ in self.roots]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%20100-1000/894.%20All%20Possible%20Full%20Binary%20Trees/#minimal", "title": "Minimal", "text": "<p>The simulation approach can be greatly simplified using dynamic programming and memorization to avoid redundant computations.</p> <p>We use the following steps to find all possible full binary trees with <code>n</code> nodes:</p> <ol> <li>If <code>n</code> is even (<code>n % 2 == 0</code>), there are no possible full binary trees, so we return an empty list.</li> <li>If <code>n</code> is 1, there is only one possible full binary tree with a single node having a value of 0. We return this tree as a list containing a single node.</li> <li>For any odd <code>n = 2x + 1</code> (where <code>x</code> is an integer), we recursively find all possible full binary trees for each possible left subtree with nodes <code>i</code> (where <code>i</code> ranges from 1 to <code>n - 1</code> with a step of 2), and the right subtree with nodes <code>n - i - 1</code>. We then combine these left and right subtrees with a root having a value of 0, and add them to the result list.</li> <li>We use memorization to store the results of subproblems in the <code>cache</code> dictionary to avoid redundant computations.</li> </ol> <p>The minimal approach is much more efficient and straightforward, and it accurately finds all possible full binary trees with <code>n</code> nodes, each having a root node with a value of 0. It returns the final list of trees in any order.</p> <pre><code>class Solution:\ndef allPossibleFBT(self, n: int, cache = None) -&gt; List[TreeNode]:\nif cache is None:\ncache = {}\nif n in cache:\nreturn cache[n]\nif n % 2 == 0:\nreturn []\nif n == 1:\ncache[n] = [TreeNode()]\nreturn [TreeNode()]\nres = []\nfor i in range(1, n, 2):\nleft = self.allPossibleFBT(i, cache)\nright = self.allPossibleFBT(n - i - 1, cache)\nfor l in left:\nfor r in right:\nroot = TreeNode(0, l, r)\nres.append(root)\ncache[n] = res\nreturn res\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/", "title": "1125. Smallest Sufficient Team", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/#problem", "title": "Problem", "text": "<p>In a project, you have a list of required skills <code>req_skills</code>, and a list of people. The <code>ith</code> person <code>people[i]</code> contains a list of skills that the person has.</p> <p>Consider a sufficient team: a set of people such that for every required skill in <code>req_skills</code>, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.</p> <ul> <li>For example, <code>team = [0, 1, 3]</code> represents the people with skills <code>people[0]</code>, <code>people[1]</code>, and <code>people[3]</code>.</li> </ul> <p>Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.</p> <p>It is guaranteed an answer exists.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= req_skills.length &lt;= 16</code></li> <li><code>1 &lt;= req_skills[i].length &lt;= 16</code></li> <li><code>req_skills[i]</code> consists of lowercase English letters.</li> <li>All the strings of <code>req_skills</code> are unique.</li> <li><code>1 &lt;= people.length &lt;= 60</code></li> <li><code>0 &lt;= people[i].length &lt;= 16</code></li> <li><code>1 &lt;= people[i][j].length &lt;= 16</code></li> <li><code>people[i][j]</code> consists of lowercase English letters.</li> <li>All the strings of <code>people[i]</code> are unique.</li> <li>Every skill in <code>people[i]</code> is a skill in <code>req_skills</code>.</li> <li>It is guaranteed a sufficient team exists.</li> </ul> <p>Example 1:</p> <pre><code>**Input:** req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"|\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\n**Output:** [0,2]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/#input-handling", "title": "Input handling", "text": "<p>With the provided constrain for input, we can turn input to it\u2019s bit representation. <pre><code>class Solution:\ndef smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -&gt; List[int]:\nwords_dictinary = req_skills.copy()\nwords_dictinary.sort()\nnumber_representation = []\nfor p in people:\ncraft_number = 0\nfor skill in p:\nwords_index = bisect_right(words_dictinary, skill) - 1\ncraft_number += 1 &lt;&lt; words_index\nnumber_representation.append(craft_number)\n</code></pre></p> <p>I debug above code using these to make sure it done right: <pre><code>print (words_dictinary)\nfor i in number_representation:\nprint (bin(i + (1 &lt;&lt; len(words_dictinary)))[3:] )\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/#first-commit-brute-force", "title": "First commit: Brute force", "text": "<p>We try all possible combination way of choosing people. Which start from <code>000..00 -&gt; 1111..11</code> (bit length equal total people)</p> <ul> <li>Every <code>1</code> bit mean we choosing the people in that bit index to the team (which we create a helper function to loop through  <code>bit_1_pos</code>)</li> <li>To check our choosing team is sufficient, We can use or operator <code>|</code> on all skill of chosen people <code>number_representation[index]</code>. If final result return <code>111..11</code> on all <code>req_skills</code> skill (bit length equal total required skill).</li> </ul> <p>Why? Because we only need one people in the team have the correspond <code>req_skills</code>, which equivalent to <code>or operation</code>,</p> <ul> <li>Using utility function <code>bit_count</code> to keep track of how many <code>1</code> bit in the number to help checking/ backtracking worse solution (any total team with is have higher people). Final code:</li> </ul> <p>Here is where I realize read the question wrong, my first thought is that <code>len(people) &lt; 2**16</code>, which make me thing for loop <code>2**16</code> is a good ideal. This code bellow is trash with possible <code>2**60</code> case</p> <pre><code>class Solution:\ndef bit_1_pos(self, number):\nfor pos, c in enumerate`-1]`:\nif c == '1':\nyield pos\ndef smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -&gt; List[int]:\nwords_dictinary = req_skills.copy()\nwords_dictinary.sort()\nnumber_representation = []\nfor p in people:\ncraft_number = 0\nfor skill in p:\nwords_index = bisect_right(words_dictinary, skill) - 1\ncraft_number += 1 &lt;&lt; words_index\nnumber_representation.append(craft_number)\nstart = 0\nlast = (1&lt;&lt;len(people)) -1\nbest = last\nfor possible_combination in range(start, last):\nis_sufficient = 0\nif possible_combination.bit_count() &gt; best.bit_count():\ncontinue\nfor index in self.bit_1_pos(possible_combination):\nis_sufficient = is_sufficient | number_representation[index] # or operation\nif is_sufficient.bit_count() == len(words_dictinary):\nbest = possible_combination\nreturn [i for i in self.bit_1_pos(best)]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/#update-the-backtracking", "title": "Update the backtracking", "text": "<ul> <li><code>possible_combination &lt;= 2**60</code> , which is too large. So I implement a queue to keep the track going on the right direction. Where at least a new skill in push into team with each people added. </li> </ul> Time Submitted Status Runtime Memory Language 07/16/2023 21:02 Time Limit Exceeded N/A N/A python3 <pre><code>class Solution:\ndef bit_1_pos(self, number):\nfor pos, c in enumerate`-1]`:\nif c == '1':\nyield pos\ndef smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -&gt; List[int]:\nwords_dictinary = req_skills.copy()\nwords_dictinary.sort()\nnumber_representation = []\nfor p in people:\ncraft_number = 0\nfor skill in p:\nwords_index = bisect_right(words_dictinary, skill) - 1\ncraft_number += 1 &lt;&lt; words_index\nnumber_representation.append(craft_number)\nstart = 0\nlast = (1 &lt;&lt; len(people)) - 1\nbest = last\nqueue = [(start, 0)]\nvisited = set()\nwhile len(queue) &gt; 0:\npossible_combination, is_sufficient = queue.pop(0)\nvisited.add(possible_combination)\nif possible_combination.bit_count() &gt; best.bit_count():\ncontinue\nif is_sufficient.bit_count() == len(words_dictinary):\nbest = possible_combination\nbreak\nfor index in range(len(people)):\nteam_skill = is_sufficient | number_representation[index]\nif team_skill == is_sufficient:\ncontinue\nteam_member = possible_combination | (1 &lt;&lt; index)\nif team_member in visited:\ncontinue\nvisited.add(team_member)\nqueue.append((team_member, team_skill))\nreturn [i for i in self.bit_1_pos(best)]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/#yank-dynamic-programing", "title": "(Yank) Dynamic programing", "text": "<pre><code>class Solution:\ndef smallestSufficientTeam(self, req_skills: List[str],\npeople: List[List[str]]) -&gt; List[int]:\nn = len(people)\nm = len(req_skills)\nskill_id = dict()\nfor i, skill in enumerate(req_skills):\nskill_id[skill] = i\nskills_mask_of_person = [0] * n\nfor i in range(n):\nfor skill in people[i]:\nskills_mask_of_person[i] |= 1 &lt;&lt; skill_id[skill]\ndp = [(1 &lt;&lt; n) - 1] * (1 &lt;&lt; m)\ndp[0] = 0\nfor skills_mask in range(1, 1 &lt;&lt; m):\nfor i in range(n):\nsmaller_skills_mask = skills_mask &amp; ~skills_mask_of_person[i]\nif smaller_skills_mask != skills_mask:\npeople_mask = dp[smaller_skills_mask] | (1 &lt;&lt; i)\nif people_mask.bit_count() &lt; dp[skills_mask].bit_count():\ndp[skills_mask] = people_mask\nanswer_mask = dp[(1 &lt;&lt; m) - 1]\nans = []\nfor i in range(n):\nif (answer_mask &gt;&gt; i) &amp; 1:\nans.append(i)\nreturn ans\n</code></pre> <p>Bit mark, understandable, <code>skills_mask_of_person</code> is the same as <code>number_representation</code> representation of my previous approach. While to use Dynamic programing, here should be the explanation:</p> <ul> <li>start an array <code>dp</code> with a length of <code>2**len(req_skill)</code> and default value <code>2**len(people) - 1</code>. Which answer question given a needed set <code>req_skill</code> in binary representation, how to chose the minimal teem people possible, also in in binary representation. The worst default oblivious that choosing all people. </li> <li><code>dp[0]</code> = 0, so no one needed to if there is no <code>req_skill</code>.</li> <li>With every possible combination require <code>skills_mask</code> set of skill start from <code>000..00</code> to <code>111..11</code> (length of require skill with the maximum of <code>2**16</code>), update current <code>skills_mask</code> set <code>dp</code> by trying with each person (range from <code>[0..n]</code>):<ul> <li>find a <code>previous_skills_mask</code> that when adding <code>person[i]</code> skill set (which mean adding <code>skills_mask_of_person[i]</code> to  <code>previous_skills_mask</code> we can qualify all skill in <code>skill_masks</code>)</li> <li>after that, try update <code>dp[skill_masks] = dp[previous_skills_mask] add person[i]</code> if it a better team (with lower people) <pre><code>        dp = [(1 &lt;&lt; n) - 1] * (1 &lt;&lt; m)\ndp[0] = 0\nfor skills_mask in range(1, 1 &lt;&lt; m):\nfor i in range(n):\nsmaller_skills_mask = skills_mask &amp; ~skills_mask_of_person[i]\nif smaller_skills_mask != skills_mask:\npeople_mask = dp[smaller_skills_mask] | (1 &lt;&lt; i)\nif people_mask.bit_count() &lt; dp[skills_mask].bit_count():\ndp[skills_mask] = people_mask\nanswer_mask = dp[(1 &lt;&lt; m) - 1]\nans = []\nfor i in range(n):\nif (answer_mask &gt;&gt; i) &amp; 1:\nans.append(i)\n</code></pre></li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/#update-to-dynamic-programing", "title": "Update to Dynamic programing", "text": "<p>Knowing the ideal, here is my re implementation using similar <code>dp</code> approach. Which on my first try isn\u2019t that fast, because of the commended for loop shown here </p> <pre><code>        for needed_skills, curr_best in enumerate(best_team):\nfor index, skill_set in enumerate(number_representation):\n# team_knowed_skill_set = needed_skills\n# for pos in self.bit_1_pos(skill_set):\n#    team_knowed_skill_set = team_knowed_skill_set &amp; ~(1 &lt;&lt; pos)\nteam_knowed_skill_set = needed_skills &amp; ~skill_set\n</code></pre> Time Submitted Status Runtime Memory Language Agro 07/16/2023 12:50 Accepted 8519 ms 18.8 MB python3 Unoptimal 07/16/2023 21:37 Accepted 1650 ms 18.9 MB python3 Remove the for loop <pre><code>class Solution:\ndef bit_1_pos(self, number):\nfor pos, c in enumerate`-1]`:\nif c == '1':\nyield pos\ndef smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -&gt; List[int]:\nwords_dictinary = req_skills.copy()\nwords_dictinary.sort()\nnumber_representation = []\nfor p in people:\ncraft_number = 0\nfor skill in p:\nwords_index = bisect_right(words_dictinary, skill) - 1\ncraft_number += 1 &lt;&lt; words_index\nnumber_representation.append(craft_number)\nall_people = (1&lt;&lt;len(people)) -1\nbest_team = [all_people] * (1 &lt;&lt; len(req_skills))\nbest_team[0] = 0\nfor needed_skills, curr_best in enumerate(best_team):\nfor index, skill_set in enumerate(number_representation):\nteam_knowed_skill_set = needed_skills &amp; ~skill_set\nknowed_best_team = best_team[team_knowed_skill_set]\nif best_team[needed_skills].bit_count() &gt; knowed_best_team.bit_count() +1:\nbest_team[needed_skills] = knowed_best_team | (1 &lt;&lt; index)\nreturn [i for i in self.bit_1_pos(best_team[-1])]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1125.%20Smallest%20Sufficient%20Team/#best-greedy-all-the-way-from-top", "title": "Best. Greedy all the way from top", "text": "<p>This is a very clear code with showing exactly the intention from code alone.</p> <ul> <li>Each time you want to choosing a people. Choose all have the most rare skill and push them in to <code>queue</code>, keeping track of <code>remaining skill</code> and <code>curr_group</code></li> <li>Overall a nice implementation of a BFS with a set of wise define rule.</li> </ul> <pre><code>class Solution:\ndef smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -&gt; List[int]:\nskill_possessor_lookup = [set() for _ in req_skills]\nskill_ID_lookup = {skill: pos for pos, skill in enumerate(req_skills)}\nfor person_id, person in enumerate(people):\nfor skill in person:\nskill_ID = skill_ID_lookup[skill]\nskill_possessor_lookup[skill_ID].add(person_id)\nqueue = deque([(skill_possessor_lookup, [])])\nwhile queue:\ntop_skills, curr_group = queue.popleft()\nrarest_skill_possessors = min(top_skills, key=len)\nfor person_id in rarest_skill_possessors:\nremaining_skills = [possessor for possessor in top_skills if person_id not in possessor]\nif not remaining_skills:\nreturn curr_group + [person_id]\nqueue.append((remaining_skills, curr_group + [person_id]))\n</code></pre> <p>Here is my implementation it again. Here is some take away:</p> <ul> <li>In our first try of burst force backtracking, we only find person that provide some thing to the team (adding at least one more skill). This isn\u2019t enough as we still need to go through many cases.</li> <li>This is where the rarest skill is introduce, adding another this layer of backtrack/greedy. Minimizing the multiple of branch that we need to check on each loop. </li> <li>This implementation showing that a powerful backtracking give a lot of credit on performance of the code.</li> </ul> <pre><code>class Solution:\ndef find_rarest_skill(self, candidates, skill_set, not_needed_skill):\nskill_talent = {}\nfor candidate in candidates:\nfor skill in skill_set[candidate]:\nif skill not in skill_talent:\nskill_talent[skill] = set()\nskill_talent[skill].add(candidate)\nrarest_skill = None\nfor skill in skill_talent:\nif skill in not_needed_skill:\ncontinue\nif rarest_skill is None:\nrarest_skill = skill\nelif len(skill_talent[rarest_skill]) &gt; len(skill_talent[skill]):\nrarest_skill = skill\nreturn rarest_skill, skill_talent[rarest_skill]\ndef smallestSufficientTeam(self, req_skills: List[str],\npeople: List[List[str]]) -&gt; List[int]:\nqueue = [(set(range(len(people))), set())]\nwhile queue:\navailable_people, current_team_skill = queue.pop(0)\nif available_people is None:\nreturn [i for i in len(people)]\nif len(current_team_skill) == len(req_skills):\nreturn list(set(range(len(people))).difference(available_people))\n_, talented_peoples = self.find_rarest_skill(\navailable_people, people, current_team_skill)\nfor candidate in talented_peoples:\nteam_skill = current_team_skill.union(set(people[candidate]))\nremain_people = available_people.copy().remove(candidate)\nqueue.append((remain_people, team_skill))\nif len(team_skill) == len(req_skills):\nqueue = [queue[-1]]\nbreak\nreturn [i for i in len(people)]\n</code></pre> <p>Reimplement my Backtracking code again. Here I not try to find a rarest skill, just chose a not found skill (sub optimal). The final result is way greater nonetheless even comparing to Dynamic programming option </p> Time Submitted Status Runtime Memory Language Argo 07/16/2023 23:06 Accepted 200 ms 23.3 MB python3 Rewirte Backtrack 07/16/2023 20:38 Accepted 61 ms 16.6 MB python3 Rewrite queue <pre><code>class Solution:\ndef bit_1_pos(self, number):\nfor pos, c in enumerate`-1]`:\nif c == '1':\nyield pos\ndef needed_skill(self, number):\ntmp = number\npos = 0\nwhile tmp != 0:\nif tmp % 2 == 1:\ntmp = tmp // 2\npos += 1\nelse:\nbreak\nreturn pos\ndef smallestSufficientTeam(self, req_skills: List[str],\npeople: List[List[str]]) -&gt; List[int]:\nwords_dictinary = req_skills.copy()\nwords_dictinary.sort()\nnumber_representation = []\nfor p in people:\ncraft_number = 0\nfor skill in p:\nwords_index = bisect_right(words_dictinary, skill) - 1\ncraft_number += 1 &lt;&lt; words_index\nnumber_representation.append(craft_number)\nstart = 0\nlast = (1 &lt;&lt; len(people)) - 1\nbest = last\nqueue = [(start, 0)]\nvisited = set()\nwhile len(queue) &gt; 0:\npossible_combination, is_sufficient = queue.pop(0)\nvisited.add(possible_combination)\nif possible_combination.bit_count() &gt; best.bit_count():\ncontinue\nif is_sufficient.bit_count() == len(words_dictinary):\nbest = possible_combination\nbreak\nneeded_skill = self.needed_skill(is_sufficient)\nfor index in range(len(people)):\nif (number_representation[index] &gt;&gt; needed_skill) % 2 == 0:\ncontinue\nteam_skill = is_sufficient | number_representation[index]\nif team_skill == is_sufficient:\ncontinue\nteam_member = possible_combination | (1 &lt;&lt; index)\nif team_member in visited:\ncontinue\nvisited.add(team_member)\nqueue.append((team_member, team_skill))\nreturn [i for i in self.bit_1_pos(best)]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1143.%20Longest%20Common%20Subsequence/", "title": "1143. Longest Common Subsequence", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1143.%20Longest%20Common%20Subsequence/#problem", "title": "Problem", "text": "<p>Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence. If there is no common subsequence, return <code>0</code>.</p> <p>A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p> <ul> <li>For example, <code>\"ace\"</code> is a subsequence of <code>\"abcde\"</code>.</li> </ul> <p>A common subsequence of two strings is a subsequence that is common to both strings.</p> <p>Example 1:</p> <p>Input: <code>text1 = \"abcde\", text2 = \"ace\"</code> Output: <code>3</code> Explanation: <code>The longest common subsequence is \"ace\" and its length is 3.</code></p> <p>Example 2:</p> <p>Input: <code>text1 = \"abc\", text2 = \"abc\"</code> Output: <code>3</code> Explanation: <code>The longest common subsequence is \"abc\" and its length is 3.</code></p> <p>Example 3:</p> <p>Input: <code>text1 = \"abc\", text2 = \"def\"</code> Output: <code>0</code> Explanation: <code>There is no such common subsequence, so the result is 0.</code></p> <p>Constraints:</p> <ul> <li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li> <li><code>text1</code> and <code>text2</code> consist of only lowercase English characters.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1143.%20Longest%20Common%20Subsequence/#solve", "title": "Solve", "text": "<p>A dynamic program problem, which leverage the information of pre-solve value</p> <pre><code>class Solution:\ndef longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:\ndp = [[0]*len(text2) for _ in text1]\nfor i, c1 in enumerate(text1):\nfor j, c2 in enumerate(text2):\npossible_answer = []\nif i &gt; 0:\npossible_answer.append(dp[i-1][j])\nif j &gt; 0:\npossible_answer.append(dp[i][j-1])\nif c1 == c2:\nif i &gt; 0 and j &gt; 0:\npossible_answer.append(dp[i-1][j-1] + 1)\nelse:\npossible_answer.append(1)\nif len(possible_answer) &gt; 0:\ndp[i][j] = max(possible_answer)\nreturn dp[len(text1)-1][len(text2)-1]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1569.%20Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/", "title": "1569. Number of Ways to Reorder Array to Get Same BST", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "tree"]}, {"location": "notes/Leetcode%201000-10000/1569.%20Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/#problem", "title": "Problem", "text": "<p>Given an array <code>nums</code> that represents a permutation of integers from <code>1</code> to <code>n</code>. We are going to construct a binary search tree (BST) by inserting the elements of <code>nums</code> in order into an initially empty BST. Find the number of different ways to reorder <code>nums</code> so that the constructed BST is identical to that formed from the original array <code>nums</code>.</p> <ul> <li>For example, given <code>nums = [2,1,3]</code>, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array <code>[2,3,1]</code> also yields the same BST but <code>[3,2,1]</code> yields a different BST.</li> </ul> <p>Return the number of ways to reorder <code>nums</code> such that the BST formed is identical to the original BST formed from <code>nums</code>.</p> <p>Since the answer may be very large, return it modulo <code>10**9 + 7</code>.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "tree"]}, {"location": "notes/Leetcode%201000-10000/1569.%20Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/#solution", "title": "Solution", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "tree"]}, {"location": "notes/Leetcode%201000-10000/1569.%20Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/#my-sane-approach-dynamic-programming-and-some-minor-math", "title": "My sane approach: Dynamic programming and some minor math", "text": "<p>Cost me so much time, but here is step by step rundown:</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "tree"]}, {"location": "notes/Leetcode%201000-10000/1569.%20Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/#1-set-up-bts-tree-for-better-feel-of-the-problem", "title": "1. Set up BTS tree, for better feel of the problem", "text": "<p>Nothing too fancy here, as the problem told:</p> <p>construct a binary search tree (BST) by inserting the elements of <code>nums</code> in order into an initially empty BST</p> <pre><code>class BinarySearchTree:\ndef __init__(self, value, left = None, right = None):\nself.value = value\nself.left = left\nself.right = right\nself.totalNode = 1\nself.countWayCache = None\nif self.left != None:\nself.totalNode += self.left.totalNode\nif self.right != None:\nself.totalNode += self.right.totalNode\ndef addNode(self, value):\nif self.value &gt; value:\nif self.right == None:\nself.right = BinarySearchTree(value)\nelse:\nself.right.addNode(value)\nif self.value &lt; value:\nif self.left == None:\nself.left = BinarySearchTree(value)\nelse:\nself.left.addNode(value)\nself.totalNode += 1\ndef countWays(self, dp, modulo):\nif self.countWayCache != None:\nreturn self.countWayCache\ntotalWay = 1\nif self.left == None and self.right == None:\nreturn totalWay\nif self.left == None:\nreturn self.right.countWays(dp, modulo)\nif self.right == None:\nreturn self.left.countWays(dp, modulo)\ntotalWay = self.right.countWays(dp, modulo) * self.left.countWays(dp, modulo) * dp[self.left.totalNode][self.right.totalNode] % modulo\nself.countWayCache = totalWay\nreturn totalWay\n</code></pre> <p>As you see, <code>__init__()</code> and <code>addNode(self, value)</code> does exactly what the problem told. Where I try to cache <code>totalNode</code> on the tree and <code>countWayCache</code>  which is the number of different ways to construct the tree for later used as we will want to keep reuse  them to deal with the main problem.</p> <p>Also, I code <code>toDict</code>, <code>toString</code> and <code>interator</code> to debug if I done the BTS implement right <pre><code>class BinarySearchTree:\ndef toDict(self, nestedlevel = None):\nnextNestedLevel = nestedlevel\nif nestedlevel != None:\nnextNestedLevel = nestedlevel - 1\nif nextNestedLevel &lt; 0:\nreturn \"...\"\ndictSeft = {}\ndictSeft[\"value\"] = self.value\nif self.left != None:\ndictSeft[\"left\"] = self.left.toDict(nextNestedLevel)\nif self.right != None:\ndictSeft[\"right\"] = self.right.toDict(nextNestedLevel)\nreturn dictSeft\ndef toString(self, nestedlevel = None, indent = 4):\ndictSeft = self.toDict(nestedlevel)\nstringSeft = json.dumps(dictSeft, indent = indent)\nreturn stringSeft\ndef interator(self): \nnodes = []\nnodes.append(self)\nif self.left != None:\nnodes.append(*self.left.interator())\nif self.right != None:\nnodes.append(*self.right.interator())\nreturn nodes\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "tree"]}, {"location": "notes/Leetcode%201000-10000/1569.%20Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/#implement-countwaydp-modulo-directly-onto-bts-tree", "title": "Implement <code>countWay(dp, modulo)</code> directly onto BTS tree", "text": "<p>Where I try to cache <code>totalNode</code> on the tree and <code>countWayCache</code>  which is the number of different ways to construct the tree for later used as we will want to keep reuse  them to deal with the main problem.</p> <p>This is what I staged before, trying to implement <code>countWay(dp, modulo)</code> is a bit tricky, but by some analyzing we know that:</p> <ol> <li>If we already done calculate <code>countWays</code> of a Tree, we can simply return the cache result</li> <li>If there is neither left nor right node, we can only have 1 way to constructed BST</li> <li>If there is either left or right node, the root node can\u2019t be change, so we can could return <code>left.countWay(dp, modulo)</code> or <code>right.countWay(dp, modulo)</code> node </li> <li>The main focus: When both <code>left</code>, <code>right</code> are available.</li> </ol> <p>Quick reference to what we have pre-calculated variable available for use:</p> <ul> <li><code>left.countWay(dp, modulo)</code> , <code>right.countWay(dp, modulo)</code> as  leaf node will be in the case 2 or 3</li> <li><code>left.totalNode</code> , <code>right.totalNode</code> as we keep tracking of them while crafting the BTS tree</li> <li><code>module</code> is just <code>10**9 + 7</code> as the problem staged </li> <li>What left, is <code>dp</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "tree"]}, {"location": "notes/Leetcode%201000-10000/1569.%20Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST/#what-is-dp", "title": "What is DP ?", "text": "<p>After a lot of paper thinking, I translate this to a new problem: \u201cWith two array A and B with n and m length, count how many way to merge them with out changing their element order (Knowing all element is unique)\u201d.</p> <p>Or similar \u201cWith two string A and B, count how many way to merge them with out changing their character order (Knowing each character is unique)\u201d</p> <p>This could be solving using dynamic programing: <code>dp[i][j]</code> is the number of way to merge an <code>i</code> length array to an <code>j</code> length array with out changing their element order</p> <ol> <li>We always have <code>dp[&lt;any&gt;][0] = dp[0][&lt;any&gt;] = 1</code> as there is only one way to merge an array with 0 length to another </li> <li>We also have <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>. As if we try to add a <code>A[i]</code> or <code>B[j]</code> element into the end of ?? </li> </ol> <pre><code>class BinarySearchTree:\ndef __init__(self, value, left = None, right = None):\nself.value = value\nself.left = left\nself.right = right\nself.totalNode = 1\nself.countWayCache = None\nif self.left != None:\nself.totalNode += self.left.totalNode\nif self.right != None:\nself.totalNode += self.right.totalNode\ndef addNode(self, value):\nif self.value &gt; value:\nif self.right == None:\nself.right = BinarySearchTree(value)\nelse:\nself.right.addNode(value)\nif self.value &lt; value:\nif self.left == None:\nself.left = BinarySearchTree(value)\nelse:\nself.left.addNode(value)\nself.totalNode += 1\ndef countWays(self, dp, modulo):\nif self.countWayCache != None:\nreturn self.countWayCache\ntotalWay = 1\nif self.left == None and self.right == None:\nreturn totalWay\nif self.left == None:\nreturn self.right.countWays(dp, modulo)\nif self.right == None:\nreturn self.left.countWays(dp, modulo)\ntotalWay = self.right.countWays(dp, modulo) * self.left.countWays(dp, modulo) * dp[self.left.totalNode][self.right.totalNode] % modulo\nself.countWayCache = totalWay\nreturn totalWay\nclass Solution:\ndef numOfWays(self, nums: List[int]) -&gt; int:\nMODULO = 10**9 + 7\nroot = None\nfor n in nums:\nif root == None:\nroot = BinarySearchTree(n)\nelse:\nroot.addNode(n)\ndp = [[0]*(len(nums) + 1) for i in range(len(nums) + 1)]\nfor i in range(len(nums)+1):\ndp[i][0] = 1\ndp[0][i] = 1\nfor i in range(1, len(nums)+1):\nfor j in range(1, len(nums)+1):\ndp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MODULO\ntotalWays = root.countWays(dp, MODULO)\nreturn totalWays - 1\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "tree"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/", "title": "1601. Maximum Number of Achievable Transfer Requests", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/#problem", "title": "Problem", "text": "<p>We have <code>n</code> buildings numbered from <code>0</code> to <code>n - 1</code>. Each building has a number of employees. It\u2019s transfer season, and some employees want to change the building they reside in.</p> <p>You are given an array <code>requests</code> where <code>requests[i] = [from_i, to_i]</code> represents an employee\u2019s request to transfer from building <code>from_i</code> to building <code>to_i</code>.</p> <p>All buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if <code>n = 3</code> and two employees are leaving building <code>0</code>, one is leaving building <code>1</code>, and one is leaving building <code>2</code>, there should be two employees moving to building <code>0</code>, one employee moving to building <code>1</code>, and one employee moving to building <code>2</code>.</p> <p>Return the maximum number of achievable requests</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 20</code></li> <li><code>1 &lt;= requests.length &lt;= 16</code></li> <li><code>requests[i].length == 2</code></li> <li><code>0 &lt;= from_i, to_i &lt; n</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/#solution", "title": "Solution", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/#read-the-problem", "title": "Read the problem", "text": "<ul> <li>There is really low number of request and building. So we can try all possible request combination</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/#evaluating", "title": "Evaluating", "text": "<ul> <li>Using a binary array to keep track of which request are served  <code>served = [False] * requests.length</code> , free slot start on each building is <code>[0] * n</code></li> <li>Let say for each request being done, we mark them as <code>True</code>, we then have a combination of <code>2 ** requests.length &lt;= 2 **16</code> or <code>65536</code>  total of possible out come</li> <li>With each one, we can then try and find the total of person in each building, is it all equal to <code>0</code>? Which cost us a total time complexity  <code>O(n) &lt;= 20</code>.</li> <li>If that true, then is could be possible answer and we can update the <code>current_max</code>.</li> <li>Know possible answer <code>current_max</code>, we will only try to check any <code>served</code> where total number of request being served is greater than  <code>current_max</code>;</li> </ul> <p>Which mean time complexity is close to <code>O(n* 2**m) = 20*65536</code> </p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/#get-it-on", "title": "Get it on", "text": "<ul> <li>A binary representation is good enough for <code>served</code> array. We can use a for loop in range <code>[0 .. 2**16]</code>. Every <code>1</code>  position in binary number representation mean request at that position is served </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/#implementation", "title": "Implementation", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/#sane-way", "title": "Sane way", "text": "<pre><code>class Solution:\ndef bit_1_pos(self, number):\nfor pos, c in enumerate`-1]`:\nif c == '1':\nyield pos\ndef maximumRequests(self, n: int, requests: List[List[int]]) -&gt; int:\ncurrent_max = 0\nfor request_served in range(1 &lt;&lt; requests.__len__()):\nbuilding = [0] * n\npos = requests.__len__() - 1\nif request_served.bit_count() &lt;= current_max:\ncontinue\nfor pos in self.bit_1_pos(request_served):\nbuilding[requests[pos][0]] -= 1\nbuilding[requests[pos][1]] += 1\ncheck = True\nfor i in range(n):\nif building[i] != 0:\ncheck = False\nbreak\nif check:\ncurrent_max = request_served.bit_count()\nreturn current_max\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1601.%20Maximum%20Number%20of%20Achievable%20Transfer%20Requests/#leetcode-provided", "title": "Leetcode provided", "text": "<pre><code>class Solution:\ndef maximumRequests(self, n: int, requests: List[List[int]]) -&gt; int:\nanswer = 0\nfor mask in range(1 &lt;&lt; requests.__len__()):\nindegree = [0] * n\npos = requests.__len__() - 1\nbitCount = mask.bit_count()\nif bitCount &lt;= answer:\ncontinue\ncurr = mask\nwhile curr &gt; 0:\nif curr &amp; 1 == 1:\nindegree[requests[pos][0]] -= 1\nindegree[requests[pos][1]] += 1\ncurr &gt;&gt;= 1\npos -= 1\nflag = True\nfor i in range(n):\nif indegree[i] != 0:\nflag = False\nbreak\nif flag:\nanswer = bitCount\nreturn answer\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1615.%20Maximal%20Network%20Rank/", "title": "1615. Maximal Network Rank", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "graph"]}, {"location": "notes/Leetcode%201000-10000/1615.%20Maximal%20Network%20Rank/#problem", "title": "Problem", "text": "<p>There is an infrastructure of <code>n</code> cities with some number of <code>roads</code> connecting these cities. Each <code>roads[i] = [ai, bi]</code> indicates that there is a bidirectional road between cities <code>ai</code> and <code>bi</code>.</p> <p>The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.</p> <p>The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.</p> <p>Given the integer <code>n</code> and the array <code>roads</code>, return the maximal network rank of the entire infrastructure.</p> <p>Example 1:</p> <p></p> <p>Input: n = 4, roads = <code>[[0,1],[0,3],[1,2],[1,3|0,1],[0,3],[1,2],[1,3]]</code> Output: 4 Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.</p> <p>Example 2:</p> <p></p> <p>Input: n = 5, roads = <code>[[0,1],[0,3],[1,2],[1,3],[2,3],[2,4|0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]</code> Output: 5 Explanation: There are 5 roads that are connected to cities 1 or 2.</p> <p>Example 3:</p> <p>Input: n = 8, roads = <code>[[0,1],[1,2],[2,3],[2,4],[5,6],[5,7</code>|0,1],[1,2],[2,3],[2,4],[5,6],[5,7`]] Output: 5 Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.</p> <p>Constraints:</p> <ul> <li><code>2 &lt;= n &lt;= 100</code></li> <li><code>0 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li> <li><code>roads[i].length == 2</code></li> <li><code>0 &lt;= a_i, b_i &lt;= n-1</code></li> <li><code>a_i != b_i</code></li> <li>Each pair of cities has at most one road connecting them.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "graph"]}, {"location": "notes/Leetcode%201000-10000/1615.%20Maximal%20Network%20Rank/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge", "graph"]}, {"location": "notes/Leetcode%201000-10000/1615.%20Maximal%20Network%20Rank/#preprocess-data", "title": "Preprocess data", "text": "<p><code>python</code></p> <p>Consider this <code>&lt;city, road&gt;</code> problem as a graph <code>&lt;node, edge&gt;</code></p> <p>Before hand, we can calculating each node rank. Which define as the total number of out going edge of the node:</p> <p>The <code>roads</code> array is a graph represent in edges array:</p> <ul> <li>Which each connection in graph, we call it a edge <code>(u,v)</code></li> <li>All connection <code>(u,v)</code> of graph is contain in <code>E = roads</code> array</li> </ul> <p>which not that great for most of graph problem. We process it to have a adjacent table <code>adjNode</code> instead:</p> <ul> <li>Each node <code>x</code> in graph have all adjacent node in <code>adjNode[i]</code> array</li> <li>All connection of graph then is contain in  <code>adjNode</code> table</li> </ul> <p>This mean, by creating <code>adjNode</code> from <code>road</code>, we also can get the rank of node <code>x</code> by taking the length of correspond <code>adjNode[x]</code> </p> <pre><code>class Solution:\ndef maximalNetworkRank(self, n: int, roads: List[List[int]]) -&gt; int:\nadjNode = [[] for i in range(n)]\nnodeRank = []\nfor (u,v) in roads:\nadjNode[v].append(u)\nadjNode[u].append(v)\nfor i in range(n):\nnodeRank.append(len(adjNode[i]))\nprint(nodeRank)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "graph"]}, {"location": "notes/Leetcode%201000-10000/1615.%20Maximal%20Network%20Rank/#brute-force-try-all-possible", "title": "Brute force / Try all possible", "text": "<p><code>python</code></p> <p>By talking all the possible combination of 2 node, we can easily calculating the maximum rank needed to be return.</p> <p>The problem specific this:</p> <p>If a road is directly connected to both cities, it is only counted once.</p> <p>So, to calculating a combination rank of 2 node <code>i</code> and <code>j</code>, we need to consider:</p> <ul> <li>If there is a <code>(i,j)</code> edge (we can check it using <code>i in adjNode[j]</code>), it already in <code>nodeRank[i] + nodeRank[j]</code> sum, and need to be reduce by one. </li> <li>Other wise this isn\u2019t needed and <code>nodeRank[i] + nodeRank[j]</code> sum being keep the same</li> </ul> <p>This is function, the trick is that Boolean numeric value is <code>True = 1</code> and <code>False = 0</code>, we can handle the if logic by using this trick in python using an <code>int</code> type cast.</p> <pre><code>possibleMaximal = nodeRank[i] + nodeRank[j] - int(i in adjNode[j])\n</code></pre> <p>This mean: </p> <ul> <li><code>- int(i in adjNode[j]) = -int(True) = -1</code></li> <li><code>- int(i in adjNode[j]) = -int(False) = -0</code></li> </ul> <p>Final implementation:</p> Time Submitted Status Runtime Memory Language 08/18/2023 22:03 Accepted 291 ms 18.1 MB python3 <pre><code>class Solution:\ndef maximalNetworkRank(self, n: int, roads: List[List[int]]) -&gt; int:\nadjNode = [[] for i in range(n)]\nnodeRank = []\nfor (u,v) in roads:\nadjNode[v].append(u)\nadjNode[u].append(v)\nfor i in range(n):\nnodeRank.append(len(adjNode[i]))\nmaximal = 0\nfor i in range(n):\nfor j in range(i+1, n):\npossible = nodeRank[i] + nodeRank[j] - int(i in adjNode[j])\nif maximal &lt; possible:\nmaximal = possible\nreturn maximal\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "graph"]}, {"location": "notes/Leetcode%201000-10000/1615.%20Maximal%20Network%20Rank/#connected-tablematrix-with-brute-force", "title": "Connected table/matrix with brute force", "text": "<p><code>python</code></p> <p>Instead of adjacent table, we could also use Connected table <code>matrix</code>, as with:</p> <ul> <li>With edge <code>(u,v)</code> is in graph, we representing them in a <code>matrix[u,v] = True</code></li> <li>With edge <code>(u,v)</code> isn\u2019t in graph, we representing them in a <code>matrix[u,v] = False</code></li> </ul> <p>This is way nice than previous one, costing <code>O(1)</code> to check if the <code>(u,v)</code> edge is in the graph or not, where we using <code>(i in array)</code> expression, which need to loop through all element in the worst case scenario.</p> <p>While we can use hash map, but it cost a lot more time to allocating that much memory, especially in python.</p> <p>As we have <code>2 &lt;= n &lt;= 100</code> , which mean <code>n</code> is small enough, this Connected table <code>matrix</code> of representation is way more fitting.</p> Time Submitted Status Runtime Memory Language 08/18/2023 22:03 Accepted 291 ms 18.1 MB python3 <pre><code>class Solution:\ndef maximalNetworkRank(self, n: int, roads: List[List[int]]) -&gt; int:\nadjNode = [[False] * n for i in range(n)]\nnodeRank = [0] * n\nfor (u,v) in roads:\nadjNode[u][v] = True\nadjNode[v][u] = True\nnodeRank[u] += 1\nnodeRank[v] += 1\nmaximal = 0\nfor i in range(n):\nfor j in range(i+1, n):\npossible = nodeRank[i] + nodeRank[j] - int(adjNode[i][j])\nif maximal &lt; possible:\nmaximal = possible\nreturn maximal\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "graph"]}, {"location": "notes/Leetcode%201000-10000/1615.%20Maximal%20Network%20Rank/#edge-only-representation-with-sort-binary-search-and-brute-force", "title": "Edge only representation with sort, binary search and brute force", "text": "<p><code>python</code></p> <p>A no one ask for solution, while we reduce the need to preprocessing data. Using just edges need a lot of thing to reduce the time complexity from <code>O(n**4)</code> down to <code>O(n**2 * log(n**2))</code></p> <ul> <li>Quickly check <code>(u,v)</code> in graph</li> <li>Quickly calculating all rank of individual <code>u</code></li> </ul> <p>A possible thing to do is quickly sort <code>roads</code> array, and using binary search to check if any <code>(u,v)</code> in the <code>roads</code> array</p> <p>To standardize <code>(u, v)</code>, as it\u2019s bi-direction, we enforce rule that <code>u &lt; v</code> in all case. So we need to update all roads.</p> <p>This also come with a lot of manual touch to finish like: </p> <ul> <li>Checking if roads is empty, which make our binary search throw error in runtime;</li> <li>Manually loop through all the node to update rank</li> <li>Using special sort that can handle two value comparing <code>(u, v)</code></li> </ul> Time Submitted Status Runtime Memory Language 08/18/2023 22:43 Accepted 478 ms 17.8 MB python3 <pre><code>class Solution:\ndef maximalNetworkRank(self, n: int, roads: List[List[int]]) -&gt; int:\nif len(roads) == 0:\nreturn 0\nrank = [0] * n\nfor i, (u, v) in enumerate(roads):\nif u &gt; v:\nroads[i] = (v, u)\nrank[u] += 1\nrank[v] += 1\ndef sortKey(road):\nu, v = road\nreturn 1000*u + v\nroads.sort(key = sortKey)\ndef search(u,v):\nl = -1\nr = len(roads)\nwhile l &lt; r:\nm = (l + r) // 2\nx, y = roads[m]\nif l == m:\nif l &lt; 0:\nreturn False\nreturn (x == u) and (y == v)\nelif (u &lt; x) or (x == u and v &lt; y):\nr = m\nelse:\nl = m\nreturn False\nmaximal = 0\nfor i in range(n):\nfor j in range(i+1, n):\npossible =  (rank[i] + rank[j]) - int(search(i, j))\nif maximal &lt; possible:\nmaximal = possible\nreturn maximal\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "graph"]}, {"location": "notes/Leetcode%201000-10000/1615.%20Maximal%20Network%20Rank/#edge-only-with-hash-map-brute-force", "title": "Edge only with hash map, brute force", "text": "<p><code>python</code></p> <p>By using hash function, we can easily check if <code>(u,v)</code> in roads in <code>O(1)</code> time, which could be on pair with Connected table/matrix solution.</p> <p>While we can directly convent roads to <code>set()</code> in python, we need to handle case where <code>(u,v)</code> is in road, but <code>(v,u)</code> is not.</p> Time Submitted Status Runtime Memory Language 08/18/2023 22:39 Accepted 307 ms 18.7 MB python3 <pre><code>class Solution:\ndef maximalNetworkRank(self, n: int, roads: List[List[int]]) -&gt; int:\nif len(roads) == 0:\nreturn 0\ncache = set()\nrank = [0] * n\nfor u, v in roads:\nrank[u] += 1\nrank[v] += 1\nif u &gt; v:\ncache.add((v,u))\nelse:\ncache.add((u,v))\nmaximal = 0\nfor i in range(n):\nfor j in range(i+1, n):\npossible =  (rank[i] + rank[j]) - int((i, j) in cache)\nprint(possible, i, j)\nif maximal &lt; possible:\nmaximal = possible\nreturn maximal\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge", "graph"]}, {"location": "notes/Leetcode%201000-10000/1751.%20Maximum%20Number%20of%20Events%20That%20Can%20Be%20Attended%20II/", "title": "1751. Maximum Number of Events That Can Be Attended II", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1751.%20Maximum%20Number%20of%20Events%20That%20Can%20Be%20Attended%20II/#problem", "title": "Problem", "text": "<p>You are given an array of <code>events</code> where <code>events[i] = [startDay_i, endDay_i, value_i]</code>. The <code>ith</code> event starts at <code>startDay_i</code> and ends at <code>endDay_i</code>, and if you attend this event, you will receive a value of <code>value_i</code>. You are also given an integer <code>k</code> which represents the maximum number of events you can attend.</p> <p>You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.</p> <p>Return the maximum sum of values that you can receive by attending events.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= k &lt;= events.length</code></li> <li><code>1 &lt;= k * events.length &lt;= 10**6</code></li> <li><code>1 &lt;= startDay_i &lt;= endDay_i &lt;= 10**9</code></li> <li><code>1 &lt;= valuei &lt;= 10**6</code></li> </ul> <p>Example 1:</p> <p></p> <pre><code>**Input:** events = [[1,2,4],[3,4,3],[2,3,1|1,2,4],[3,4,3],[2,3,1]], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1751.%20Maximum%20Number%20of%20Events%20That%20Can%20Be%20Attended%20II/#solve", "title": "Solve", "text": "<p>My first thought is some dynamic programing that we try to get all possible events instead of having to limit our self with only visit <code>k</code> event. Storing them in a <code>lookup</code> array, I could found a pattern:</p> <ul> <li>Go from first event to the last event that sorted by <code>end</code> value</li> <li>Try to calculating the best total value we can get with each the <code>end</code> value. Because we have a quite large range of <code>endDay_i in  [1..10**9]</code> . So I implement a Binary search and reduce the need to storing <code>[1..10**9]</code> possible <code>end</code> value.<ul> <li>As the end day is inclusive, so we need to find index where <code>key[index-1] &lt; start &lt;= key[index]</code> . Where <code>key = events_end[0..current_event_index]</code></li> </ul> </li> <li>When calculate the best possible total value of event with each <code>lookup[end]</code>. we have either:<ul> <li>(Case 1) Last found best event <code>lookup[end] = lookup[end-1]</code> </li> <li>(Case 2) Choosing current event and best found <code>lookup[end_before]</code> with <code>end_before &lt; start[index]</code> or we can said <code>lookup[end] = value_of_current_event + lookup[start-1]</code> </li> </ul> </li> </ul> <p><code>end-1</code> or <code>start-1</code> here is just for representation, as I try to minimize the total memory for the <code>lookup</code> array by using Binary search instead.</p> <p>Here is first implementation  <pre><code>class Solution:\ndef maxValue(self, events: List[List[int]], k: int) -&gt; int:\ndef sort_key_end(x):\nreturn x[1]\ndef binary_search(arr, value):\nl = -1\nr = len(arr)\nwhile l+1&lt;r:\nm = (l + r) //2\ncurr_val = arr[m]\nif curr_val &lt; value:\nl = m\nelse:\nr = m\nis_found = l &gt; -1\nreturn is_found, l\nevents.sort(key=sort_key_end)\nlookup = []\nkey = []\nfor index, (s, e, v) in enumerate(events):\nlookup.append(v)\nkey.append(e)\nis_found, possible = binary_search(key, s)\nif is_found:\nlookup[index] += lookup[possible]\nif lookup[index] &lt; lookup[index - 1]:\nlookup[index] = lookup[index - 1]\nreturn lookup[len(events)-1]\n</code></pre></p> <p>To check my (without <code>k</code>) implementation, the best match for this solution is 2008. Maximum Earnings From Taxi, the same question without <code>k</code> maximum number of events part but it isn\u2019t inclusive thought, so I have to modify it a bit. </p> <p>To add <code>k</code> into this solution, the best and easiest way is just store lookup by a matrix of <code>n*k</code>, where we add another dimension <code>[0..k]</code> on how much event we have attend. And update function into either:</p> <pre><code>- **(Case 1)** Last found best event `lookup[curr_attend][end] = lookup[curr_attend][end-1]` \n- **(Case 2)** Choosing current event and best found `lookup[end_before]` with `end_before &lt; start[index]` and have `curr_attend-1` total event had attended; or we can said `lookup[curr_attend][end] = value_of_current_event + lookup[curr_attend-1][start-1]`\n</code></pre> <pre><code>class Solution:\ndef maxValue(self, events: List[List[int]], k: int) -&gt; int:\ndef sort_key_end(x):\nreturn x[1]\ndef binary_search(arr, value):\nl = -1\nr = len(arr)\nwhile l+1&lt;r:\nm = (l + r) //2\ncurr_val = arr[m]\nif curr_val &lt; value:\nl = m\nelse:\nr = m\nis_found = l &gt; -1\nreturn is_found, l\nevents.sort(key=sort_key_end)\nlookup = [[] for _ in range(k)]\nkey = []\nfor index, (s, e, v) in enumerate(events):\nkey.append(e)\nis_found, possible = binary_search(key, s)\nfor i in range(k):\nlookup[i].append(v)\nif is_found and i &gt; 0:\nlookup[i][index] += lookup[i-1][possible]\nif lookup[i][index] &lt; lookup[i][index - 1]:\nlookup[i][index] = lookup[i][index - 1]\nreturn lookup[k-1][len(events)-1]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1751.%20Maximum%20Number%20of%20Events%20That%20Can%20Be%20Attended%20II/#optimized", "title": "Optimized:", "text": "<p>We can use bisect instead of Binary searching, which is similar to Leetcode problem 2008. optimal solution. Where <code>bisect_left(key, s)</code> will find the index position of <code>key</code> array where <code>key[bisect_left-1] &lt; s &lt;= key[bisect_left]</code> </p> <pre><code>class Solution:\ndef maxValue(self, events: List[List[int]], k: int) -&gt; int:\ndef sort_key_end(x):\nreturn x[1]\nevents.sort(key=sort_key_end)\nlookup = [[] for _ in range(k)]\nkey = []\nfor index, (s, e, v) in enumerate(events):\nkey.append(e)\nsearch = bisect_left(key, s)\nfor i in range(k):\nlookup[i].append(v)\nif search &gt; 0 and i &gt; 0:\nlookup[i][index] += lookup[i-1][search - 1]\nif lookup[i][index] &lt; lookup[i][index - 1]:\nlookup[i][index] = lookup[i][index - 1]\nreturn lookup[k-1][len(events)-1]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1751.%20Maximum%20Number%20of%20Events%20That%20Can%20Be%20Attended%20II/#best-one-yet", "title": "Best one yet?", "text": "<p>Seem not, here is some thing else, where one try to implement a Python heap and a greedy approach:</p> <ul> <li>Start with the best possible event value till the lowest value.</li> <li><code>Schedule()</code> helper class<ul> <li>This is where we storing all event we had attend (<code>self.events</code> array) and total value of them (<code>self.value</code>). </li> <li>This likely to keep track which set of event we currently chose (similar to our <code>lookup</code> and <code>key</code>  helper array to store needed information dynamic programming ) </li> <li>Each time we try to add a events, we create a new copy of it, so any modify is on a different array and don\u2019t break previous found answer. </li> </ul> </li> <li>Main function store all solve <code>Schedule()</code> object into <code>schedules</code> array<ul> <li>With each <code>curr_event in events</code> we try to either:<ul> <li>Push the event into a know <code>Schedule()</code> solution</li> <li>or Create a new <code>Schedule()</code> solution branch with our <code>events</code>, this case to make sure there is a solution that had/possibly used the <code>curr_event</code> (Even if it can be push out of heap in the end)</li> </ul> </li> <li>There is some try to check and update best possible answer within every schedules update loop (on the fly). Still double check it again (with the last for loop) before return the result <code>best</code> <pre><code>from typing import List\nimport heapq\nclass Schedule:\ndef __init__(self, value=0, events=None):\nself.value = value\nself.events = [] if events is None else events\ndef __lt__(self, other):\nreturn self.value &lt; other.value or self.value == other.value and len(self.events) &gt; len(other.events)\ndef add_event(self, value, k):\nnew_events = self.events.copy()\nnew_value = self.value\nif k &gt; len(new_events):\nnew_events.append(value)\nnew_value += value\nif k == len(new_events):\nheapq.heapify(new_events)\nelif value &gt; new_events[0]:\nnew_value += value - new_events[0]\nheapq.heapreplace(new_events, value)\nreturn Schedule(new_value, new_events)\nclass Solution:\ndef maxValue(self, events: List[List[int]], k: int) -&gt; int:\nif k == 1:\nreturn max(e[2] for e in events)\nevents = sorted(tuple(event) for event in events)\nbest = Schedule()\nschedules = []\nfor start, end, value in events:\nokay = False\nwhile schedules and schedules[0][0] &lt; start:\ne, s = heapq.heappop(schedules)\nheapq.heappush(schedules, (end, s.add_event(value, k)))\nif best &lt; s:\nbest = s\nokay = True\nif not okay:\nheapq.heappush(schedules, (end, best.add_event(value, k)))\nfor e, s in schedules:\nif best &lt; s:\nbest = s\nreturn best.value\n</code></pre></li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1751.%20Maximum%20Number%20of%20Events%20That%20Can%20Be%20Attended%20II/#final-result", "title": "Final result", "text": "Time Submitted Status Runtime Memory Language Agro 07/16/2023 01:02 Accepted 1046 ms 62.7 MB python3 Binary search 07/16/2023 01:01 Accepted 875 ms 62.8 MB python3 Bisect optimized", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/", "title": "1802. Maximum Value at a Given Index in a Bounded Array", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#problem", "title": "Problem", "text": "<p>You are given three positive integers: <code>n</code>, <code>index</code>, and <code>maxSum</code>. You want to construct an array <code>nums</code> (0-indexed) that satisfies the following conditions:</p> <ul> <li><code>nums.length == n</code></li> <li><code>nums[i]</code> is a positive integer where <code>0 &lt;= i &lt; n</code>.</li> <li><code>abs(nums[i] - nums[i+1]) &lt;= 1</code> where <code>0 &lt;= i &lt; n-1</code>.</li> <li>The sum of all the elements of <code>nums</code> does not exceed <code>maxSum</code>.</li> <li><code>nums[index]</code> is maximized.</li> </ul> <p>Return <code>nums[index]</code> of the constructed array.</p> <p>Note that <code>abs(x)</code> equals <code>x</code> if <code>x &gt;= 0</code>, and <code>-x</code> otherwise.</p> <p>Example 1:</p> <p>Input: n = 4, index = 2,  maxSum = 6 Output: 2 Explanation: nums = [1,2,2,1] is one array that satisfies all the conditions. There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].</p> <p>Example 2:</p> <p>Input: n = 6, index = 1,  maxSum = 10 Output: 3</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= maxSum &lt;= 10**9</code></li> <li><code>0 &lt;= index &lt; n</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#solution", "title": "Solution", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#overview-my-sane", "title": "Overview (My sane)", "text": "<p>By the given input, where  <code>nums.length = n &lt;= 10**9</code> , we can be sure that O(log n) is the only way to solve the problem</p> <p>So: Binary search, which and only way. <pre><code>\n</code></pre></p> <p>We define:</p> <ul> <li><code>a...</code> Quickly calculate all elements of numbers does not exceed maxSum</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#overview", "title": "Overview", "text": "<p>As usual, let\u2019s start with the example given in the problem statement. Referring to the figure below, there are several ways to make <code>nums[2]</code> the maximum, as shown in the first two examples. However, once we want a larger <code>nums[2]</code> as <code>3</code>, the sum of the array will certainly be greater than <code>maxSum</code>.</p> <p></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#approach-greedy-binary-search", "title": "Approach: Greedy + Binary Search", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#intuition", "title": "Intuition", "text": "<p>The objective is to maximize <code>nums[index]</code> while ensuring the sum the array does not exceed <code>maxSum</code>, so we can try using a greedy algorithm. In order to maximize <code>nums[index]</code>, we need to ensure that all other values are as small as possible.</p> <p>However, we cannot take the other values to be arbitrarily small. Referring to the two rules given in the problem:</p> <ul> <li>The difference between adjacent numbers cannot be greater than <code>1</code>.</li> <li><code>nums[i]</code> must be positive.</li> </ul> <p>Therefore, the last two examples in the figure below are not valid. In the example in the middle, the difference between adjacent numbers (<code>nums[3]</code> and <code>nums[4]</code>) is greater than <code>1</code>. In the example on the right, the first number is equal to <code>0</code>, which is not allowed.</p> <p>Hence, we need to ensure that <code>nums[i]</code> satisfies these conditions as well.</p> <p></p> <p>Therefore, the straightforward approach is after setting a value for <code>nums[index]</code>, let the numbers to its left decrease one by one from right to left until they reach <code>1</code>. Similarly, the numbers to its right decrease one by one from left to right until they reach <code>1</code>. This way, we can ensure that the total sum of the array is minimized without violating the rules.</p> <p>Next, we need to calculate the sum of the array, which is a purely mathematical problem. Let\u2019s take the numbers to the left of <code>nums[index]</code> as an example. There will be an arithmetic sequence to its left, and (possibly) a consecutive sequence of <code>1</code>s if <code>nums[index]</code> is less than the number of elements to the left. We need to determine the length of the arithmetic sequence based on the relative sizes of <code>index</code> and <code>value</code>.</p> <p>Once we have determined the length of the arithmetic sequence, we can calculate the sum of the sequence using the arithmetic sequence formula:</p> <p><code>sum=(A[1]+A[n])\u22c5n/2</code></p> <p>where <code>A[1]</code> and <code>A[n]</code> are the first and last terms of the sequence respectively, and <code>n</code> is the length of the sequence.</p> <p>Take the following figure as an example:</p> <p></p> <ul> <li> <p>If <code>value &lt;= index</code>, it means in addition to the arithmetic sequence from value to <code>1</code>, there will also be a continuous sequence of <code>1</code>s with length <code>index - value + 1</code>. The sum of all elements on <code>index</code>\u2019s left (including <code>nums[index]</code>) is made up by two parts:</p> <ul> <li>The sum of arithmetic sequence <code>[1, 2, 3, ..., value - 1, value]</code>, which is <code>(value + 1) * value / 2</code>.</li> <li>The sum of sequence of length <code>index - value + 1</code> consisting of all <code>1</code>s, which is <code>index - value + 1</code>.</li> <li> <p>Otherwise, it means there is only one arithmetic sequence on the left side of index, with the first item being <code>value</code> and the last item being <code>value - index</code>, so the sum of all elements on <code>index</code>\u2019s left (including <code>nums[index]</code>) is:</p> </li> <li> <p>The sum of arithmetic sequence <code>[value - index, ..., value - 1, value]</code>, which is <code>(value + value - index) * (index + 1) / 2</code>.</p> </li> </ul> </li> </ul> <p>Similarly, the right side of <code>nums[index]</code> is exactly the same. We need to determine the length of the arithmetic sequence and the length of the continuous subarray of <code>1</code> based on the relative sizes of <code>n - index</code> and <code>value</code>.</p> <p></p> <ul> <li> <p>If <code>value</code> is less than or equal to <code>n - index</code>, it means there is a subarray of length <code>n - index - value</code> consisting of all <code>1</code>s in addition to the arithmetic sequence from <code>value</code> to <code>1</code>. The sum of all elements on <code>index</code>\u2019s right (including <code>nums[index]</code>) is made up by two parts:</p> <ul> <li>The sum of arithmetic sequence <code>[value, value - 1, ..., 2, 1]</code>, which is <code>(value + 1) * value / 2</code>.</li> <li>The sum of sequence of length <code>index - value + 1</code> consisting of all <code>1</code>s, which is <code>n - index - value</code></li> <li> <p>Otherwise, there is only an arithmetic sequence on the right side of index with the first term being <code>value</code> and the last term being <code>value - n + 1 + index</code>, so the sum of all elements on <code>index</code>\u2019s right (including <code>nums[index]</code>) is:</p> </li> <li> <p>The sum of arithmetic sequence <code>[value, value - 1, ..., value - n + 1 + index]</code>, which is <code>(value + value - n + 1 + index) * (n - index) / 2</code>.</p> </li> </ul> </li> </ul> <p>Don\u2019t forget that we have added the actual <code>value</code> at <code>index</code> twice, so we need to subtract the final sum by <code>value</code>.</p> <p>Now that we know how to calculate the array sum given a specific <code>nums[index] = value</code>, the question is how do we maximize <code>value</code>?</p> <p>We can use binary search to find the maximum <code>value</code> that meets the criteria. First, we define a search range <code>[left, right]</code> that ensures the maximum <code>value</code> falls within this range. Next, we perform a binary search within this range. For each boundary value <code>mid</code> that divides the current search space in half, we try whether <code>nums[index] = mid</code> is a feasible value that ensures the sum of the array does not exceed <code>maxSum</code>. If it is valid, we continue searching for a larger <code>mid</code> in the right half of the interval. If it is not feasible, it means that <code>mid</code> is too large, and we need to search for a smaller value in the left half of the interval. In this way, we can halve the search interval at each step, and find the maximum <code>mid</code> that meets the criteria in logarithmic time.  </p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#algorithm", "title": "Algorithm", "text": "<ol> <li>We first need to define a function <code>getSum(index, value)</code> to calculate the minimum sum of the array given <code>nums[index] = value</code>.</li> <li>Initialize the search space <code>[left, right]</code>, set <code>left = 1</code> as it is the minimum possible value, set <code>right = maxSum</code> for it is the maximum possible value.</li> <li>While <code>left &lt; right</code>, get the middle index of the search space as <code>mid = (left + right + 1) / 2</code>, and check if <code>getSum(index, mid) &lt;= maxSum</code>:<ul> <li>If so, it means that <code>nums[index] = mid</code> is a valid value, we can go for the right half by setting <code>left = mid</code>.</li> <li>Otherwise, it means that <code>mid</code> is too large for <code>nums[index]</code>, we shall go for the left half of the searching space by setting <code>right = mid - 1</code>.</li> </ul> </li> <li>Return <code>left</code> once the binary search ends.</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#implementation", "title": "Implementation", "text": "<pre><code>class Solution:\ndef getSum(self, index: int, value: int, n: int) -&gt; int:\ncount = 0\n# On index's left:\n# If value &gt; index, there are index + 1 numbers in the arithmetic sequence:\n# [value - index, ..., value - 1, value].\n# Otherwise, there are value numbers in the arithmetic sequence:\n# [1, 2, ..., value - 1, value], plus a sequence of length (index - value + 1) of 1s. \nif value &gt; index:\ncount += (value + value - index) * (index + 1) // 2\nelse:\ncount += (value + 1) * value // 2 + index - value + 1\n# On index's right:\n# If value &gt;= n - index, there are n - index numbers in the arithmetic sequence:\n# [value, value - 1, ..., value - n + 1 + index].\n# Otherwise, there are value numbers in the arithmetic sequence:\n# [value, value - 1, ..., 1], plus a sequence of length (n - index - value) of 1s. \nif value &gt;= n - index:\ncount += (value + value - n + 1 + index) * (n - index) // 2\nelse:\ncount += (value + 1) * value // 2 + n - index - value\nreturn count - value\ndef maxValue(self, n: int, index: int, maxSum: int) -&gt; int:\nleft, right = 1, maxSum\nwhile left &lt; right:\nmid = (left + right + 1) // 2\nif self.getSum(index, mid, n) &lt;= maxSum:\nleft = mid\nelse:\nright = mid - 1\nreturn left\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/1802.%20Maximum%20Value%20at%20a%20Given%20Index%20in%20a%20Bounded%20Array/#complexity-analysis", "title": "Complexity Analysis", "text": "<ul> <li> <p>Time complexity: O(log(maxSum))</p> <ul> <li> <p>We set the searching space as <code>[1, maxSum]</code>, thus it takes O(log(maxSum)) steps to finish the binary search.</p> </li> <li> <p>At each step, we made some calculations that take O(1) time.</p> </li> </ul> </li> <li> <p>Space complexity: O(1)</p> <ul> <li>Both the binary search and the <code>getSum</code> function take O(1) space.</li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2008.%20Maximum%20Earnings%20From%20Taxi/", "title": "2008. Maximum Earnings From Taxi", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2008.%20Maximum%20Earnings%20From%20Taxi/#problem", "title": "Problem", "text": "<p>There are <code>n</code> points on a road you are driving your taxi on. The <code>n</code> points on the road are labeled from <code>1</code> to <code>n</code> in the direction you are going, and you want to drive from point <code>1</code> to point <code>n</code> to make money by picking up passengers. You cannot change the direction of the taxi.</p> <p>The passengers are represented by a 0-indexed 2D integer array <code>rides</code>, where <code>rides[i] = [starti, endi, tipi]</code> denotes the <code>ith</code> passenger requesting a ride from point <code>starti</code> to point <code>endi</code> who is willing to give a <code>tipi</code> dollar tip.</p> <p>For each passenger <code>i</code> you pick up, you earn <code>endi - starti + tipi</code> dollars. You may only drive at most one passenger at a time.</p> <p>Given <code>n</code> and <code>rides</code>, return the maximum number of dollars you can earn by picking up the passengers optimally.</p> <p>Note: You may drop off a passenger and pick up a different passenger at the same point.</p> <p>Example 1: <pre><code>**Input:** n = 5, rides = [[2,5,4],[1,5,1|2,5,4],[1,5,1]]\n**Output:** 7\n**Explanation:** We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.\n</code></pre></p> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 10**5</code></li> <li><code>1 &lt;= rides.length &lt;= 3 * 10**4</code></li> <li><code>rides[i].length == 3</code></li> <li><code>1 &lt;= start_i &lt; end_i &lt;= n</code></li> <li><code>1 &lt;= tip_i &lt;= 10**5</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2008.%20Maximum%20Earnings%20From%20Taxi/#solve", "title": "Solve", "text": "<p>This need some Dynamic programming</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2008.%20Maximum%20Earnings%20From%20Taxi/#minimize-memory-allocation-solution", "title": "Minimize memory allocation solution", "text": "<ul> <li>Closely related to 1751. Maximum Number of Events That Can Be Attended II, where I use a binary search to stored best found choosing rides/events with each <code>end</code> at position <code>index</code>. Storing it it in a  <code>lookup</code> array, we have either:<ul> <li>(Case 1) Last found best rides array <code>lookup[end] = lookup[end-1]</code> </li> <li>(Case 2) Choosing current ride and best found <code>[..., end]</code> with <code>end &lt; start[index]</code>. <code>lookup[end] = value_of_the_ride + lookup[start-1]</code> </li> </ul> </li> </ul> <p><code>end-1</code> or <code>start-1</code> here is just for representation, as I try to minimize the total memory for the <code>lookup</code> array by using Binary search instead.</p> <ul> <li>Sorting: To get the best result, any possible ride we can take between two ride in (Case 2) need to already process. so we need to sort <code>rides</code> array by <code>end</code> to make sure our calculated in a right order.</li> <li>Storing: With two array <code>key</code>, and <code>lookup</code> which is where we save the current <code>end</code> and total <code>value</code> of the path (now tbh, <code>key</code> isn\u2019t doing that much as it just a better way to get <code>[r[1] for r in rides[:index]]</code>), </li> </ul> <pre><code>class Solution:\ndef maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:\ndef sort_key_end(x):\nreturn x[1]\ndef binary_search(arr, value):\nl = -1\nr = len(arr)\nwhile l+1&lt;r:\nm = (l + r) //2\ncurr_val = arr[m]\nif curr_val &lt;= value:\nl = m\nelse:\nr = m\nis_found = l &gt; -1\nreturn is_found, l\nrides.sort(key=sort_key_end)\nlookup = []\nkey = []\nfor index, (s, e, v) in enumerate(rides):\nlookup.append(e - s + v)\nkey.append(e)\nis_found, possible = binary_search(key, s)\nif is_found:\nlookup[index] += lookup[possible]\nif lookup[index] &lt; lookup[index - 1]:\nlookup[index] = lookup[index - 1]\nreturn lookup[len(rides)-1]\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2008.%20Maximum%20Earnings%20From%20Taxi/#using-hash-map-to-sort-instead", "title": "Using hash map to sort instead", "text": "<p>We can using a hash map with <code>dict()</code> instead for better sorting in O(n) time complexity and O(1) look up too, here is a lazy <code>Crtl + C</code> implementation:</p> <ul> <li>This sorted rides by <code>start</code> instead (which making you need to go backward from <code>end</code> to <code>start</code> instead)</li> <li>The checking parse get all possible (case 2) at current position, find the max one with <code>max(dp[i], dp[e] + d)</code>, after all of that, recheck (case 1) with final update <code>dp[i] = max(dp[i], dp[i + 1])</code> <pre><code>class Solution:\ndef maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:\nrideStartAt = defaultdict(list)\nfor s, e, t in rides:\nrideStartAt[s].append([e, e - s + t])\ndp = [0] * (n + 1)\nfor i in range(n - 1, 0, -1):\nfor e, d in rideStartAt[i]:\ndp[i] = max(dp[i], dp[e] + d)\ndp[i] = max(dp[i], dp[i + 1])\nreturn dp[1]\n</code></pre></li> </ul> <p>Quick rewrite it again, yeah, same thing. <pre><code>from typing import List\nfrom collections import defaultdict\nclass Solution:\ndef maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:\nrideStartAt = defaultdict(list)\nfor start, end, tip in rides:\nrideStartAt[start].append([end, end - start + tip])\nlookup = [0] * (n + 1)\nfor i in range(n - 1, 0, -1):\nfor end, true_value in rideStartAt[i]:\nlookup[i] = max(lookup[i], lookup[end] + true_value)\nlookup[i] = max(lookup[i], lookup[i + 1])\nreturn lookup[1]\n</code></pre></p> <p>We just storing in a normal array instead of using binary search</p> <p>My first implementation is affected by 1751. Maximum Number of Events That Can Be Attended II, the binary search part isn\u2019t necessary and increasing a lot of computed time.</p> <p>Here is implementation my re implementation which <code>lookup</code> is an array with its range is base on <code>n</code> (the worst case it is only <code>[0..10**5]</code>). Which return the Accepted with <code>1550 ms</code> <pre><code>class Solution_2:\ndef maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:\ndef sort_key_end(x):\nreturn x[1]\nrides.sort(key=sort_key_end)\nlookup = [0] * (n + 1)\ncar_pos = 1\nfor s, e, v in rides:\nfor i in range(car_pos, e):\nlookup[i] = lookup[car_pos]\ncar_pos = e\npossible = (e - s + v)\nif s &gt; 0:\npossible += lookup[s]\nlookup[e] = max(lookup[e], lookup[e-1], possible)\nreturn lookup[car_pos]\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2008.%20Maximum%20Earnings%20From%20Taxi/#looking-for-the-best-of-best-implementation", "title": "Looking for the best of best implementation?", "text": "<p>Here is sample <code>1542 ms</code> submission <pre><code>class Solution:\ndef maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:\nrides.sort(key=lambda r: r[1])\ncur = [-1]\ndollars = [0]\nfor st, ed, tip in rides:\ni = bisect_right(cur, st)\nearn = dollars[i - 1] + ed - st + tip\ndollars.append(max(dollars[-1], earn))\ncur.append(ed)\nreturn dollars[-1]\n</code></pre></p> <p>Python isn\u2019t that fast, so anything that you get from standard library will get you quite far on the leader board. <code>bisect_right</code> being use here is a python array helper function that alternate Binary search implementation.</p> <ul> <li>There is a lot of similarity to the first implementation. My retry on rewriting the same function <pre><code>class Solution:\ndef maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:\ndef sort_key_end(x):\nreturn x[1]\nrides.sort(key=sort_key_end)\nkey = [-1]\nlookup = [0]\nfor start, end, tip in rides:\nsearch = bisect_right(key, start)\ntrue_rides_value = lookup[search - 1] + end - start + tip\nlookup.append(max(lookup[-1], true_rides_value))\nkey.append(end)\nreturn lookup[-1]\n</code></pre></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2008.%20Maximum%20Earnings%20From%20Taxi/#final-result", "title": "Final result", "text": "Time Submitted Status Runtime Memory Language Agro 07/15/2023 19:52 Accepted 1566 ms 36.2 MB python3 Best one 07/15/2023 17:46 Accepted 1550 ms 36.3 MB python3 Array 07/15/2023 08:10 Accepted 2043 ms 48.8 MB python3 Binary search 07/15/2023 08:08 Accepted 1962 ms 36.4 MB python3 Dict implement 07/15/2023 08:07 Accepted 2026 ms 36.5 MB python3 First try (Binary search)", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/", "title": "2140. Questions With Brainpower", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/#problem", "title": "Problem", "text": "<p>You are given a 0-indexed 2D integer array <code>questions</code> where <code>questions[i] = [pointsi, brainpoweri]</code>.</p> <p>The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question <code>0</code>) and make a decision whether to solve or skip each question. Solving question <code>i</code> will earn you <code>pointsi</code> points but you will be unable to solve each of the next <code>brainpoweri</code> questions. If you skip question <code>i</code>, you get to make the decision on the next question.</p> <ul> <li>For example, given <code>questions = [[3, 2], [4, 3], [4, 4], [2, 5|3, 2], [4, 3], [4, 4], [2, 5]]</code>:<ul> <li>If question <code>0</code> is solved, you will earn <code>3</code> points but you will be unable to solve questions <code>1</code> and <code>2</code>.</li> <li>If instead, question <code>0</code> is skipped and question <code>1</code> is solved, you will earn <code>4</code> points but you will be unable to solve questions <code>2</code> and <code>3</code>.</li> </ul> </li> </ul> <p>Return the maximum points you can earn for the exam.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= questions.length &lt;= 105</code></li> <li><code>questions[i].length == 2</code></li> <li><code>1 &lt;= pointsi, brainpoweri &lt;= 105</code></li> </ul> <p>Example 1:</p> <pre><code>**Input:** questions = [[3,2],[4,3],[4,4],[2,5|3,2],[4,3],[4,4],[2,5]]\n**Output:** 5\n**Explanation:** The maximum points can be earned by solving questions 0 and 3.\n\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n- Unable to solve questions 1 and 2\n- Solve question 3: Earn 2 points\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/#solve", "title": "Solve", "text": "<p>Info: https://leetcode.com/problems/solving-questions-with-brainpower/</p> <p>This is the one I come up with: <pre><code>class Solution:\ndef mostPoints(self, questions: List[List[int]]) -&gt; int:\nself.n = questions.__len__()\nself.trace = [[0,0] for i in range(self.n)]\ni = 0\nfor v,bp in questions[::-1]:\nif i &gt; 0:\nself.trace[i][0]=max(self.trace[i-1][0], self.trace[i-1][1])\nif i-bp-1&lt;0:\nself.trace[i][1] = v\nelse:\nself.trace[i][1] = v + max(self.trace[i-bp-1][0], self.trace[i-bp-1][1])\ni+= 1\nreturn max(self.trace[self.n-1][0], self.trace[self.n-1][1])\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/#first-look", "title": "First look", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/#problem-analised", "title": "Problem analised", "text": "<p>Giving the problem with the skipping, it get a bit tricky:</p> <ol> <li>Let say you go from the first to last question,<ol> <li>If there is only one question <code>questions[0]</code>, then chose to do the first question <code>questions[0]</code>  will give the most point. We have <code>maxPoint( questions[0] ) = q[0].value</code></li> <li>But if there is 2 question, there will be 2 case: <ol> <li>We want to do the second question, which lead to 2 child case:<ol> <li>We want to do only the second question:<ol> <li>This mean <code>questions[1].value &gt;= question[0].value</code></li> <li><code>questions[0]</code> .brainPower &gt;= 1: which mean if we try to do it, we need to skip at least 1 question, meanning skip the second question <code>questions[1]</code> </li> <li>maxPoint( <code>questions[0..1]</code> ) = q[1].value </li> </ol> </li> <li>We can do both questtion<ol> <li><code>questions[0]</code> .brainPower == 0: which mean if we try to do it, we can still do the second question <code>questions[1]</code> </li> <li>maxPoint( <code>questions[0..1]</code> ) = q[1].value + q[0].value</li> </ol> </li> </ol> </li> <li>We don\u2019t want to do the second question<ol> <li>This mean <code>questions[1]</code> . value &lt; <code>question[0]</code> .value</li> <li><code>questions[0]</code> .brainPower &gt;= 1: which mean if we try to do it, we need to skip at least 1 question, meanning skip the second question <code>questions[1]</code></li> <li>maxPoint( <code>questions[0..1]</code> ) =  q[0].value</li> </ol> </li> </ol> </li> <li>Let keep it going: add the third question, the best point of current could be:<ol> <li>We want to do  the third question<ol> <li>We want to do only the third question<ol> <li>This mean <code>questions[2]</code> . value &gt;= the maxPoint(question[0..1])</li> <li>Also,  <code>questions[i]</code> .brainPower &gt;= 1 + i (i=[0..1]) : which mean if we try to do it, we need to skip the third question <code>questions[2]</code> </li> <li>We could see a recusive approad here</li> </ol> </li> <li>We could do the third question, but we need to find<ol> <li><code>questions[i]</code> .brainPower &lt; 1 + i (i=[0..1]): which mean if we do it, we can still do the third question <code>questions[2]</code> </li> <li>Here, we can see a bad partent:<ol> <li>If we can find a matching <code>questions[i]</code> .brainPower &lt; 1+ i: maxPoint(question[0..i]) still isn\u2019t mean we have used <code>questions[i]</code> in it</li> <li>Which lead to a seperated:<ol> <li>maxPoint(question[0..i]) that use <code>questions[i]</code> and have the corresponding <code>questions[i]</code>.brainPower</li> <li>maxPoint(question[0..i]) that not <code>questions[i]</code> and we need to trace back which is the last <code>question[j]</code> (j != i) being done, and what is it\u2019s corresponding brainPower</li> </ol> </li> <li>This could mean we have to handle traceback/max table for each of there case</li> </ol> </li> </ol> </li> </ol> </li> <li>We skip the third question: Well, which mean we can keep the maxPoint(question[0..1]) of two last question</li> </ol> </li> </ol> </li> <li>This could mean we have a O(n^2) if we not careful to handle the trace back and find the best maxPoint(question[0..i])</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/#first-implementation", "title": "First implementation", "text": "<p>Still, here could be the answer</p> <pre><code>class Solution:\ndef mostPoints(self, questions: List[List[int]]) -&gt; int:\nself.n = questions.__len__()\n# Define trace array for trace back -1 mean we have no traceback; first value is the last question we do when we not do the question [i], second value is when we do the question [i] \nself.trace = [[-1,i] for i in range(self.n)]\n# Define max array to give us a maxPoint table for cache the result instead of calling mostPoint over and over; Simmilar to trace, the first value is when we not do the question [i], second one is when we do the question[i] \nself.max = [[0,0] for i in range(self.n)]\ni = 0\nfor v,bp in questions:\n# Handle the first one\nif i==0:\nself.max[i][0]= 0\nself.max[i][1] = questions[0][0]\nself.trace[i][0] = -1\nself.trace[i][1] = 0\ncontinue\n# find max case\ninnerMax = 0\ninnerTrace = -1\nfor innerIndex in range(i):\nif self.trace[innerIndex][0] != -1:\nif innerMax &lt; self.max[innerIndex][0]:\ninnerMax = self.max[innerIndex][0]\ninnerTrace = self.trace[innerIndex][0\nif innerMax &lt; self.max[innerIndex][0]:\ninnerMax = self.max[innerIndex][0]\ninnerTrace = self.trace[innerIndex][0]\n# TODO............\ni+= 1\nreturn max(self.trace[self.n-1][0], self.trace[self.n-1][1])\n</code></pre> <p>The code it self become too much of a head ache; and also, the double for loop make me feel like there should be a better solution.</p> <p>This is when i revaluate the aproad for better solution and also, fix the mess code above.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/#revaluate", "title": "Revaluate", "text": "<ol> <li>We could go back-ward, doing the last question back to the first question. <ol> <li>This make the brainPower from from skip \u201cahead\u201d infomation problem (Which later information being rely on a lot of trace back info and need all history data for processing) : <code>MaxPoint(question[0..i]) = max(question[i].value + maxPoint(question[0..i-1]) that isn't *require* question[i] to be skip, maxPoint(question[0..i-1]))</code></li> <li>into a skip \u201cbehind\u201d problem (Which we can predicted exact infomation needed): when doing question[i], the maxPoint value after skipping question[i].brainPower will alway be <code>question[i].value + maxPoint([i+question[i].brainPower .. n])</code> without any condition: <code>maxPoint(question[i..n]) = max(question[i].value + maxPoint([i+question[i].brainPower .. n]), maxPoint(question[i+1..n]))</code></li> </ol> </li> <li>Now that more like it; we not need to go and code to finding something weird like <code>that isn't *require* question[i] to be skip</code></li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/#recusive-approad", "title": "Recusive approad", "text": "<pre><code>class Solution:\ndef mostPoints(self, questions: List[List[int]]) -&gt; int:\nif questions.__len__() == 0:\nreturn 0\nn = questions.__len__()\nv = questions[0][0]\nbp = questions[0][1]\nreturn max(v + self.mostPoints(questions[bp+1:n]), self.mostPoints( questions[1:n]))\n</code></pre> <p>quite slow tho; also, this is when i learn about <code>@cache</code> in python; it can\u2019t be use for List type, so just global the question infomation and instead using index value as parameter. Here is a updated code</p> <pre><code>class Solution:\n@cache\ndef maxPoints(self, x):\nif x&gt;=self.n:\nreturn 0\nv = self.questions[x][0]\nbp = self.questions[x][1]\nreturn max(v + self.maxPoints(x+bp+1), self.maxPoints(x+1))\ndef mostPoints(self, questions: List[List[int]]) -&gt; int:\nself.n = questions.__len__()\nself.questions = questions\nreturn maxPoints(0)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2140.%20Questions%20With%20Brainpower/#dynamic-approad", "title": "Dynamic approad", "text": "<p>Yeah, just do it at this point; These should be better to understand than my first submit</p> <pre><code>class Solution:\ndef mostPoints(self, questions: List[List[int]]) -&gt; int:\nn = questions.__len__()\nmaxTable = [0]*n\nmaxTable[n-1] = questions[n-1][0]\ni = n-2\nfor v, bp in questions[::-1]:\nif i+bp+1 &lt; n:\nv += maxTable[i+bp+1] \nmaxTable[i] = max(v, maxTable[i+1])\ni -= 1\nreturn maxTable[0]\n</code></pre> <ol> <li>The first submit code [i] value will be separate if I do it or not</li> <li>I using hard code to separate the len = 1 (which turn into an if statement inside the for loop in the first submit code)</li> <li>Invert the for loop index value from n down to 1; instead couting up 1 to n like in the first submit code.</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2141.%20Maximum%20Running%20Time%20of%20N%20Computers/", "title": "2141. Maximum Running Time of N Computers", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2141.%20Maximum%20Running%20Time%20of%20N%20Computers/#problem", "title": "Problem", "text": "<p>You have <code>n</code> computers. You are given the integer <code>n</code> and a 0-indexed integer array <code>batteries</code> where the <code>ith</code> battery can run a computer for <code>batteries[i]</code> minutes. You are interested in running all <code>n</code> computers simultaneously using the given batteries.</p> <p>Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.</p> <p>Note that the batteries cannot be recharged.</p> <p>Return the maximum number of minutes you can run all the <code>n</code> computers simultaneously.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2141.%20Maximum%20Running%20Time%20of%20N%20Computers/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2141.%20Maximum%20Running%20Time%20of%20N%20Computers/#first-implementation-simulation", "title": "First implementation - Simulation", "text": "<pre><code>class Solution:\ndef maxRunTime(self, n: int, batteries: List[int]) -&gt; int:\nif n == len(batteries):\nreturn min(batteries)\ntime = 0\nwhile len(batteries) &gt;= n:\nbatteries.sort(reverse = True)\nrunOut = []\nfor i in range(n):\nbatteries[i] = batteries[i] - 1\nif batteries[i] == 0:\nrunOut.append(i)\nfor i in runOut[::-1]:\nbatteries.pop(i)\ntime += 1\nreturn time\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/", "title": "2328. Number of Increasing Paths in a Grid", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/#problem", "title": "Problem", "text": "<p>You are given an <code>m x n</code> integer matrix <code>grid</code>, where you can move from a cell to any adjacent cell in all <code>4</code> directions.</p> <p>Return the number of strictly increasing paths in the grid such that you can start from any cell and end at any cell. Since the answer may be very large, return it modulo <code>109 + 7</code>.</p> <p>Two paths are considered different if they do not have exactly the same sequence of visited cells.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/#solution", "title": "Solution", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/#overview", "title": "Overview", "text": "<ul> <li>A cell itself is also a valid path, so each cell in the grid stands for a unique path.</li> <li>The path must be strictly increasing, so the paths colored in red are invalid.</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/#approach-1-sorting-dp", "title": "Approach 1: Sorting + DP.", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/#intuition", "title": "Intuition", "text": "<p>Let\u2019s build an auxiliary array <code>dp</code> of the same size as <code>grid</code> to represent the number of paths that end at each cell. Initially, the value of each <code>dp[i][j]</code> cell is <code>1</code>, which stands for the path made by <code>grid[i][j]</code> cell itself.</p> <p>Then, for each cell <code>grid[i][j]</code>, we need to look for its neighbor cells in 4 directions, if there exists a neighbor cell (let\u2019s say <code>grid[i + 1][j]</code>) that is larger than <code>grid[i][j]</code>, it means every path that ends at <code>grid[i][j]</code> can be extended to <code>grid[i + 1][j]</code>. Therefore, the number of paths ending at <code>grid[i + 1][j]</code> should be incremented by <code>grid[i][j]</code>.</p> <p>However, if we traverse all cells by arbitrary order, we might need many repeated updates, as described below.</p> <p></p> <p>It implies that we should iterate over all cells by value. If we sort these cells by value, then traverse over them from the smallest. This ensures that the number of paths ending at each cell in <code>dp</code> is updated only once.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/#algorithm", "title": "Algorithm", "text": "<ol> <li>Initialize <code>dp</code>, a 2-d array of the same size as <code>grid</code>, and set every value as <code>1</code>.</li> <li>Sort all cells by value and iterate over the sorted cells.</li> <li>For each cell <code>grid[i][j]</code>, check its 4-direction neighbor cells, if a neighbor cell <code>grid[curr_i][curr_j]</code> has a larger value, then increment <code>dp[curr_i][curr_j]</code> by <code>dp[i][j]</code>.</li> <li>Return the sum of all cells of <code>dp</code> when the iteration ends.</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/#implementation", "title": "Implementation", "text": "<pre><code>class Solution:\ndef countPaths(self, grid: List[List[int]]) -&gt; int:\nm, n = len(grid), len(grid[0])\nmod = 10 ** 9 + 7\ndirections = [[0, 1], [0, -1], [1, 0], [-1, 0|0, 1], [0, -1], [1, 0], [-1, 0]]\n# Initialize dp, 1 stands for the path made by a cell itself.\ndp = [[1] * n for _ in range(m)]\n# Sort all cells by value.\ncell_list = [[i, j] for i in range(m) for j in range(n)]\ncell_list.sort(key = lambda x: grid[x[0]][x[1]])\n# Iterate over the sorted cells, for each cell grid[i][j]: \nfor i, j in cell_list:\n# Check its four neighbor cells, if a neighbor cell grid[curr_i][curr_j] has a\n# larger value, increment dp[curr_i][curr_j] by dp[i][j]\nfor di, dj in directions:\ncurr_i, curr_j = i + di, j + dj\nif 0 &lt;= curr_i &lt; m and 0 &lt;= curr_j &lt; n and grid[curr_i][curr_j] &gt; grid[i][j]:\ndp[curr_i][curr_j] += dp[i][j]\ndp[curr_i][curr_j] %= mod\n# Sum over dp[i][j].\nreturn sum(sum(row) % mod for row in dp) % mod\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2328.%20Number%20of%20Increasing%20Paths%20in%20a%20Grid/#complexity-analysis", "title": "Complexity Analysis", "text": "<p>Let <code>m\u00d7n</code> be the size of the input array <code>grid</code>.</p> <ol> <li> <p>Time complexity: <code>O(m\u22c5n\u22c5log(m\u22c5n))</code></p> <ul> <li>We sort all cells by value, it takes <code>O(klogk)</code> to sort an array of size <code>O(k)</code>, so it takes <code>O(m\u22c5n\u22c5log(m\u22c5n))</code> time.</li> <li>The iteration over sorted cells has <code>O(m\u22c5n)</code> steps, each step consists of checking at most four neighbor cells, thus it takes <code>O(m\u22c5n)</code> time.</li> <li>For initialization of <code>dp</code> and the calculation of <code>answer</code> we iterate over all the cells of the <code>dp</code> array, which also takes <code>O(m\u22c5n)</code> time.</li> <li>To sum up, the overall time complexity is <code>O(m\u22c5n\u22c5log(m\u22c5n))</code>.</li> </ul> </li> <li> <p>Space complexity: <code>O(m\u22c5n)</code></p> <ul> <li>We used two arrays, <code>cellList</code> and <code>dp</code>, they both contain <code>O(m\u22c5n)</code> elements.</li> </ul> </li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/", "title": "2352. Equal Row and Column Pairs   solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#problem", "title": "Problem", "text": "<p>Given a 0-indexed <code>n x n</code> integer matrix <code>grid</code>, return the number of pairs <code>(ri, cj)</code> such that row <code>ri</code> and column <code>cj</code> are equal.</p> <p>A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).</p> <p>Example 1: <pre><code>**Input:** grid = [[3,2,1],[1,7,6],[2,7,7|3,2,1],[1,7,6],[2,7,7]]\n**Output:** 1\n**Explanation:** There is 1 equal row and column pair:\n\n- (Row 2, Column 1): [2,7,7]\n</code></pre> Example 2: <pre><code>**Input:** grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2|3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]\n**Output:** 3\n**Explanation:** There are 3 equal row and column pairs:\n- (Row 0, Column 0): [3,1,2,2]\n- (Row 2, Column 2): [2,4,2,2]\n- (Row 3, Column 2): [2,4,2,2]\n</code></pre> Constraints:</p> <ul> <li><code>n == grid.length == grid[i].length</code></li> <li><code>1 &lt;= n &lt;= 200</code></li> <li><code>1 &lt;= grid[i][j] &lt;= 105</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#solution", "title": "Solution", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#my-hash-solution", "title": "My - Hash solution", "text": "<p>Using hash function to quickly compare column and array. Define </p> <ul> <li>The <code>getColumns()</code> to get all column in the given grid, costing O(n^2) time</li> <li>Calculate and storing hash array of all row and column, costing O(n) time</li> <li>Map each <code>&lt;hash, index&gt;</code> for quickly reference all row and column sharing a same hash, costing O(n) time</li> </ul> <pre><code>class Solution:\ndef getColumns(self,grid):\ncolumns = []\ntotalRow = totalColumn = len(grid)\nfor c in range(totalColumn):\ntmp = []\nfor r in range(totalRow):\ntmp.append(grid[r][c])\ncolumns.append(tmp)\nreturn columns\ndef arrayHash(self, array):\nreturn tuple(array).__hash__()\ndef equalPairs(self, grid: List[List[int]]) -&gt; int:\nrowsHash = [self.arrayHash(r) for r in grid]\ncolumnsHash = [self.arrayHash(c) for c in self.getColumns(grid)]\nhashDict = {}\npairEquadArray = []\nfor rowID, rh in enumerate(rowsHash):\nif not rh in hashDict:\nhashDict[rh] = []\nhashDict[rh].append(rowID)\nfor columnID, ch in enumerate(columnsHash):\nif not ch in hashDict:\ncontinue\nfor rowID in hashDict[ch]:\npairEquadArray.append([rowID, columnID])\nreturn pairEquadArray.__len__()\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#approach-1-brute-force", "title": "Approach 1: Brute Force", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#intuition", "title": "Intuition", "text": "<p>Let\u2019s start with the most intuitive approach, which is brute force. Since we need to find the number of matching rows and columns, we traverse through every possible combination of rows and columns (row R, col C) and check if all elements at the same position in R and C are equal to each other.</p> <p></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#algorithm", "title": "Algorithm", "text": "<ol> <li> <p>Initialize <code>count</code> to 0.</p> </li> <li> <p>Iterate over each row R in <code>grid</code>.</p> </li> <li> <p>For each row, iterate over each column C in <code>grid</code>.</p> </li> <li> <p>Check if row R equals column C by comparing each element at the same index <code>i</code> in both R and C. If row R equals column C, increment <code>count</code> by 1.</p> </li> <li> <p>Return <code>count</code> after iterating over all row-column pairs.</p> </li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#implementation", "title": "Implementation", "text": "<pre><code>class Solution:\ndef equalPairs(self, grid: List[List[int]]) -&gt; int:\ncount = 0\nn = len(grid)\n# Check each row r against each column c.\nfor r in range(n):\nfor c in range(n):\nmatch = True\n# Iterate over row r and column c.\nfor i in range(n):\nif grid[r][i] != grid[i][c]:\nmatch = False\nbreak\n# If row r equals column c, increment count by 1.\ncount += int(match)\nreturn count\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#complexity-analysis", "title": "Complexity Analysis", "text": "<p>Let n\u00d7n be the size of <code>grid</code>.</p> <ul> <li> <p>Time complexity: O(n^3)</p> <ul> <li>There are a total of O(n^2) pairs when iterating over each row R and column C. Traversing each element in R and C takes O(n) time.</li> <li> <p>Space complexity: O(1)</p> </li> <li> <p>we are use constant amount of extra space to store the answer <code>count</code>.</p> </li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#approach-2-hash-map", "title": "Approach 2: Hash Map", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#intuition_1", "title": "Intuition", "text": "<p>The brute force approach involves comparing each row R with each column C, resulting in a time complexity of O(n3). However, we can optimize this approach by using a hash map data structure to reduce the time complexity.</p> <p>In this approach, we can consider each row as the key and store it in a hash map. The corresponding value for each key would be the frequency of that row in the grid. Then, we can traverse through each column of the grid and increment the answer by the frequency of the equivalent row in the hash map.</p> <p></p> <p>Taking the example shown in the picture, we traverse each row of the grid and use it as a key and record its frequency in a hash map.</p> <p>Note that arrays cannot typically be used as keys, so we need to convert them into equivalent hashable objects, such as tuples in Python or strings in Java. The converted object still maintains a one-to-one correspondence with the original object, allowing us to record the frequency of the original array by hash map.</p> <p></p> <p>Next, we traverse through each column of the grid, convert the array of each column into a hashable object of the same type as the previous keys, and then retrieve its number of occurrences in the hash map. This provides us with the number of rows in the grid that are equal to this column.</p> <p></p> <p>We found that <code>[3,1,2,2]</code> appears once and <code>[2,4,2,2]</code> appears twice. Therefore, the final answer is 3.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#algorithm_1", "title": "Algorithm", "text": "<ol> <li> <p>Create an empty hash map <code>row_counter</code> and set <code>count</code> to 0.</p> </li> <li> <p>For each row <code>row</code> in the grid, convert it into an equivalent hashable object and use it as a key to the <code>row_counter</code>. Increment the value of the corresponding key by 1.</p> </li> <li> <p>For each column in the grid, convert it into the same type of hashable object and check if it appears in the <code>row_counter</code>. If it does, increment <code>count</code> by the frequency.</p> </li> <li> <p>Return the answer <code>count</code>.</p> </li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#implementation_1", "title": "Implementation", "text": "<pre><code>class Solution:\ndef equalPairs(self, grid: List[List[int]]) -&gt; int:\ncount = 0\nn = len(grid)\n# Keep track of the frequency of each row.\nrow_counter = collections.Counter(tuple(row) for row in grid)\n# Add up the frequency of each column in map.\nfor c in range(n):\ncol = [grid[i][c] for i in range(n)]\ncount += row_counter[tuple(col)]\nreturn count\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#complexity-analysis_1", "title": "Complexity Analysis", "text": "<p>Let n\u00d7n be the size of <code>grid</code>.</p> <ul> <li> <p>Time complexity: O(n^2)</p> <ul> <li>We iterate over each row and column only once, converting one array of length n into a hash table object takes O(n) time.</li> <li>Operations like adding or checking on hash map take O(1) time.</li> <li> <p>Space complexity: O(n^2)</p> </li> <li> <p>We store each row of the grid in the hash map, in the worst-case scenario, <code>row_counter</code> might contains n distinct rows of length n.</p> </li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#approach-3-trie", "title": "Approach 3: Trie", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#intuition_2", "title": "Intuition", "text": "<p>If you are not familiar with trie, please refer to this problem Implement Trie. In this article, we will focus on the usage of trie rather than on implementation details.</p> <p>Trie, also known as prefix tree, is a tree-like data structure which is often used to store strings (In this problem, we store arrays of integers instead of strings). The key advantage of trie is its efficient search time, which can be achieved in O(n) time where n is the length of the array. Trie works by storing each element of the array in a separate node, and each node has an array of children representing the possible characters that can follow the current element.</p> <p>Depending on the requirements, we can modify the original trie by adding more elements. In this problem, we need to determine the frequency of each row, so we add a variable called <code>count</code> into the trie node. To construct the trie, we traverse each row of the grid and insert the row into the trie by traversing down the trie based on each element in the row. At the end of the row, we increment <code>count</code> associated with the last node in the trie to indicate that we have recorded the occurrence of this row.</p> <p></p> <p>To count the number of pairs of equal row and column, we traverse through each column <code>col_array</code> of the grid and search for it in the trie by traversing down the trie based on each element in <code>col_array</code>. If we reach the end of the array and encounter a node, we know that there are rows in <code>grid</code> equal to this column, and we can increment the answer by the value of <code>count</code> of this node.</p> <p></p> <p>In the above image, we see that the value of <code>count</code> of the last node is 1, indicating that there is one row in the grid that matches the column <code>col_array</code> we are searching for.</p> <p>If we can\u2019t find a node associated with current value in <code>col_array</code>, it means that there is no such array stored in the trie that is equal to <code>col_array</code>, so we stop the search.</p> <p></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#algorithm_2", "title": "Algorithm", "text": "<ol> <li> <p>Initialize a empty trie <code>my_trie</code> and set <code>count</code> as 0.</p> </li> <li> <p>Insert each row of <code>grid</code> into <code>my_trie</code>.</p> </li> <li> <p>Search for each column <code>col_array</code> in the trie.</p> </li> <li> <p>If the <code>col_array</code> is found in the trie, add the frequency count to the <code>count</code>.</p> </li> <li> <p>Return the answer <code>count</code>.</p> </li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#implementation_2", "title": "Implementation", "text": "<pre><code>class TrieNode:\ndef __init__(self):\nself.count = 0\nself.children = {}\nclass Trie:\ndef __init__(self):\nself.trie = TrieNode()\ndef insert(self, array):\nmy_trie = self.trie\nfor a in array:\nif a not in my_trie.children:\nmy_trie.children[a] = TrieNode()\nmy_trie = my_trie.children[a] \nmy_trie.count += 1\ndef search(self, array):\nmy_trie = self.trie\nfor a in array:\nif a in my_trie.children:\nmy_trie = my_trie.children[a]\nelse:\nreturn 0\nreturn my_trie.count\nclass Solution:\ndef equalPairs(self, grid: List[List[int]]) -&gt; int:\nmy_trie = Trie()\ncount = 0\nn = len(grid)\nfor row in grid:\nmy_trie.insert(row)\nfor c in range(n):\ncol_array = [grid[i][c] for i in range(n)]\ncount += my_trie.search(col_array)\nreturn count    \n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2352.%20Equal%20Row%20and%20Column%20Pairs%20-%20solve/#complexity-analysis_2", "title": "Complexity Analysis", "text": "<p>Let n\u00d7n be the size of <code>grid</code>.</p> <ul> <li> <p>Time complexity: O(n^2)</p> <ul> <li> <p>The length of input rows is fixed to n, the time complexity of building a trie for n rows is O(n^2), since we need to traverse each element in the array to insert it into the trie.</p> </li> <li> <p>The time complexity of search an array of length n is O(n) as we need to iterate over the entire array in the worst-case scenario.</p> </li> </ul> </li> <li> <p>Space complexity: O(n^2)</p> <ul> <li>In a trie, each node represents a number. Therefore, for n rows of length n, the trie has n^2 nodes in the worst-case scenario.</li> </ul> </li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/", "title": "2369. Check if There is a Valid Partition For The Array", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/#problem", "title": "Problem", "text": "<p>You are given a 0-indexed integer array <code>nums</code>. You have to partition the array into one or more contiguous subarrays.</p> <p>We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions: ^97b248</p> <ol> <li>The subarray consists of exactly <code>2</code> equal elements. For example, the subarray <code>[2,2]</code> is good.</li> <li>The subarray consists of exactly <code>3</code> equal elements. For example, the subarray <code>[4,4,4]</code> is good.</li> <li>The subarray consists of exactly <code>3</code> consecutive increasing elements, that is, the difference between adjacent elements is <code>1</code>. For example, the subarray <code>[3,4,5]</code> is good, but the subarray <code>[1,3,5]</code> is not.</li> </ol> <p>Return <code>true</code> if the array has at least one valid partition. Otherwise, return <code>false</code>.</p> <p>Example 1:</p> <p>Input: nums = [4,4,4,5,6] Output: true Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6]. This partition is valid, so we return true.</p> <p>Example 2:</p> <p>Input: nums = [1,1,1,2] Output: false Explanation: There is no valid partition for this array.</p> <p>Constraints:</p> <ul> <li><code>2 &lt;= nums.length &lt;= 105</code></li> <li><code>1 &lt;= nums[i] &lt;= 106</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/#solve", "title": "Solve", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/#recursion-check", "title": "Recursion check", "text": "<p>This is a TLE solution</p> <p>It share a lot of similarity with 131. Palindrome Partitioning, where I:</p> <ul> <li>Preprocess the Partition, to create a function <code>isContiguousSubarrays(x, y)</code> that quickly check  any sub arrays start at index <code>x</code> and end at index <code>y</code> from <code>nums</code> array is contiguous. This can be achieve by simulating 3 of the rules</li> <li>After that, a helper recursion is there to partition the array one by one, using try and error burst force process</li> </ul> Time Submitted Status Runtime Memory Language 08/13/2023 15:23 Time Limit Exceeded N/A N/A python3 <pre><code>class Solution:\ndef validPartition(self, nums: List[int]) -&gt; bool:\nlast = None\nprev = None\ncurr = None\nn = len(nums)\n# This is inclusive\ndef isContiguousSubarrays(x, y):\n# enum 0 ==&gt; 2 member; enum  1 == 3 member\nif not (x &lt; y &lt; n):\nreturn False\nsize = y - x - 1\nreturn contiguousPartition[size][x]\ncontiguousPartition = [[],[|],[]]\nfor i in nums:\nlast = prev\nprev = curr\ncurr = i\nif prev is not None:\ntype1 = (curr == prev)\ncontiguousPartition[0].append(type1)\nif last is not None:\ntype2 = (last == curr == prev)\ntype3 = (abs(last - prev) == abs(curr - prev) == 1)\ncontiguousPartition[1].append(type2 or type3)\n# This sould be inclusive, also, y is not needed and just there for sanity \ndef helper(x, y):\nif (x - 1 == y):\nreturn True\nif isContiguousSubarrays(x, x + 1):\nif helper(x + 2, y):\nreturn True\nif isContiguousSubarrays(x, x + 2):\nif helper(x + 3, y):\nreturn True\nreturn False\nreturn helper(0, n-1)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/#recursion-caching", "title": "Recursion + Caching", "text": "<ul> <li>We only need to cache the <code>helper</code> function, because y not change, so an array storing data base on <code>x</code> is enough. </li> <li>Also, the third rule is <code>True</code> for <code>[1,2,3]</code>, but not for <code>[3,2,1]</code>. As it is increasing elements, which I need to modify <code>type3 = (abs(last - prev) == abs(curr - prev) == 1)</code> to pass the test <ol> <li>The subarray consists of exactly <code>3</code> consecutive increasing elements, that is, the difference between adjacent elements is <code>1</code>. For example, the subarray <code>[3,4,5]</code> is good, but the subarray <code>[1,3,5]</code> is not.</li> </ol> </li> </ul> <p>This does the job to finish the problem</p> Time Submitted Status Runtime Memory Language 08/13/2023 15:36 Accepted 1031 ms 84.1 MB python3 <pre><code>class Solution:\ndef validPartition(self, nums: List[int]) -&gt; bool:\nlast = None\nprev = None\ncurr = None\nn = len(nums)\n# This is inclusive\ndef isContiguousSubarrays(x, y):\n# enum 0 ==&gt; 2 member; enum  1 == 3 member\nif not (x &lt; y &lt; n):\nreturn False\nsize = y - x - 1\nreturn contiguousPartition[size][x]\ncontiguousPartition = [[],[|],[]]\nfor i in nums:\nlast = prev\nprev = curr\ncurr = i\nif prev is not None:\ntype1 = (curr == prev)\ncontiguousPartition[0].append(type1)\nif last is not None:\ntype2 = (last == curr == prev)\ntype3 = (prev - last == curr - prev == 1)\ncontiguousPartition[1].append(type2 or type3)\ncache = [0] * n\n# This sould be inclusive, also, y is not needed and just there for sanity \ndef helper(x, y):\nif (x - 1 == y):\nreturn True\nif cache[x] != 0:\nreturn cache[x] &gt; 0\nif isContiguousSubarrays(x, x + 1):\nif helper(x + 2, y):\ncache[x] = 1\nreturn True\nif isContiguousSubarrays(x, x + 2):\nif helper(x + 3, y):\ncache[x] = 1\nreturn True\ncache[x] = -1\nreturn False\nreturn helper(0, n-1)\n</code></pre> <p>Still, this isn\u2019t ideal, we can do a O(n) loop which is even better base on this formula <pre><code>isValid[x] = isValid[x-2] &amp;&amp; isContiguousSubarrays(x-1, x) \n            || isValid[x-3] &amp;&amp; isContiguousSubarrays(x-2, x);\n</code></pre></p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/#re-implementation-in-c-recursion-caching", "title": "Re-implementation in <code>c</code> : Recursion + Caching", "text": "<p>Optimize seem better to use a compile language with a hard type system.</p> <p>Nothing much to say except I encounter a bug with the implementation, that is:</p> <ul> <li>When declare a global variable, if you try to have multiple input from console, the global variable isn\u2019t being reset (keep the last input value).</li> <li>This make my cache <code>isValid</code> and <code>contiguousPartition</code> store last know value and return wrong answer.</li> </ul> <p>There is some debug to be make until I reach above conclusion.</p> Time Submitted Status Runtime Memory Language 08/13/2023 16:11 Wrong Answer N/A N/A c <pre><code>bool contiguousPartition[2][100000] = {0};\nint isValid[100000] = {0};\nint n;\nbool isContiguousSubarrays(int x, int y) {\nif (!((x &lt; y) &amp;&amp; (y &lt; n))) return false;\nint size = y - x - 1;\nreturn contiguousPartition[size][x];\n}\nbool helper(int x, int  y){\nprintf(\"okay %d, %d\", x, y);\nif (x - 1 == y) return true;\nif (isValid[x] != 0) return isValid[x] &gt; 0;\nif (isContiguousSubarrays(x, x + 1))\nif (helper(x + 2, y)) {\nisValid[x] = 1;\nprintf(\"is true\\n\");\nreturn true;\n}\nif (isContiguousSubarrays(x, x + 2))\nif (helper(x + 3, y)) {\nisValid[x] = 1;\nprintf(\"is true\\n\");\nreturn true;\n}\nisValid[x] = -1;\nprintf(\"is false\\n\");\nreturn false;\n}\nbool validPartition(int* nums, int numsSize){\nint last, prev, curr, indexSize2, indexSize3;\nbool type1, type2, type3;\nn = numsSize;\nlast = 0; prev = 0; curr = 0;\nindexSize2 = 0; indexSize3 = 0;\nfor (int i= 0; i &lt; numsSize; i ++) {\nlast = prev;\nprev = curr;\ncurr = nums[i];\nif (prev != 0) {\ntype1 = (curr == prev);\ncontiguousPartition[0][indexSize2] = type1;\nindexSize2 += 1;\nprintf(\"%d\", contiguousPartition[0][indexSize2-1]);\n}\nif (last != 0) {\ntype2 = (last == curr &amp;&amp; curr == prev);\ntype3 = (prev - last == curr - prev &amp;&amp; curr - prev == 1);\ncontiguousPartition[1][indexSize3] = type2 || type3;\nindexSize3 += 1;\nprintf(\", %d\", contiguousPartition[1][indexSize3-1]);\n}\nprintf(\"\\n\");\n}\nreturn helper(0, n-1);\n}\n</code></pre> <p>By keeping that in mind, I just then initiation inside my main function.</p> Time Submitted Status Runtime Memory Language 08/13/2023 16:14 Accepted 122 ms 17.4 MB c <pre><code>bool contiguousPartition[2][100000] = {0};\nint isValid[100000] = {0};\nint n;\nbool isContiguousSubarrays(int x, int y) {\nif (!((x &lt; y) &amp;&amp; (y &lt; n))) return false;\nint size = y - x - 1;\nreturn contiguousPartition[size][x];\n}\nbool helper(int x, int  y){\nif (x - 1 == y) return true;\nif (isValid[x] != 0) return isValid[x] &gt; 0;\nif (isContiguousSubarrays(x, x + 1))\nif (helper(x + 2, y)) {\nisValid[x] = 1;\nreturn true;\n}\nif (isContiguousSubarrays(x, x + 2))\nif (helper(x + 3, y)) {\nisValid[x] = 1;\nreturn true;\n}\nisValid[x] = -1;\nreturn false;\n}\nbool validPartition(int* nums, int numsSize){\nint last, prev, curr, indexSize2, indexSize3;\nbool type1, type2, type3;\nlast = 0; prev = 0; curr = 0;\nindexSize2 = 0; indexSize3 = 0;\nn = numsSize;\nfor (int i= 0; i &lt; numsSize; i ++) {\nisValid[i] = 0; // &lt;== This is  the initiation needed\nlast = prev;\nprev = curr;\ncurr = nums[i];\nif (prev != 0) {\ntype1 = (curr == prev);\ncontiguousPartition[0][indexSize2] = type1;\nindexSize2 += 1;\n}\nif (last != 0) {\ntype2 = (last == curr &amp;&amp; curr == prev);\ntype3 = (prev - last == curr - prev &amp;&amp; curr - prev == 1);\ncontiguousPartition[1][indexSize3] = type2 || type3;\nindexSize3 += 1;\n}\n}\nreturn helper(0, n-1);\n}\n</code></pre> <p>Also, it seem like I the only one who done the problem in <code>c</code>, so there isn\u2019t anything to comparing.</p>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/#dynamic-programming-c-implementation", "title": "Dynamic programming - <code>c</code> implementation", "text": "<p>base on this formula <pre><code>isValid[x] = isValid[x-2] &amp;&amp; isContiguousSubarrays(x-1, x) \n            || isValid[x-3] &amp;&amp; isContiguousSubarrays(x-2, x);\n</code></pre></p> <p>We can combine both of <code>isContiguousSubarrays</code> function creation process with <code>isValid</code> in one loop. It is not that much of a jump in time complexity, but we can stop the processing if <code>isValid[i-3] == isValid[i-2] == == isValid[i-1] == false</code>, as the above formula always be <code>false</code> from <code>i</code> and above</p> Time Submitted Status Runtime Memory Language 08/13/2023 16:51 Accepted 113 ms 14.3 MB c <pre><code>bool contiguousPartition[2][100000];\nbool isValid[100001];\nint n;\nbool isContiguousSubarrays(int x, int y) {\nif (!((x &lt; y) &amp;&amp; (y &lt; n))) return false;\nint size = y - x - 1;\nreturn contiguousPartition[size][x];\n}\nbool validPartition(int* nums, int numsSize){\nint last, prev, curr, indexSize2, indexSize3;\nbool type1, type2, type3;\nlast = 0; prev = 0; curr = 0;\nindexSize2 = 0; indexSize3 = 0;\nn = numsSize;\nfor (int i= 0; i &lt; numsSize; i ++) {\nlast = prev;\nprev = curr;\ncurr = nums[i];\nif (prev != 0) {\ntype1 = (curr == prev);\ncontiguousPartition[0][indexSize2] = type1;\nindexSize2 += 1;\n}\nif (last != 0) {\ntype2 = (last == curr &amp;&amp; curr == prev);\ntype3 = (prev - last == curr - prev &amp;&amp; curr - prev == 1);\ncontiguousPartition[1][indexSize3] = type2 || type3;\nindexSize3 += 1;\n}\nif (i &gt; 2)\nif (isValid[i-2] == isValid[i-3] &amp;&amp; isValid[i-2] == isValid[i-1] &amp;&amp; isValid[i-1] == false)\nreturn false;\nisValid[i] = false;\nif (i &gt; 1)\nisValid[i] = isValid[i] || (isValid[i-2] &amp;&amp; isContiguousSubarrays(i-1, i));\nelse if (i == 1)\nisValid[i] = isValid[i] || isContiguousSubarrays(i-1, i);\nif (i &gt; 2)\nisValid[i] = isValid[i] || (isValid[i-3] &amp;&amp; isContiguousSubarrays(i-2, i));\nelse if (i == 2)\nisValid[i] =  isValid[i] || isContiguousSubarrays(i-2, i);\n}\nreturn isValid[n-1];\n}\n</code></pre> <p>Even with the most optimize version, <code>c</code> still take too long to finish, it quite weird to see x10 time compare to <code>rust</code> and <code>java</code> needed to finish (is Leetcode overhead function is the problem?)</p> Time Submitted Status Runtime Memory Language 08/13/2023 18:35 Accepted 101 ms 13.8 MB c <pre><code>bool validPartition(int* nums, int numsSize) {\nbool last = false;\nbool prev = false;\nbool curr = false;\nbool type1 = false;\nbool type2 = false;\nfor (int i = 0; i &lt; numsSize; i++) {\nbool tmp;\ntmp = false;\nif (i &gt;= 1)\ntype1 = nums[i] == nums[i-1];\nif (i &gt;= 2) type2 = (nums[i] == nums[i-1] &amp;&amp; nums[i] == nums[i-2])\n|| (nums[i] - nums[i-1] ==  nums[i-1] - nums[i-2]\n&amp;&amp; nums[i] - nums[i-1] == 1);\nif (i == 1)\ntmp = tmp || type1;\nif (i == 2)\ntmp = tmp || type2;\nif (i &gt;= 3) {\ntmp = tmp || (type1 &amp;&amp; prev);\ntmp = tmp || (type2 &amp;&amp; last);\nif (!tmp &amp;&amp; !curr &amp;&amp; !prev)\nreturn false;\n}\nlast = prev; prev = curr; curr = tmp;\n}\nreturn curr;\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/#java-re-implementation", "title": "<code>java</code> re-implementation", "text": "<ul> <li>By rewriting all of my code again. I have a new look of my code and and found out that the <code>isContiguousSubarrays</code> function and <code>contiguousPartition</code> array can be remove and we could directly calculate it on the fly</li> <li>Which make the code more compact, but also quite harder to understand how I can come up it it in the first place</li> </ul> <pre><code>class Solution {\npublic boolean validPartition(int[] nums) {\nint n = nums.length;\nboolean[] isValid = new boolean[n];\nint index = 0;\nint last = 0, prev = 0,curr = 0;\nboolean type1 = false, type2 = false;\nfor (int i: nums) {\nlast = prev; prev = curr; curr = i;\nisValid[index] = false;\nif (index &gt;= 1)\ntype1 = curr == prev;\nif (index &gt;= 2) type2 = (curr == prev &amp;&amp; curr == last)\n|| (curr - prev == prev - last &amp;&amp; curr - prev == 1);\nif (index == 1)\nisValid[index] = isValid[index] || type1;\nif (index == 2)\nisValid[index] = isValid[index] || type2;\nif (index &gt;= 3) {\nisValid[index] = isValid[index] || (type1 &amp;&amp; isValid[index-2]);\nisValid[index] = isValid[index] || (type2 &amp;&amp; isValid[index-3]);\nif (!isValid[index] &amp;&amp; !isValid[index - 1] &amp;&amp; !isValid[index -2])\nreturn false;\n}\nindex++;\n}\nreturn isValid[n-1];\n}\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2369.%20Check%20if%20There%20is%20a%20Valid%20Partition%20For%20The%20Array/#rust-reimplementation", "title": "<code>rust</code> reimplementation", "text": "<ul> <li>We also only use 4 most recently value of the <code>isValid</code> cache array, so we could remove the <code>isValid</code> array.</li> <li>It quite nice to use <code>nums.iter().enumerate()</code> which only python have the similarity <code>enumerate(nums)</code> while both <code>java</code> and <code>c</code> does not have. But in the final implementation, we don\u2019t use the value <code>&amp;v</code> anyway.</li> </ul> Time Submitted Status Runtime Memory Language 08/13/2023 18:13 Accepted 15 ms 3.5 MB rust 08/13/2023 18:04 Accepted 13 ms 3.7 MB rust <pre><code>impl Solution {\npub fn valid_partition(nums: Vec&lt;i32&gt;) -&gt; bool {\nlet mut last = false;\nlet mut prev = false;\nlet mut curr = false;\nlet mut type1 = false;\nlet mut type2 = false;\nfor (index, &amp;v) in nums.iter().enumerate() {\nlet mut tmp = false;\nif index &gt;= 1 {\ntype1 = nums[index] == nums[index-1];\n}\nif index &gt;= 2 {\ntype2 = (nums[index] == nums[index-1] &amp;&amp; nums[index] == nums[index-2]) || (nums[index] - nums[index-1] == nums[index-1] - nums[index-2] &amp;&amp; nums[index] - nums[index-1] == 1);\n}\nif index == 1 {\ntmp = tmp || type1;\n}\nif index == 2 {\ntmp = tmp || type2;\n}\nif index &gt;= 3 {\ntmp = tmp || (type1 &amp;&amp; prev);\ntmp = tmp || (type2 &amp;&amp; last);\nif !tmp &amp;&amp; !curr &amp;&amp; !prev {\nreturn false;\n}\n}\nlast = prev;\nprev = curr;\ncurr = tmp;\n}\ncurr\n}\n}\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2448.%20Minimum%20Cost%20to%20Make%20Array%20Equal/", "title": "2448. Minimum Cost to Make Array Equal", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2448.%20Minimum%20Cost%20to%20Make%20Array%20Equal/#problem", "title": "Problem", "text": "<p>You are given two 0-indexed arrays <code>nums</code> and cost consisting each of n positive integers.</p> <p>You can do the following operation any number of times:</p> <p>Increase or decrease any element of the array <code>nums</code> by 1. The cost of doing one operation on the <code>i-th</code> element is <code>cost[i]</code>.</p> <p>Return the minimum total cost such that all the elements of the array <code>nums</code> become equal.</p> <p>Example 1: <pre><code>Input: nums = [1,3,5,2], cost = [2,3,1,14]\nOutput: 8\nExplanation: We can make all the elements equal to 2 in the following way:\n\n- Increase the 0th element one time. The cost is 2.\n- Decrease the 1st element one time. The cost is 3.\n- Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3.\nThe total cost is 2 + 3 + 3 = 8.\nIt can be shown that we cannot make the array equal with a smaller cost.\n</code></pre></p> <p>Example 2: <pre><code>Input: nums = [2,2,2,2,2], cost = [4,2,8,1,3]\nOutput: 0\nExplanation: All the elements are already equal, so no operations are needed.\n</code></pre></p> <p>Constraints:</p> <ul> <li><code>n == nums.length == cost.length</code></li> <li><code>1 &lt;= n &lt;= 105</code></li> <li><code>1 &lt;= nums[i], cost[i] &lt;= 106</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2448.%20Minimum%20Cost%20to%20Make%20Array%20Equal/#solution", "title": "Solution", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2448.%20Minimum%20Cost%20to%20Make%20Array%20Equal/#overview", "title": "Overview", "text": "<ol> <li> <p>Assuming result always try to match one of the number inside the array - It easy to conclude that the <code>equal value</code> that we trying to find in in between min - max of the array (or else they are the min or max of the array) - We can just using binary search if the assumption isn\u2019t true, with left and right start at min - max</p> </li> <li> <p>If you can calculate the cost given a specific equal value it in <code>O(1)</code> time. The handling process rely on the fact that if you can separating all the increase / decrease part of the array, with each change quickly or not.</p> <ul> <li>After sorting the provided <code>nums</code>, which cost <code>O(n log n)</code></li> <li>We can separating increase / decrease part  in half by <code>O(1)</code> if we tryout each <code>nums</code> in sorted order; or <code>O(log n)</code> in-case we using binary search</li> <li>Then the problem becoming <code>O(n)</code> to tryout all <code>nums</code>; or <code>O(log (max - min))</code> in-case we using binary search</li> <li>We can achieve <code>O(1)</code> time complexity calculate the cost given a specific equal value this by just pre-calculating all array range with Dynamic Programming Sub array-Sum</li> <li>Overall, a <code>O(n log n) + O(n)*O(1)</code> or <code>O(n log n) + O(log n)* O(log (max - min)) *O(1)</code></li> </ul> </li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2448.%20Minimum%20Cost%20to%20Make%20Array%20Equal/#implement", "title": "Implement", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2448.%20Minimum%20Cost%20to%20Make%20Array%20Equal/#on-log-n-ono1", "title": "<code>O(n log n) + O(n)*O(1)</code>", "text": "<pre><code>class Solution:\ndef minCost(self, nums: List[int], cost: List[int]) -&gt; int:\narr = list(zip(nums, cost))\narr.sort()\nsumCost = [0] * len(arr)\nfor i, (_, cost) in enumerate(arr):\nsumCost[i] += cost\nif i &gt; 0:\nsumCost[i] += sumCost[i-1]\ndef sumRange(sumCost, left, right):\nif left == -1:\nreturn sumCost[right]\nreturn sumCost[right] - sumCost[left]\nminNums = min(nums)\nres = [0] * len(arr)\nres[0] = sum([(num - minNums) * cost for num, cost in arr])\nfor i in range(1, len(arr)):\npreNum, preCost = arr[i-1]\nnum, cost = arr[i]\nres[i] = res[i - 1]\nres[i] += sumRange(sumCost, -1, i-1) * (-preNum + num)\nres[i] -= sumRange(sumCost, i-1, len(arr) - 1) * (num - preNum)\nreturn min(res)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2448.%20Minimum%20Cost%20to%20Make%20Array%20Equal/#on-log-n-olog-n-olog-max-min-o1-wrong-first-thought-tho", "title": "<code>O(n log n) + O(log n)* O(log (max - min)) *O(1)</code> (WRONG - FIRST THOUGHT THO)", "text": "<pre><code>class Solution:\ndef minCost(self, nums: List[int], cost: List[int]) -&gt; int:\narr = list(zip(nums, cost))\narr.sort()\nsumCost = [0] * len(arr)\nfor i, (_, cost) in enumerate(arr):\nsumCost[i] += cost\nif i &gt; 0:\nsumCost[i] += sumCost[i-1]\ndef sumRange(sumCost, left, right):\nif left == -1:\nreturn sumCost[right]\nreturn sumCost[right] - sumCost[left]\nminNums = min(nums)\nexampleRes = sum([(num - minNums) * cost for num, cost in arr])\ndef findCut(arr, value):\nleft = -1\nright = len(arr)\nwhile True:\nmid = (left + right)// 2\nif left == mid:\nbreak\nif arr[mid] &lt;= value:\nleft = mid\nelse:\nright = mid\nreturn right\nmaxNums = max(nums)\nleft = minNums-1\nright = maxNums+1\nwhile True:\nmid = (left + right)// 2\ncutIndex = findCut(arr, mid)\ntestRes = exampleRes\ntestRes += sumRange(sumCost, -1, cutIndex) * (num - minNums)\ntestRes -= sumRange(sumCost, cutIndex, len(arr) - 1) * (num -  minNums)\nreturn min(res)\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2462.%20Total%20Cost%20to%20Hire%20K%20Workers/", "title": "2462. Total Cost to Hire K Workers", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2462.%20Total%20Cost%20to%20Hire%20K%20Workers/#problem", "title": "Problem", "text": "<p>You are given a 0-indexed integer array <code>costs</code> where <code>costs[i]</code> is the cost of hiring the <code>ith</code> worker.</p> <p>You are also given two integers <code>k</code> and <code>candidates</code>. We want to hire exactly <code>k</code> workers according to the following rules:</p> <ul> <li>You will run <code>k</code> sessions and hire exactly one worker in each session.</li> <li>In each hiring session, choose the worker with the lowest cost from either the first <code>candidates</code> workers or the last <code>candidates</code> workers. Break the tie by the smallest index.<ul> <li>For example, if <code>costs = [3,2,7,7,1,2]</code> and <code>candidates = 2</code>, then in the first hiring session, we will choose the <code>4th</code> worker because they have the lowest cost <code>[3,2,7,7,**1**,2]</code>.</li> <li>In the second hiring session, we will choose <code>1st</code> worker because they have the same lowest cost as <code>4th</code> worker but they have the smallest index <code>[3,**2**,7,7,2]</code>. Please note that the indexing may be changed in the process.</li> </ul> </li> <li>If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.</li> <li>A worker can only be chosen once.</li> </ul> <p>Return the total cost to hire exactly <code>k</code> workers.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= costs.length &lt;= 10**5</code></li> <li><code>1 &lt;= costs[i] &lt;= 10**5</code></li> <li><code>1 &lt;= k, candidates &lt;= costs.length</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2462.%20Total%20Cost%20to%20Hire%20K%20Workers/#reevaluate", "title": "Reevaluate", "text": "<ul> <li>A find min problem: Heap, Min Binary Tree</li> <li>We only need to find the lowest cost in first  <code>cost[0:candidates]</code>  and last <code>cost[len-1 - candidates : len]</code>, so we could used some dynamic left right pointer and a: Heap</li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2462.%20Total%20Cost%20to%20Hire%20K%20Workers/#solving-with-heap", "title": "Solving with heap", "text": "<ol> <li>Create a <code>left</code> heap and <code>right</code> heap</li> <li>Push <code>cost[0:candidates]</code> to <code>left</code> heap and <code>cost[len-1 - candidates : len]</code> to <code>right</code> heap</li> <li>Pop ether head of <code>left</code> and <code>right</code> heap then push next correspond from cost table back to the heap</li> <li>Run it <code>k</code> time</li> </ol>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2462.%20Total%20Cost%20to%20Hire%20K%20Workers/#actual-code", "title": "Actual code", "text": "<pre><code>class Solution:\ndef totalCost(self, costs: List[int], k: int, candidates: int) -&gt; int:\nleft = []\nright = []\nfor value in costs[:candidates]:\nheapq.heappush(left, value)\nfor value in costs[max(candidates, len(costs) - candidates):]:\nheapq.heappush(right, value)\npointerLeft = candidates - 1\npointerRight = len(costs) - candidates\ntotal = 0\nfor i in range(k):\nif left == [] and right == []:\nbreak\nif left == []:\ntotal += heapq.heappop(right)\ncontinue\nelif right == []:\ntotal += heapq.heappop(left)\ncontinue\nif left[0] &lt;= right[0]:\ntotal += heapq.heappop(left)\nif pointerLeft + 1 &lt; pointerRight:\npointerLeft += 1\nheapq.heappush(left, costs[pointerLeft])\nelse:\ntotal += heapq.heappop(right)\nif pointerLeft &lt; pointerRight - 1:\npointerRight -= 1\nheapq.heappush(right, costs[pointerRight])\nreturn total\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2616.%20Minimize%20the%20Maximum%20Difference%20of%20Pairs/", "title": "2616. Minimize the Maximum Difference of Pairs", "text": "", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2616.%20Minimize%20the%20Maximum%20Difference%20of%20Pairs/#problem", "title": "Problem", "text": "<p>You are given a 0-indexed integer array <code>nums</code> and an integer <code>p</code>. Find <code>p</code> pairs of indices of <code>nums</code> such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the <code>p</code> pairs.</p> <p>Note that for a pair of elements at the index <code>i</code> and <code>j</code>, the difference of this pair is <code>|nums[i] - nums[j]|</code>, where <code>|x|</code> represents the absolute value of <code>x</code>.</p> <p>Return the minimum maximum difference among all <code>p</code> pairs. We define the maximum of an empty set to be zero.</p> <p>Example 1:</p> <p>Input: nums = [10,1,2,7,1,3], p = 2 Output: 1 Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5.  The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.</p> <p>Example 2:</p> <p>Input: nums = [4,2,1,2], p = 1 Output: 0 Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 105</code></li> <li><code>0 &lt;= nums[i] &lt;= 109</code></li> <li><code>0 &lt;= p &lt;= (nums.length)/2</code></li> </ul>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "notes/Leetcode%201000-10000/2616.%20Minimize%20the%20Maximum%20Difference%20of%20Pairs/#solve", "title": "Solve", "text": "<pre><code>class Solution:\ndef minimizeMax(self, nums: List[int], p: int) -&gt; int:\nnums.sort()\n# Choosing pair base on sorted number, get mimimal number\n# (1,2) (3,4) (...) (2p-1, 2p)\ndef greedy(self, nums):\ndef helper(x,y):\nreturn nums[y] - nums[x]\nminimize = None\nfor i in range(0,len(nums), 2):\nif minimize is None:\nminimize = helper(i, i+1)\nelif minimize &gt; helper(i, i+1):\nminimize = helper(i, i+1)\nreturn minimize\n# We can chosing number base on their distinct, from lowest to largest\n# Keeping track of all added pair to make sure we adding not visided number\ndef smarter(self, nums)\ndef helper(x,y):\nreturn nums[y] - nums[x]\n# By sorting, we rounded down possible pair to choose to adj number only\n# by example [1,2,3,4] right next to each other\n# -&gt; We can only choing [1,2] [3,4] or [2,3] [1,4]. But because of sorting\n# [1,4] &gt; any of ([1,2] [2,3] [3,4])\n# -&gt; We won't using any pair that isn't adj each other\npossible_pair = []\nfor i in range(0, len(num)):\npair = [i, i+1]\npossible_pair.append( pair )\ndef sortkey(x):\nreturn helper(*x)\npossible_pair.sort(key = sortkey)\n# Checking and pushing each pair from the lowest to highest isn't possible\n# As we need to take care a lot of vairable stage\n\"\"\"queue = []\n        while queue:\n            pair, diff = possible_pair.pop()\n            visited_number\n            queue.append(visited_number)\"\"\"\n# Instead, we can try to using some dynamic programing and maximize the\n# pair that we can choose step by step in avaiable possible_pair \nmax_pair = []\nfor x, y in possible_pair:\n</code></pre>", "tags": ["leetcode", "computer_sience", "coding_chalenge"]}, {"location": "tags/", "title": "Tags", "text": ""}, {"location": "tags/#bfs", "title": "BFS", "text": "<ul> <li>46. Permutations</li> <li>542. 01 Matrix</li> </ul>"}, {"location": "tags/#array", "title": "array", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>215. Kth Largest Element in an Array</li> <li>274. H Index</li> </ul>"}, {"location": "tags/#binary_search", "title": "binary_search", "text": "<ul> <li>74. Search a 2D Matrix</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>274. H Index</li> </ul>"}, {"location": "tags/#bit_manipulation", "title": "bit_manipulation", "text": "<ul> <li>50. Pow(x, n)</li> </ul>"}, {"location": "tags/#c", "title": "c", "text": "<ul> <li>50. Pow(x, n)</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> </ul>"}, {"location": "tags/#cache", "title": "cache", "text": "<ul> <li>84. Largest Rectangle in Histogram</li> </ul>"}, {"location": "tags/#coding_chalenge", "title": "coding_chalenge", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>50. Pow(x, n)</li> <li>55. Jump Game</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>77. Combinations</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>86. Partition List</li> <li>88. Merge Sorted Array</li> <li>91. Decode Ways</li> <li>94. Binary Tree Inorder Traversal</li> <li>98. Validate Binary Search Tree</li> <li>101. Symmetric Tree</li> <li>102. Binary Tree Level Order Traversal</li> <li>103. Binary Tree Zigzag Level Order Traversal</li> <li>104. Maximum Depth of Binary Tree</li> <li>108. Convert Sorted Array to Binary Search Tree</li> <li>116. Populating Next Right Pointers in Each Node</li> <li>118. Pascal\u2019s Triangle</li> <li>121. Best Time to Buy and Sell Stock</li> <li>122. Best Time to Buy and Sell Stock II</li> <li>124. Binary Tree Maximum Path Sum</li> <li>125. Valid Palindrome</li> <li>130. Surrounded Regions</li> <li>131. Palindrome Partitioning</li> <li>134. Gas Station</li> <li>136. Single Number</li> <li>139. Word Break</li> <li>141. Linked List Cycle</li> <li>146. LRU Cache</li> <li>169. Majority Element</li> <li>171. Excel Sheet Column Number</li> <li>190. Reverse Bits</li> <li>191. Number of 1 Bits</li> <li>202. Happy Number</li> <li>206. Reverse Linked List</li> <li>207. Course Schedule</li> <li>215. Kth Largest Element in an Array</li> <li>217. Contains Duplicate</li> <li>234. Palindrome Linked List</li> <li>239. Sliding Window Maximum</li> <li>242. Valid Anagram</li> <li>268. Missing Number</li> <li>274. H Index</li> <li>283. Move Zeroes</li> <li>326. Power of Three</li> <li>344. Reverse String</li> <li>350. Intersection of Two Arrays II</li> <li>373. Find K Pairs with Smallest Sums</li> <li>380. Insert Delete GetRandom O(1)</li> <li>387. First Unique Character in a String</li> <li>412. Fizz Buzz</li> <li>435. Non overlapping Intervals</li> <li>445. Add Two Numbers II</li> <li>518. Coin Change II</li> <li>530. Minimum Absolute Difference in BST</li> <li>542. 01 Matrix</li> <li>688. Knight Probability in Chessboard</li> <li>712. Minimum ASCII Delete Sum for Two Strings</li> <li>714. Best Time to Buy and Sell Stock with Transaction Fee</li> <li>735. Asteroid Collision</li> <li>802. Find Eventual Safe States</li> <li>852. Peak Index in a Mountain Array</li> <li>859. Buddy Strings</li> <li>894. All Possible Full Binary Trees</li> <li>1125. Smallest Sufficient Team</li> <li>1143. Longest Common Subsequence</li> <li>1569. Number of Ways to Reorder Array to Get Same BST</li> <li>1601. Maximum Number of Achievable Transfer Requests</li> <li>1615. Maximal Network Rank</li> <li>1751. Maximum Number of Events That Can Be Attended II</li> <li>1802. Maximum Value at a Given Index in a Bounded Array</li> <li>2008. Maximum Earnings From Taxi</li> <li>2140. Questions With Brainpower</li> <li>2141. Maximum Running Time of N Computers</li> <li>2328. Number of Increasing Paths in a Grid</li> <li>2352. Equal Row and Column Pairs   solve</li> <li>2369. Check if There is a Valid Partition For The Array</li> <li>2448. Minimum Cost to Make Array Equal</li> <li>2462. Total Cost to Hire K Workers</li> <li>2616. Minimize the Maximum Difference of Pairs</li> </ul>"}, {"location": "tags/#computer_sience", "title": "computer_sience", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>50. Pow(x, n)</li> <li>55. Jump Game</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>77. Combinations</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>86. Partition List</li> <li>88. Merge Sorted Array</li> <li>91. Decode Ways</li> <li>94. Binary Tree Inorder Traversal</li> <li>98. Validate Binary Search Tree</li> <li>101. Symmetric Tree</li> <li>102. Binary Tree Level Order Traversal</li> <li>103. Binary Tree Zigzag Level Order Traversal</li> <li>104. Maximum Depth of Binary Tree</li> <li>108. Convert Sorted Array to Binary Search Tree</li> <li>116. Populating Next Right Pointers in Each Node</li> <li>118. Pascal\u2019s Triangle</li> <li>121. Best Time to Buy and Sell Stock</li> <li>122. Best Time to Buy and Sell Stock II</li> <li>124. Binary Tree Maximum Path Sum</li> <li>125. Valid Palindrome</li> <li>130. Surrounded Regions</li> <li>131. Palindrome Partitioning</li> <li>134. Gas Station</li> <li>136. Single Number</li> <li>139. Word Break</li> <li>141. Linked List Cycle</li> <li>146. LRU Cache</li> <li>169. Majority Element</li> <li>171. Excel Sheet Column Number</li> <li>190. Reverse Bits</li> <li>191. Number of 1 Bits</li> <li>202. Happy Number</li> <li>206. Reverse Linked List</li> <li>207. Course Schedule</li> <li>215. Kth Largest Element in an Array</li> <li>217. Contains Duplicate</li> <li>234. Palindrome Linked List</li> <li>239. Sliding Window Maximum</li> <li>242. Valid Anagram</li> <li>268. Missing Number</li> <li>274. H Index</li> <li>283. Move Zeroes</li> <li>326. Power of Three</li> <li>344. Reverse String</li> <li>350. Intersection of Two Arrays II</li> <li>373. Find K Pairs with Smallest Sums</li> <li>380. Insert Delete GetRandom O(1)</li> <li>387. First Unique Character in a String</li> <li>412. Fizz Buzz</li> <li>435. Non overlapping Intervals</li> <li>445. Add Two Numbers II</li> <li>518. Coin Change II</li> <li>530. Minimum Absolute Difference in BST</li> <li>542. 01 Matrix</li> <li>688. Knight Probability in Chessboard</li> <li>712. Minimum ASCII Delete Sum for Two Strings</li> <li>714. Best Time to Buy and Sell Stock with Transaction Fee</li> <li>735. Asteroid Collision</li> <li>802. Find Eventual Safe States</li> <li>852. Peak Index in a Mountain Array</li> <li>859. Buddy Strings</li> <li>894. All Possible Full Binary Trees</li> <li>1125. Smallest Sufficient Team</li> <li>1143. Longest Common Subsequence</li> <li>1569. Number of Ways to Reorder Array to Get Same BST</li> <li>1601. Maximum Number of Achievable Transfer Requests</li> <li>1615. Maximal Network Rank</li> <li>1751. Maximum Number of Events That Can Be Attended II</li> <li>1802. Maximum Value at a Given Index in a Bounded Array</li> <li>2008. Maximum Earnings From Taxi</li> <li>2140. Questions With Brainpower</li> <li>2141. Maximum Running Time of N Computers</li> <li>2328. Number of Increasing Paths in a Grid</li> <li>2352. Equal Row and Column Pairs   solve</li> <li>2369. Check if There is a Valid Partition For The Array</li> <li>2448. Minimum Cost to Make Array Equal</li> <li>2462. Total Cost to Hire K Workers</li> <li>2616. Minimize the Maximum Difference of Pairs</li> </ul>"}, {"location": "tags/#divide_and_conquer", "title": "divide_and_conquer", "text": "<ul> <li>215. Kth Largest Element in an Array</li> </ul>"}, {"location": "tags/#dynamic_programing", "title": "dynamic_programing", "text": "<ul> <li>55. Jump Game</li> </ul>"}, {"location": "tags/#dynamic_programming", "title": "dynamic_programming", "text": "<ul> <li>63. Unique Paths II</li> </ul>"}, {"location": "tags/#graph", "title": "graph", "text": "<ul> <li>1615. Maximal Network Rank</li> </ul>"}, {"location": "tags/#heap_c_lang", "title": "heap_c_lang", "text": "<ul> <li>74. Search a 2D Matrix</li> </ul>"}, {"location": "tags/#java", "title": "java", "text": "<ul> <li>63. Unique Paths II</li> <li>80. Remove Duplicates from Sorted Array II</li> </ul>"}, {"location": "tags/#leetcode", "title": "leetcode", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>50. Pow(x, n)</li> <li>55. Jump Game</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>77. Combinations</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> <li>86. Partition List</li> <li>88. Merge Sorted Array</li> <li>91. Decode Ways</li> <li>94. Binary Tree Inorder Traversal</li> <li>98. Validate Binary Search Tree</li> <li>101. Symmetric Tree</li> <li>102. Binary Tree Level Order Traversal</li> <li>103. Binary Tree Zigzag Level Order Traversal</li> <li>104. Maximum Depth of Binary Tree</li> <li>108. Convert Sorted Array to Binary Search Tree</li> <li>116. Populating Next Right Pointers in Each Node</li> <li>118. Pascal\u2019s Triangle</li> <li>121. Best Time to Buy and Sell Stock</li> <li>122. Best Time to Buy and Sell Stock II</li> <li>124. Binary Tree Maximum Path Sum</li> <li>125. Valid Palindrome</li> <li>130. Surrounded Regions</li> <li>131. Palindrome Partitioning</li> <li>134. Gas Station</li> <li>136. Single Number</li> <li>139. Word Break</li> <li>141. Linked List Cycle</li> <li>146. LRU Cache</li> <li>169. Majority Element</li> <li>171. Excel Sheet Column Number</li> <li>190. Reverse Bits</li> <li>191. Number of 1 Bits</li> <li>202. Happy Number</li> <li>206. Reverse Linked List</li> <li>207. Course Schedule</li> <li>215. Kth Largest Element in an Array</li> <li>217. Contains Duplicate</li> <li>234. Palindrome Linked List</li> <li>239. Sliding Window Maximum</li> <li>242. Valid Anagram</li> <li>268. Missing Number</li> <li>274. H Index</li> <li>283. Move Zeroes</li> <li>326. Power of Three</li> <li>344. Reverse String</li> <li>350. Intersection of Two Arrays II</li> <li>373. Find K Pairs with Smallest Sums</li> <li>380. Insert Delete GetRandom O(1)</li> <li>387. First Unique Character in a String</li> <li>412. Fizz Buzz</li> <li>435. Non overlapping Intervals</li> <li>445. Add Two Numbers II</li> <li>518. Coin Change II</li> <li>530. Minimum Absolute Difference in BST</li> <li>542. 01 Matrix</li> <li>688. Knight Probability in Chessboard</li> <li>712. Minimum ASCII Delete Sum for Two Strings</li> <li>714. Best Time to Buy and Sell Stock with Transaction Fee</li> <li>735. Asteroid Collision</li> <li>802. Find Eventual Safe States</li> <li>852. Peak Index in a Mountain Array</li> <li>859. Buddy Strings</li> <li>894. All Possible Full Binary Trees</li> <li>1125. Smallest Sufficient Team</li> <li>1143. Longest Common Subsequence</li> <li>1569. Number of Ways to Reorder Array to Get Same BST</li> <li>1601. Maximum Number of Achievable Transfer Requests</li> <li>1615. Maximal Network Rank</li> <li>1751. Maximum Number of Events That Can Be Attended II</li> <li>1802. Maximum Value at a Given Index in a Bounded Array</li> <li>2008. Maximum Earnings From Taxi</li> <li>2140. Questions With Brainpower</li> <li>2141. Maximum Running Time of N Computers</li> <li>2328. Number of Increasing Paths in a Grid</li> <li>2352. Equal Row and Column Pairs   solve</li> <li>2369. Check if There is a Valid Partition For The Array</li> <li>2448. Minimum Cost to Make Array Equal</li> <li>2462. Total Cost to Hire K Workers</li> <li>2616. Minimize the Maximum Difference of Pairs</li> </ul>"}, {"location": "tags/#matrix", "title": "matrix", "text": "<ul> <li>74. Search a 2D Matrix</li> </ul>"}, {"location": "tags/#network", "title": "network", "text": "<ul> <li>LAP 1   Routing</li> </ul>"}, {"location": "tags/#python", "title": "python", "text": "<ul> <li>33. Search in Rotated Sorted Array</li> <li>45. Jump Game II</li> <li>46. Permutations</li> <li>50. Pow(x, n)</li> <li>55. Jump Game</li> <li>63. Unique Paths II</li> <li>74. Search a 2D Matrix</li> <li>77. Combinations</li> <li>80. Remove Duplicates from Sorted Array II</li> <li>81. Search in Rotated Sorted Array II</li> <li>84. Largest Rectangle in Histogram</li> </ul>"}, {"location": "tags/#recusion", "title": "recusion", "text": "<ul> <li>50. Pow(x, n)</li> <li>77. Combinations</li> </ul>"}, {"location": "tags/#runtime_memory_alocation", "title": "runtime_memory_alocation", "text": "<ul> <li>74. Search a 2D Matrix</li> </ul>"}, {"location": "tags/#rust", "title": "rust", "text": "<ul> <li>63. Unique Paths II</li> </ul>"}, {"location": "tags/#sort", "title": "sort", "text": "<ul> <li>215. Kth Largest Element in an Array</li> </ul>"}, {"location": "tags/#stack_c_lang", "title": "stack_c_lang", "text": "<ul> <li>74. Search a 2D Matrix</li> </ul>"}, {"location": "tags/#tree", "title": "tree", "text": "<ul> <li>1569. Number of Ways to Reorder Array to Get Same BST</li> </ul>"}]}